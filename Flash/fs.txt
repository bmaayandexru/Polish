; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\flash\fs.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\fs.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\Main -I.\Drivers -I.\Drivers\include -I.\UCNC -ID:\Projects\Frezer\Frezer.keil\01020124\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\LPC1700_DFP\2.3.0\Device\Include -D__UVISION_VERSION=517 -D_RTE_ -DLPC175x_6x --omf_browse=.\flash\fs.crf Main\FS.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FS_Init PROC
;;;174    //-----------------------------------------------------------------------------
;;;175    s8 FS_Init(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;176    	u8 i;
;;;177    //-	отставляем пока------------------------------------
;;;178    	u8 bank_num;
;;;179    	u8 ID;
;;;180    
;;;181    	FLASH_BANKS_NUM = 0;
000002  4cf8              LDR      r4,|L1.996|
000004  2500              MOVS     r5,#0
;;;182    	FS_IS_INITED = 0;															// Обнулить кол-во банков FLASH-памяти
;;;183    
;;;184    	// Опросить наличие банков
;;;185    	for (bank_num = 0; bank_num < 4; bank_num++) {
000006  462e              MOV      r6,r5
000008  7025              STRB     r5,[r4,#0]            ;181
00000a  7065              STRB     r5,[r4,#1]            ;182
                  |L1.12|
;;;186    		//	где функция FLASH_GetBankID ?????????? 
;;;187    		ID = FLASH_GetBankID(bank_num);
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       FLASH_GetBankID
;;;188    //		Msg("B %d ID %X\r\n",bank_num,ID);
;;;189    		if (ID == 0x18) {							// Если ID = 18h (тип флэш-памяти M25P128)
000012  2818              CMP      r0,#0x18
000014  d106              BNE      |L1.36|
;;;190    			FLASH_BANKS_NUM++;													// ДА - Увеличить кол-во банков
000016  7820              LDRB     r0,[r4,#0]  ; FLASH_BANKS_NUM
000018  1c76              ADDS     r6,r6,#1
00001a  1c40              ADDS     r0,r0,#1
00001c  b2f6              UXTB     r6,r6                 ;185
00001e  7020              STRB     r0,[r4,#0]
000020  2e04              CMP      r6,#4                 ;185
000022  d3f3              BCC      |L1.12|
                  |L1.36|
;;;191    		}
;;;192    //		if (FLASH_GetBankID(bank_num) == 0x18) {							// Если ID = 18h (тип флэш-памяти M25P128)
;;;193    //			FLASH_BANKS_NUM++;													// ДА - Увеличить кол-во банков
;;;194    //		}
;;;195    		else {
;;;196    			break;															// НЕТ - Завершить опрос банков
;;;197    		}
;;;198    	}
;;;199    //	Msg("FBN %d\r\n",FLASH_BANKS_NUM);
;;;200    	if (! FLASH_BANKS_NUM) {														// Обнаружены банки Флэш-памяти?
000024  7820              LDRB     r0,[r4,#0]  ; FLASH_BANKS_NUM
;;;201    		return EFS_FLASH_NOT_INITED;														// НЕТ - Вернуть результат: "Флэш-память не инициализирована"
000026  f04f36ff          MOV      r6,#0xffffffff
00002a  b130              CBZ      r0,|L1.58|
;;;202    	}
;;;203    //----Будет так--------------------------------------
;;;204    // 	res = FLASH_Init();
;;;205    //	if (res < 0) {
;;;206    //  	// в res код ошибки
;;;207    //	}	 
;;;208    	// Проверить состояние ФС
;;;209    	FS_STATE = FLASH_ReadByte(FS_PARAM_FS_STATE);
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       FLASH_ReadByte
000032  70a0              STRB     r0,[r4,#2]
;;;210    
;;;211    	// Если "Чистая FLASH"
;;;212    	if (FS_STATE == FS_STATE_FLASH_CLEAR) {
000034  28ff              CMP      r0,#0xff
000036  d002              BEQ      |L1.62|
000038  e006              B        |L1.72|
                  |L1.58|
00003a  4630              MOV      r0,r6                 ;201
;;;213    
;;;214    		// Установить состояние ФС = "ФС готова к работе"
;;;215    		//---------------------------------------------------------------
;;;216    		FS_STATE = FS_STATE_READY;
;;;217    		FLASH_WriteByte(FS_PARAM_FS_STATE, FS_STATE);
;;;218    	}
;;;219    	// Если "ФС готова к работе"
;;;220    	else if (FS_STATE == FS_STATE_READY) {
;;;221    
;;;222    	}
;;;223    
;;;224    	// Вычислить рабочие параметры ФС
;;;225    	//---------------------------------------------------------------
;;;226    	SECTORS_NUMBER = FLASH_BANKS_NUM * FLASH_SECTORS_PER_BANK;						// Кол-во секторов
;;;227    	SECTOR_SIZE = FLASH_PAGES_PER_SECTOR * PAGE_SIZE;								// Размер сектора
;;;228    
;;;229    	CLUSTERS_PER_SECTOR = FLASH_PAGES_PER_SECTOR / PAGES_PER_CLUSTER;				// Кол-во кластеров в секторе
;;;230    	CLUSTERS_NUMBER = (SECTORS_NUMBER - 3) * CLUSTERS_PER_SECTOR;					// Кол-во кластеров
;;;231    	CLUSTER_SIZE = PAGES_PER_CLUSTER * PAGE_SIZE;									// Размер кластера
;;;232    
;;;233    	// Размер отводимый для размещения таблицы CAT
;;;234    	CAT_Size = CLUSTERS_NUMBER * CAT_RECORD_SIZE / FNT_RECORD_SIZE * FNT_RECORD_SIZE;
;;;235    	if ( (CLUSTERS_NUMBER * CAT_RECORD_SIZE) % FNT_RECORD_SIZE ) {
;;;236    		CAT_Size += FNT_RECORD_SIZE;												// (округлить в бо'льшую сторону)
;;;237    	}
;;;238    	CATRecordsNumber = CLUSTERS_NUMBER;												// Кол-во записей в таблице CAT
;;;239    
;;;240    	FNTRecordsNumber = ( (SECTOR_SIZE - CAT_Size) / FNT_RECORD_SIZE ) - 1;			// Кол-во записей в таблице FNT
;;;241    
;;;242    	CAT_BASE_ADDRESS = FNT_BASE_ADDRESS +
;;;243    					   FNTRecordsNumber * FNT_RECORD_SIZE;							// Базовый адрес таблицы CAT
;;;244    	CLUSTERS_BASE_ADDRESS = SECTOR_SIZE * 3;										// Базовый адрес таблицы кластеров
;;;245    
;;;246    	ClusterMAX   = CLUSTERS_NUMBER  - 1;											// Номер максимального кластера
;;;247    	CATRecordMAX = CATRecordsNumber - 1;											// Номер максимальной записи в таблице CAT
;;;248    	FNTRecordMAX = FNTRecordsNumber - 1;											// Номер максимальной записи в таблице FNT
;;;249    
;;;250    	// Заполнить массив указателей на стркутуры FCS
;;;251    	for (i=0; i<MAX_FILES; i++) {
;;;252    		pFCSArray[i] = FCSArray + i;
;;;253    	}
;;;254    
;;;255    	// Состояние всех структур FCS = "Закрыто"
;;;256    	for (i=0; i<MAX_FILES; i++) {
;;;257    		pFCSArray[i]->State = FCS_STATE_CLOSED ;
;;;258    	}
;;;259    // отладка потом убрать
;;;260    //	return 0;
;;;261    
;;;262    	FS_IS_INITED = 1;															// Файловая система инициализирована
;;;263    
;;;264    	return FS_RESULT_OK;// 0
;;;265    }
00003c  bd70              POP      {r4-r6,pc}
                  |L1.62|
00003e  21fc              MOVS     r1,#0xfc              ;216
000040  70a1              STRB     r1,[r4,#2]            ;216
000042  2000              MOVS     r0,#0                 ;217
000044  f7fffffe          BL       FLASH_WriteByte
                  |L1.72|
000048  7820              LDRB     r0,[r4,#0]            ;226  ; FLASH_BANKS_NUM
00004a  f44f2180          MOV      r1,#0x40000           ;227
00004e  0180              LSLS     r0,r0,#6              ;226
000050  80a0              STRH     r0,[r4,#4]            ;226
000052  6161              STR      r1,[r4,#0x14]         ;229  ; SECTOR_SIZE
000054  1ec0              SUBS     r0,r0,#3              ;229
000056  2110              MOVS     r1,#0x10              ;229
000058  0500              LSLS     r0,r0,#20             ;230
00005a  80e1              STRH     r1,[r4,#6]            ;229
00005c  0c00              LSRS     r0,r0,#16             ;230
00005e  0289              LSLS     r1,r1,#10             ;231
000060  8120              STRH     r0,[r4,#8]            ;230
000062  81a1              STRH     r1,[r4,#0xc]          ;231
000064  eb000140          ADD      r1,r0,r0,LSL #1       ;234
000068  f021011f          BIC      r1,r1,#0x1f           ;234
00006c  eb000240          ADD      r2,r0,r0,LSL #1       ;235
000070  61a1              STR      r1,[r4,#0x18]         ;235  ; CAT_Size
000072  06d2              LSLS     r2,r2,#27             ;235
000074  d001              BEQ      |L1.122|
000076  3120              ADDS     r1,r1,#0x20           ;235
000078  61a1              STR      r1,[r4,#0x18]         ;236  ; CAT_Size
                  |L1.122|
00007a  f5c12180          RSB      r1,r1,#0x40000        ;240
00007e  81e0              STRH     r0,[r4,#0xe]          ;238
000080  eb061151          ADD      r1,r6,r1,LSR #5       ;240
000084  2220              MOVS     r2,#0x20              ;242
000086  eb021241          ADD      r2,r2,r1,LSL #5       ;242
00008a  6262              STR      r2,[r4,#0x24]         ;244  ; CAT_BASE_ADDRESS
00008c  61e1              STR      r1,[r4,#0x1c]         ;244  ; FNTRecordsNumber
00008e  f44f2240          MOV      r2,#0xc0000           ;244
000092  1e40              SUBS     r0,r0,#1              ;244
000094  62a2              STR      r2,[r4,#0x28]         ;246  ; CLUSTERS_BASE_ADDRESS
000096  8160              STRH     r0,[r4,#0xa]          ;246
000098  8220              STRH     r0,[r4,#0x10]         ;247
00009a  1e49              SUBS     r1,r1,#1              ;247
00009c  4ad2              LDR      r2,|L1.1000|
00009e  6221              STR      r1,[r4,#0x20]         ;252  ; FNTRecordMAX
0000a0  2000              MOVS     r0,#0                 ;251
0000a2  f1a20120          SUB      r1,r2,#0x20           ;252
0000a6  bf00              NOP                            ;252
                  |L1.168|
0000a8  f2401343          MOV      r3,#0x143             ;252
0000ac  fb032300          MLA      r3,r3,r0,r2           ;252
0000b0  f8413020          STR      r3,[r1,r0,LSL #2]     ;252
0000b4  1c40              ADDS     r0,r0,#1              ;252
0000b6  b2c0              UXTB     r0,r0                 ;251
0000b8  2808              CMP      r0,#8                 ;251
0000ba  d3f5              BCC      |L1.168|
0000bc  f05f0000          MOVS.W   r0,#0                 ;256
                  |L1.192|
0000c0  f8512020          LDR      r2,[r1,r0,LSL #2]     ;257
0000c4  1c40              ADDS     r0,r0,#1              ;257
0000c6  b2c0              UXTB     r0,r0                 ;256
0000c8  7015              STRB     r5,[r2,#0]            ;257
0000ca  2808              CMP      r0,#8                 ;256
0000cc  d3f8              BCC      |L1.192|
0000ce  2001              MOVS     r0,#1                 ;262
0000d0  7060              STRB     r0,[r4,#1]            ;262
0000d2  2000              MOVS     r0,#0                 ;264
0000d4  bd70              POP      {r4-r6,pc}
;;;266    
                          ENDP

                  FS_StrSymbolsValid PROC
;;;270    //-----------------------------------------------------------------------------
;;;271    bool FS_StrSymbolsValid(const u8 *str) {
0000d6  b510              PUSH     {r4,lr}
0000d8  4604              MOV      r4,r0
;;;272    	u8 s;
;;;273    	u8 i;
;;;274    	u8 len;
;;;275    
;;;276    	len = strlen((char *)str);
0000da  f7fffffe          BL       strlen
0000de  b2c0              UXTB     r0,r0
;;;277    	for (i = 0; i < len; i++) {
0000e0  2200              MOVS     r2,#0
0000e2  e014              B        |L1.270|
                  |L1.228|
;;;278    		s = str[i];
0000e4  5ca1              LDRB     r1,[r4,r2]
;;;279    		if ( s <= ' ' ||
0000e6  2920              CMP      r1,#0x20
0000e8  d915              BLS      |L1.278|
;;;280    			 s == ':' ||
0000ea  293a              CMP      r1,#0x3a
0000ec  d013              BEQ      |L1.278|
;;;281    			 s == ';' ||
0000ee  293b              CMP      r1,#0x3b
0000f0  d011              BEQ      |L1.278|
;;;282    			 s == '.' ||
0000f2  292e              CMP      r1,#0x2e
0000f4  d00f              BEQ      |L1.278|
;;;283    			 s == '*' ||
0000f6  292a              CMP      r1,#0x2a
0000f8  d00d              BEQ      |L1.278|
;;;284    			 s == '?' ||
0000fa  293f              CMP      r1,#0x3f
0000fc  d00b              BEQ      |L1.278|
;;;285    			 s == '/' ||
0000fe  292f              CMP      r1,#0x2f
000100  d009              BEQ      |L1.278|
;;;286    			 s == '|' ||
000102  297c              CMP      r1,#0x7c
000104  d007              BEQ      |L1.278|
;;;287    			 s == '\\' ) {
000106  295c              CMP      r1,#0x5c
000108  d005              BEQ      |L1.278|
00010a  1c52              ADDS     r2,r2,#1
00010c  b2d2              UXTB     r2,r2                 ;277
                  |L1.270|
00010e  4282              CMP      r2,r0                 ;277
000110  d3e8              BCC      |L1.228|
;;;288    			return FALSE;
;;;289    		}
;;;290    	}
;;;291    
;;;292    	return TRUE;
000112  2001              MOVS     r0,#1
;;;293    }
000114  bd10              POP      {r4,pc}
                  |L1.278|
000116  2000              MOVS     r0,#0                 ;288
000118  bd10              POP      {r4,pc}
;;;294    
                          ENDP

                  FS_GetNameAndType PROC
;;;299    // В случае ошибки - возвращаются пустые строки
;;;300    bool FS_GetNameAndType(const u8 *file_name, u8 *name, u8 *type) {
00011a  b570              PUSH     {r4-r6,lr}
00011c  460e              MOV      r6,r1
;;;301    	u8 i, k;
;;;302    	u8 s;
;;;303    
;;;304    	// Выделить имя
;;;305    	for (i = 0, k = 0; k <= FILE_NAME_LENGTH; i++, k++) {
00011e  2100              MOVS     r1,#0
000120  4603              MOV      r3,r0                 ;300
000122  4615              MOV      r5,r2                 ;300
000124  4608              MOV      r0,r1
000126  460c              MOV      r4,r1
                  |L1.296|
;;;306    		s = file_name[i];
000128  5c5a              LDRB     r2,[r3,r1]
;;;307    		if (s && s != '.') {
00012a  b14a              CBZ      r2,|L1.320|
00012c  2a2e              CMP      r2,#0x2e
00012e  d007              BEQ      |L1.320|
;;;308    			name[k] = s;
000130  5432              STRB     r2,[r6,r0]
000132  1c49              ADDS     r1,r1,#1
000134  1c40              ADDS     r0,r0,#1              ;305
000136  b2c0              UXTB     r0,r0                 ;305
000138  b2c9              UXTB     r1,r1                 ;305
00013a  280e              CMP      r0,#0xe               ;305
00013c  d9f4              BLS      |L1.296|
00013e  e000              B        |L1.322|
                  |L1.320|
;;;309    		}
;;;310    		else {
;;;311    			name[k] = 0;
000140  5434              STRB     r4,[r6,r0]
                  |L1.322|
;;;312    			break;
;;;313    		}
;;;314    	}
;;;315    	if (k == 0 || k > FILE_NAME_LENGTH) {									// Имя отсутствует или слишком длинное?
000142  b1f0              CBZ      r0,|L1.386|
000144  280e              CMP      r0,#0xe
000146  d81c              BHI      |L1.386|
;;;316    		name[0] = 0;
;;;317    		type[0] = 0;
;;;318    		return FALSE;														// ДА - Завершить с ошибкой "Неверный формат имени файла"
;;;319    	}
;;;320    
;;;321    	// Выделить тип
;;;322    	if (s == '.') {
000148  2a2e              CMP      r2,#0x2e
00014a  d00a              BEQ      |L1.354|
;;;323    		for (i++, k = 0; k <= FILE_TYPE_LENGTH; i++, k++) {
;;;324    			s = file_name[i];
;;;325    			type[k] = s;
;;;326    			if (!s) {
;;;327    				break;
;;;328    			}
;;;329    		}
;;;330    		if (k == 0 || k > FILE_TYPE_LENGTH) {								// Тип отсутствует после точки или слишком длинный?
;;;331    			name[0] = 0;
;;;332    			type[0] = 0;
;;;333    			return FALSE;													// ДА - Завершить с ошибкой "Неверный формат имени файла"
;;;334    		}
;;;335    	}
;;;336    	else {
;;;337    		type[0] = 0;
00014c  702c              STRB     r4,[r5,#0]
                  |L1.334|
;;;338    	}
;;;339    
;;;340    	// Проверить имя и тип на допустимые символы
;;;341    	if ( ! FS_StrSymbolsValid(name) ) {										// Символы имени допустимы?
00014e  4630              MOV      r0,r6
000150  f7fffffe          BL       FS_StrSymbolsValid
000154  b1a8              CBZ      r0,|L1.386|
;;;342    		name[0] = 0;
;;;343    		type[0] = 0;
;;;344    		return FALSE;														// НЕТ - Завершить с ошибкой "Неверный формат имени файла"
;;;345    	}
;;;346    	if ( ! FS_StrSymbolsValid(type) ) {										// Символы типа допустимы?
000156  4628              MOV      r0,r5
000158  f7fffffe          BL       FS_StrSymbolsValid
00015c  b188              CBZ      r0,|L1.386|
;;;347    		name[0] = 0;
;;;348    		type[0] = 0;
;;;349    		return FALSE;														// НЕТ - Завершить с ошибкой "Неверный формат имени файла"
;;;350    	}
;;;351    
;;;352    	return TRUE;															// Завершить с результатом "ОК"
00015e  2001              MOVS     r0,#1
;;;353    }
000160  bd70              POP      {r4-r6,pc}
                  |L1.354|
000162  1c49              ADDS     r1,r1,#1
000164  b2c9              UXTB     r1,r1                 ;323
000166  2000              MOVS     r0,#0                 ;323
                  |L1.360|
000168  5c5a              LDRB     r2,[r3,r1]            ;324
00016a  542a              STRB     r2,[r5,r0]            ;325
00016c  b132              CBZ      r2,|L1.380|
00016e  1c49              ADDS     r1,r1,#1              ;326
000170  1c40              ADDS     r0,r0,#1              ;323
000172  b2c0              UXTB     r0,r0                 ;323
000174  b2c9              UXTB     r1,r1                 ;323
000176  2803              CMP      r0,#3                 ;323
000178  d9f6              BLS      |L1.360|
00017a  e002              B        |L1.386|
                  |L1.380|
00017c  b108              CBZ      r0,|L1.386|
00017e  2803              CMP      r0,#3                 ;330
000180  d9e5              BLS      |L1.334|
                  |L1.386|
000182  7034              STRB     r4,[r6,#0]            ;347
000184  702c              STRB     r4,[r5,#0]            ;348
000186  2000              MOVS     r0,#0                 ;349
000188  bd70              POP      {r4-r6,pc}
;;;354    
                          ENDP

                  FS_GetFullName PROC
;;;358    //-----------------------------------------------------------------------------
;;;359    void FS_GetFullName(const u8 *name, const u8 *type, u8 *full_name) {
00018a  e92d41f0          PUSH     {r4-r8,lr}
00018e  4615              MOV      r5,r2
000190  4688              MOV      r8,r1
000192  4607              MOV      r7,r0
;;;360    	u8 len;
;;;361    	u8 i, j;
;;;362    	u8 crc;
;;;363    
;;;364    	// Взять имя файла
;;;365    	i = 1;
000194  2401              MOVS     r4,#1
;;;366    	j = 0;
000196  2600              MOVS     r6,#0
;;;367    	len = strlen((char *)name);
000198  f7fffffe          BL       strlen
00019c  b2c0              UXTB     r0,r0
;;;368    	while (i <= len) {
00019e  e005              B        |L1.428|
                  |L1.416|
;;;369    		full_name[i++] = name[j++];
0001a0  5db9              LDRB     r1,[r7,r6]
0001a2  1c76              ADDS     r6,r6,#1
0001a4  5529              STRB     r1,[r5,r4]
0001a6  1c64              ADDS     r4,r4,#1
0001a8  b2f6              UXTB     r6,r6
0001aa  b2e4              UXTB     r4,r4
                  |L1.428|
0001ac  4284              CMP      r4,r0                 ;368
0001ae  d9f7              BLS      |L1.416|
;;;370    	}
;;;371    
;;;372    	// Имя файла дополнить нулями
;;;373    	len = FILE_NAME_LENGTH;
0001b0  270e              MOVS     r7,#0xe
0001b2  2600              MOVS     r6,#0
;;;374    	while (i <= len) {
0001b4  e002              B        |L1.444|
                  |L1.438|
;;;375    		full_name[i++] = 0;
0001b6  552e              STRB     r6,[r5,r4]
0001b8  1c64              ADDS     r4,r4,#1
0001ba  b2e4              UXTB     r4,r4
                  |L1.444|
0001bc  42bc              CMP      r4,r7                 ;374
0001be  d9fa              BLS      |L1.438|
;;;376    	}
;;;377    
;;;378    	// Добавить тип файла
;;;379    	len += strlen((char *)type);
0001c0  4640              MOV      r0,r8
0001c2  f7fffffe          BL       strlen
0001c6  4438              ADD      r0,r0,r7
0001c8  b2c1              UXTB     r1,r0
;;;380    	j = 0;
0001ca  2000              MOVS     r0,#0
;;;381    	while (i <= len) {
0001cc  e007              B        |L1.478|
;;;382    		full_name[i++] = type[j++];
0001ce  bf00              NOP      
                  |L1.464|
0001d0  f8182000          LDRB     r2,[r8,r0]
0001d4  1c40              ADDS     r0,r0,#1
0001d6  552a              STRB     r2,[r5,r4]
0001d8  1c64              ADDS     r4,r4,#1
0001da  b2c0              UXTB     r0,r0
0001dc  b2e4              UXTB     r4,r4
                  |L1.478|
0001de  428c              CMP      r4,r1                 ;381
0001e0  d9f6              BLS      |L1.464|
;;;383    	}
;;;384    
;;;385    	// Тип файла дополнить нулями
;;;386    	len = FILE_NAME_LENGTH + FILE_TYPE_LENGTH;
0001e2  2011              MOVS     r0,#0x11
;;;387    	while (i <= len) {
0001e4  e002              B        |L1.492|
                  |L1.486|
;;;388    		full_name[i++] = 0;
0001e6  552e              STRB     r6,[r5,r4]
0001e8  1c64              ADDS     r4,r4,#1
0001ea  b2e4              UXTB     r4,r4
                  |L1.492|
0001ec  4284              CMP      r4,r0                 ;387
0001ee  d9fa              BLS      |L1.486|
;;;389    	}
;;;390    
;;;391    	// Получить CRC для типа файла
;;;392    	crc = CRC8(full_name + len, 0xFF, FILE_TYPE_LENGTH);
0001f0  4428              ADD      r0,r0,r5
0001f2  4606              MOV      r6,r0
0001f4  2203              MOVS     r2,#3
0001f6  21ff              MOVS     r1,#0xff
0001f8  f7fffffe          BL       CRC8
0001fc  4601              MOV      r1,r0
;;;393    	full_name[i] = crc;
0001fe  5528              STRB     r0,[r5,r4]
;;;394    
;;;395    	// Получить CRC для полного имени (имя + тип)
;;;396    	crc = CRC8(full_name + len - FILE_TYPE_LENGTH, crc, FILE_NAME_LENGTH);
000200  1ef0              SUBS     r0,r6,#3
000202  220e              MOVS     r2,#0xe
000204  f7fffffe          BL       CRC8
;;;397    	if ( crc == 0x00 || crc == 0xFF ) {
000208  b108              CBZ      r0,|L1.526|
00020a  28ff              CMP      r0,#0xff
00020c  d100              BNE      |L1.528|
                  |L1.526|
;;;398    		crc = 0x01;
00020e  2001              MOVS     r0,#1
                  |L1.528|
;;;399    	}
;;;400    	full_name[0] = crc;
000210  7028              STRB     r0,[r5,#0]
                  |L1.530|
;;;401    }
000212  e8bd81f0          POP      {r4-r8,pc}
;;;402    
                          ENDP

                  FS_FileUseFCS PROC
;;;408    // иначе - возвращается -1 
;;;409    tFile FS_FileUseFCS(const u8 *name, const u8 *type) {
000216  e92d41f0          PUSH     {r4-r8,lr}
;;;410    	u8 fcs_num;																// Указатель на FCS
;;;411    	tFCS *p_fcs;
;;;412    	u8 state;
;;;413    
;;;414    	for (fcs_num = 0; fcs_num < MAX_FILES; fcs_num++) {						// Проверять все структуры FCS
;;;415    		p_fcs = pFCSArray[fcs_num];											// Получить указатель на FCS
00021a  4e73              LDR      r6,|L1.1000|
00021c  2400              MOVS     r4,#0                 ;414
00021e  460f              MOV      r7,r1                 ;409
000220  4680              MOV      r8,r0                 ;409
000222  3e20              SUBS     r6,r6,#0x20
                  |L1.548|
000224  f8565024          LDR      r5,[r6,r4,LSL #2]
;;;416    
;;;417    		state = p_fcs->State;
000228  7828              LDRB     r0,[r5,#0]
;;;418    		if (state == FCS_STATE_CLOSED) {									// Структура FCS закрыта?
00022a  b150              CBZ      r0,|L1.578|
;;;419    			continue;														// ДА - Перейти к следующеей структуре FCS
;;;420    		}
;;;421    
;;;422    		// Здесь структура FCS не закрыта
;;;423    		if ( ! strcmp( (char *)name, (char *)p_fcs->Name ) &&				// Имена совпадают?
00022c  4640              MOV      r0,r8
00022e  1c69              ADDS     r1,r5,#1
000230  f7fffffe          BL       strcmp
000234  b928              CBNZ     r0,|L1.578|
;;;424    		     ! strcmp( (char *)type, (char *)p_fcs->Type ) ) {				// И типы совпадают?
000236  f1050110          ADD      r1,r5,#0x10
00023a  4638              MOV      r0,r7
00023c  f7fffffe          BL       strcmp
000240  b130              CBZ      r0,|L1.592|
                  |L1.578|
000242  1c64              ADDS     r4,r4,#1
000244  b2e4              UXTB     r4,r4                 ;414
000246  2c08              CMP      r4,#8                 ;414
000248  d3ec              BCC      |L1.548|
;;;425    			return fcs_num;													// Вернуть номер структуры FCS
;;;426    		};
;;;427    	}
;;;428    
;;;429    	return -1;																// Вернуть результат "Файл не используется"
00024a  f04f30ff          MOV      r0,#0xffffffff
;;;430    }
00024e  e7e0              B        |L1.530|
                  |L1.592|
000250  b260              SXTB     r0,r4                 ;425
000252  e7de              B        |L1.530|
;;;431    
                          ENDP

                  FS_FindFreeFNT PROC
;;;436    // если свободных записей нет - возвращается 0xFFFFFFFF
;;;437    u32 FS_FindFreeFNT(void) {
000254  e92d41f0          PUSH     {r4-r8,lr}
;;;438    	u32 fnt_num1;															// Левый элемент при поиске = первая запись
;;;439    	u32 fnt_num2;															// Правый элемент при поиске = последняя запись
;;;440    	u32 fnt_num;															// Промежуточный элемент при поиске
;;;441    	u32 addr;
;;;442    
;;;443    	fnt_num1 = 0;															// Левый элемент при поиске = первая запись
;;;444    	fnt_num2 = FNTRecordMAX;												// Правый элемент при поиске = последняя запись
000258  4f62              LDR      r7,|L1.996|
;;;445    
;;;446    	// Предельные случаи
;;;447    	addr = FNT_BASE_ADDRESS;
00025a  2520              MOVS     r5,#0x20
00025c  2600              MOVS     r6,#0                 ;443
;;;448    	if (FLASH_ReadByte(addr) == 0xFF) {										// Первая запись свободна?
00025e  4628              MOV      r0,r5
000260  6a3c              LDR      r4,[r7,#0x20]  ; FNTRecordMAX
000262  f7fffffe          BL       FLASH_ReadByte
000266  28ff              CMP      r0,#0xff
000268  d008              BEQ      |L1.636|
;;;449    		return 0;															// ДА - Свободная запись FNT = 0
;;;450    	}
;;;451    	addr += FNTRecordMAX * FNT_RECORD_SIZE;
00026a  6a38              LDR      r0,[r7,#0x20]  ; FNTRecordMAX
00026c  eb051040          ADD      r0,r5,r0,LSL #5
;;;452    	if (FLASH_ReadByte(addr) != 0xFF) {										// Последняя запись занята?
000270  f7fffffe          BL       FLASH_ReadByte
000274  28ff              CMP      r0,#0xff
000276  d00f              BEQ      |L1.664|
;;;453    		return 0xFFFFFFFF;													// ДА - Свободных записей FNT нет
000278  1e70              SUBS     r0,r6,#1
;;;454    	}
;;;455    
;;;456    	// Дихотомический поиск по таблице FNT
;;;457    	while ( (fnt_num2 - fnt_num1) > 1 ) {									// Повторять чтобы левый и правый элемент оказались рядом
;;;458    		fnt_num = (fnt_num1 + fnt_num2) >> 1;
;;;459    		addr = FNT_BASE_ADDRESS + fnt_num * FNT_RECORD_SIZE;
;;;460    		if (FLASH_ReadByte(addr) == 0xFF) {
;;;461    			fnt_num2 = fnt_num;
;;;462    		}
;;;463    		else {
;;;464    			fnt_num1 = fnt_num;
;;;465    		}
;;;466    	}
;;;467    	return fnt_num2;														// Свободная запись FNT = правый элемент
;;;468    }
00027a  e7ca              B        |L1.530|
                  |L1.636|
00027c  2000              MOVS     r0,#0                 ;449
00027e  e7c8              B        |L1.530|
                  |L1.640|
000280  1930              ADDS     r0,r6,r4              ;458
000282  0845              LSRS     r5,r0,#1              ;458
000284  eb071045          ADD      r0,r7,r5,LSL #5       ;459
000288  f7fffffe          BL       FLASH_ReadByte
00028c  28ff              CMP      r0,#0xff              ;460
00028e  d001              BEQ      |L1.660|
000290  462e              MOV      r6,r5                 ;464
000292  e002              B        |L1.666|
                  |L1.660|
000294  462c              MOV      r4,r5                 ;461
000296  e000              B        |L1.666|
                  |L1.664|
000298  2720              MOVS     r7,#0x20              ;447
                  |L1.666|
00029a  1ba0              SUBS     r0,r4,r6              ;457
00029c  2801              CMP      r0,#1                 ;457
00029e  d8ef              BHI      |L1.640|
0002a0  4620              MOV      r0,r4                 ;467
0002a2  e7b6              B        |L1.530|
;;;469    
                          ENDP

                  FS_FindFileByName PROC
;;;476    // если файл не найден - возвращается 0xFFFFFFFF
;;;477    u32 FS_FindFileByName(const u8 *full_name) {
0002a4  e92d47f0          PUSH     {r4-r10,lr}
;;;478    	u32 fnt_num;
;;;479    	u32 fnt_addr;
;;;480    	u32 addr;
;;;481    	u8 len;
;;;482    	u8 i;
;;;483    	u8 b;
;;;484    
;;;485    	len = 1 + FILE_NAME_LENGTH + FILE_TYPE_LENGTH;							// Длина поиска
0002a8  2712              MOVS     r7,#0x12
0002aa  4681              MOV      r9,r0                 ;477
;;;486    	fnt_addr = FNT_BASE_ADDRESS;											// Адрес первой записи FNT
0002ac  f04f0820          MOV      r8,#0x20
;;;487    	for (fnt_num = 0; fnt_num < FNTRecordsNumber; fnt_num++) {				// Проверять все записи в таблице FNT
0002b0  2600              MOVS     r6,#0
0002b2  f8dfa130          LDR      r10,|L1.996|
0002b6  e015              B        |L1.740|
                  |L1.696|
;;;488    		addr = fnt_addr;													// Адрес символа строки
0002b8  4644              MOV      r4,r8
;;;489    		for (i=0; i<len; i++) {												// Сравнивать все байты в заданной строке
0002ba  2500              MOVS     r5,#0
                  |L1.700|
;;;490    			b = FLASH_ReadByte(addr++);										// Прочитать байт из строки
0002bc  4620              MOV      r0,r4
0002be  1c64              ADDS     r4,r4,#1
0002c0  f7fffffe          BL       FLASH_ReadByte
;;;491    			if (b != full_name[i]) {										// Символы равны?
0002c4  f8191005          LDRB     r1,[r9,r5]
0002c8  4281              CMP      r1,r0
0002ca  d103              BNE      |L1.724|
0002cc  1c6d              ADDS     r5,r5,#1
0002ce  b2ed              UXTB     r5,r5                 ;489
0002d0  42bd              CMP      r5,r7                 ;489
0002d2  d3f3              BCC      |L1.700|
                  |L1.724|
;;;492    				break;														// НЕТ - прервать сравнение строк
;;;493    			}
;;;494    		}
;;;495    		if (i == len) {														// Имя файла найдено?
0002d4  42bd              CMP      r5,r7
0002d6  d102              BNE      |L1.734|
;;;496    			return fnt_num;													// ДА - Вернуть номер записи FNT
0002d8  4630              MOV      r0,r6
                  |L1.730|
;;;497    		}
;;;498    		fnt_addr += FNT_RECORD_SIZE;										// Адрес следующей записи FNT
;;;499    	}
;;;500    	return 0xFFFFFFFF;														// Результат = "Файл не найден"
;;;501    }
0002da  e8bd87f0          POP      {r4-r10,pc}
                  |L1.734|
0002de  f1080820          ADD      r8,r8,#0x20           ;498
0002e2  1c76              ADDS     r6,r6,#1              ;498
                  |L1.740|
0002e4  f8da001c          LDR      r0,[r10,#0x1c]        ;487  ; FNTRecordsNumber
0002e8  4286              CMP      r6,r0                 ;487
0002ea  d3e5              BCC      |L1.696|
0002ec  f04f30ff          MOV      r0,#0xffffffff        ;500
0002f0  e7f3              B        |L1.730|
;;;502    
                          ENDP

                  FS_FindFreeCluster PROC
;;;507    // если свободных кластеров нет - возвращается 0xFFFF
;;;508    u16 FS_FindFreeCluster(void) {
0002f2  b570              PUSH     {r4-r6,lr}
;;;509    	u16 cat_num;
;;;510    	u32 cat_addr;
;;;511    
;;;512    	cat_addr = CAT_BASE_ADDRESS;											// Адрес первой записи CAT
0002f4  4e3b              LDR      r6,|L1.996|
;;;513    	for (cat_num = 0; cat_num < CATRecordsNumber; cat_num++) {				// Проверять все записи в таблице CAT
0002f6  2400              MOVS     r4,#0
0002f8  6a75              LDR      r5,[r6,#0x24]         ;508  ; CAT_BASE_ADDRESS
0002fa  e007              B        |L1.780|
                  |L1.764|
;;;514    		if (FLASH_ReadByte(cat_addr) == 0xFF) {								// Запись свободна?
0002fc  4628              MOV      r0,r5
0002fe  f7fffffe          BL       FLASH_ReadByte
000302  28ff              CMP      r0,#0xff
000304  d008              BEQ      |L1.792|
000306  1c64              ADDS     r4,r4,#1
000308  b2a4              UXTH     r4,r4                 ;513
00030a  1ced              ADDS     r5,r5,#3              ;513
                  |L1.780|
00030c  89f0              LDRH     r0,[r6,#0xe]          ;513  ; CATRecordsNumber
00030e  4284              CMP      r4,r0                 ;513
000310  d3f4              BCC      |L1.764|
;;;515    			return cat_num;													// ДА - Вернуть номер записи CAT
;;;516    		}
;;;517    		cat_addr += CAT_RECORD_SIZE;										// Адрес следующей записи CAT
;;;518    	}
;;;519    	return 0xFFFF;															// Результат = "Свободная запись CAT не найдена"
000312  f64f70ff          MOV      r0,#0xffff
;;;520    }
000316  bd70              POP      {r4-r6,pc}
                  |L1.792|
000318  4620              MOV      r0,r4                 ;515
00031a  bd70              POP      {r4-r6,pc}
;;;521    
                          ENDP

                  FS_GetFreeClustersNum PROC
;;;526    // Искать по всем записям от начала до конца таблицы CAT
;;;527    u16 FS_GetFreeClustersNum(void) {
00031c  e92d41f0          PUSH     {r4-r8,lr}
;;;528    	u16 cat_num;
;;;529    	u32 cat_addr;
;;;530    	u16 n = 0;
;;;531    
;;;532    	cat_addr = CAT_BASE_ADDRESS;											// Адрес первой записи CAT
000320  4f30              LDR      r7,|L1.996|
000322  2500              MOVS     r5,#0                 ;530
;;;533    	for (cat_num = 0; cat_num < CATRecordsNumber; cat_num++) {				// Проверять все записи в таблице CAT
000324  462c              MOV      r4,r5
000326  6a7e              LDR      r6,[r7,#0x24]         ;527  ; CAT_BASE_ADDRESS
000328  e009              B        |L1.830|
                  |L1.810|
;;;534    		if (FLASH_ReadByte(cat_addr) == 0xFF) {								// Запись свободна?
00032a  4630              MOV      r0,r6
00032c  f7fffffe          BL       FLASH_ReadByte
000330  28ff              CMP      r0,#0xff
000332  d101              BNE      |L1.824|
000334  1c6d              ADDS     r5,r5,#1
;;;535    			n++;															// ДА - Считать кол-во свободных кластеров
000336  b2ad              UXTH     r5,r5
                  |L1.824|
000338  1c64              ADDS     r4,r4,#1
00033a  b2a4              UXTH     r4,r4                 ;533
00033c  1cf6              ADDS     r6,r6,#3              ;533
                  |L1.830|
00033e  89f8              LDRH     r0,[r7,#0xe]          ;533  ; CATRecordsNumber
000340  4284              CMP      r4,r0                 ;533
000342  d3f2              BCC      |L1.810|
;;;536    		}
;;;537    		cat_addr += CAT_RECORD_SIZE;										// Адрес следующей записи CAT
;;;538    	}
;;;539    	return n;																// Результат = Кол-во свободных кластеров
000344  4628              MOV      r0,r5
;;;540    }
000346  e764              B        |L1.530|
;;;541    
                          ENDP

                  FS_FNTWriteFullName PROC
;;;545    //-----------------------------------------------------------------------------
;;;546    void FS_FNTWriteFullName(u32 fnt_num, const u8 *full_name) {
000348  2213              MOVS     r2,#0x13
;;;547    	u8 len;
;;;548    
;;;549    	len = 1 + FILE_NAME_LENGTH + FILE_TYPE_LENGTH + 1;
;;;550    	FLASH_Write( FNT_BASE_ADDRESS + fnt_num * FNT_RECORD_SIZE, full_name, len );
00034a  2320              MOVS     r3,#0x20
00034c  eb031040          ADD      r0,r3,r0,LSL #5
000350  f7ffbffe          B.W      FLASH_Write
;;;551    }
;;;552    
                          ENDP

                  FS_FNTSetSignature1 PROC
;;;556    //-----------------------------------------------------------------------------
;;;557    void FS_FNTSetSignature1(u32 fnt_num, u8 signature) {
000354  2220              MOVS     r2,#0x20
;;;558    	FLASH_WriteByte( FNT_BASE_ADDRESS + fnt_num * FNT_RECORD_SIZE, signature );
000356  eb021040          ADD      r0,r2,r0,LSL #5
00035a  f7ffbffe          B.W      FLASH_WriteByte
;;;559    }
;;;560    
                          ENDP

                  FS_ClusterSetFlag PROC
;;;564    //-----------------------------------------------------------------------------
;;;565    void FS_ClusterSetFlag(u16 clust_num, u8 flag) {
00035e  4a21              LDR      r2,|L1.996|
;;;566    	FLASH_WriteByte( CAT_BASE_ADDRESS + clust_num * CAT_RECORD_SIZE, flag );
000360  eb000040          ADD      r0,r0,r0,LSL #1
000364  6a52              LDR      r2,[r2,#0x24]  ; CAT_BASE_ADDRESS
000366  4410              ADD      r0,r0,r2
000368  f7ffbffe          B.W      FLASH_WriteByte
;;;567    }
;;;568    
                          ENDP

                  FS_SetNextCluster PROC
;;;572    //-----------------------------------------------------------------------------
;;;573    void FS_SetNextCluster(u16 clust_num_curr, u16 clust_num_next) {
00036c  b513              PUSH     {r0,r1,r4,lr}
;;;574    	FLASH_Write( CAT_BASE_ADDRESS + clust_num_curr * CAT_RECORD_SIZE + 1, (u8 *)&clust_num_next, 2 );
00036e  491d              LDR      r1,|L1.996|
000370  eb000040          ADD      r0,r0,r0,LSL #1
000374  2202              MOVS     r2,#2
000376  6a49              LDR      r1,[r1,#0x24]  ; CAT_BASE_ADDRESS
000378  4408              ADD      r0,r0,r1
00037a  a901              ADD      r1,sp,#4
00037c  1c40              ADDS     r0,r0,#1
00037e  f7fffffe          BL       FLASH_Write
;;;575    }
000382  bd1c              POP      {r2-r4,pc}
;;;576    
                          ENDP

                  FS_GetNextCluster PROC
;;;580    //-----------------------------------------------------------------------------
;;;581    u16 FS_GetNextCluster(u16 clust_num_curr) {
000384  4917              LDR      r1,|L1.996|
000386  b508              PUSH     {r3,lr}
;;;582    	u16 clust_num_next;
;;;583    
;;;584    	FLASH_Read( (u8 *)&clust_num_next, CAT_BASE_ADDRESS + clust_num_curr * CAT_RECORD_SIZE + 1, 2 );
000388  6a49              LDR      r1,[r1,#0x24]  ; CAT_BASE_ADDRESS
00038a  eb000040          ADD      r0,r0,r0,LSL #1
00038e  4401              ADD      r1,r1,r0
000390  2202              MOVS     r2,#2
000392  4668              MOV      r0,sp
000394  1c49              ADDS     r1,r1,#1
000396  f7fffffe          BL       FLASH_Read
;;;585    	return clust_num_next;
00039a  f8bd0000          LDRH     r0,[sp,#0]
;;;586    }
00039e  bd08              POP      {r3,pc}
;;;587    
                          ENDP

                  FS_FlushPageBuffer PROC
;;;591    //-----------------------------------------------------------------------------
;;;592    void FS_FlushPageBuffer(const tFCS *p_fcs, u16 size) {
0003a0  b430              PUSH     {r4,r5}
;;;593    	u32 addr;
;;;594    
;;;595    	addr = CLUSTERS_BASE_ADDRESS +											// Адрес страницы в флэш-памяти
0003a2  4a10              LDR      r2,|L1.996|
0003a4  7e83              LDRB     r3,[r0,#0x1a]
0003a6  6a94              LDR      r4,[r2,#0x28]  ; CLUSTERS_BASE_ADDRESS
0003a8  8992              LDRH     r2,[r2,#0xc]  ; CLUSTER_SIZE
0003aa  eb042303          ADD      r3,r4,r3,LSL #8
0003ae  8b04              LDRH     r4,[r0,#0x18]
0003b0  fb043302          MLA      r3,r4,r2,r3
;;;596    	       p_fcs->CurrCluster * CLUSTER_SIZE +
;;;597    		   p_fcs->CurrPage * PAGE_SIZE;
;;;598     	FLASH_Write(addr, p_fcs->PageBuffer, size);								// Записать страницу флэш-памяти
0003b4  460a              MOV      r2,r1
0003b6  f100011d          ADD      r1,r0,#0x1d
0003ba  bc30              POP      {r4,r5}
0003bc  4618              MOV      r0,r3
0003be  f7ffbffe          B.W      FLASH_Write
;;;599    }
;;;600    
                          ENDP

                  FS_GetFreeFCS PROC
;;;604    //-----------------------------------------------------------------------------
;;;605    s8 FS_GetFreeFCS() {
0003c2  4909              LDR      r1,|L1.1000|
;;;606    	u8 i;
;;;607    
;;;608    	for (i=0; i<MAX_FILES; i++) {											// Проверить все структуры FCS
0003c4  2000              MOVS     r0,#0
;;;609    		if (pFCSArray[i]->State == FCS_STATE_CLOSED) {						// Найдена свободная (закрытая) структура FCS?
0003c6  3920              SUBS     r1,r1,#0x20
                  |L1.968|
0003c8  f8512020          LDR      r2,[r1,r0,LSL #2]
0003cc  7812              LDRB     r2,[r2,#0]
0003ce  b132              CBZ      r2,|L1.990|
0003d0  1c40              ADDS     r0,r0,#1
0003d2  b2c0              UXTB     r0,r0                 ;608
0003d4  2808              CMP      r0,#8                 ;608
0003d6  d3f7              BCC      |L1.968|
;;;610    			return i;														// ДА - Вернуть номер найденной структуры FCS
;;;611    		}
;;;612    	}
;;;613    	return -1;																// НЕТ - Вернуть ошибку "Нет свободной структуры FCS" (ошибка -1)
0003d8  f04f30ff          MOV      r0,#0xffffffff
;;;614    }
0003dc  4770              BX       lr
                  |L1.990|
0003de  b240              SXTB     r0,r0                 ;610
                  |L1.992|
0003e0  4770              BX       lr
0003e2  0000              DCW      0x0000
                  |L1.996|
                          DCD      ||.data||
                  |L1.1000|
                          DCD      ||.bss||+0x20
                          ENDP

                  FS_Assign PROC
;;;626    //-----------------------------------------------------------------------------
;;;627    s8 FS_Assign(const u8 *file_name,tFile * f) {
0003ec  b570              PUSH     {r4-r6,lr}
0003ee  460e              MOV      r6,r1
;;;628    	s8 fcs_num;
;;;629    	u8 name[FILE_NAME_LENGTH + 1];
;;;630    	u8 type[FILE_TYPE_LENGTH + 1];
;;;631    
;;;632    	// Проверить инициализацию файловой системы (ошибка -1)
;;;633    	if (! FS_IS_INITED) {													// Файловая система инициализирована?
0003f0  49fe              LDR      r1,|L1.2028|
0003f2  b086              SUB      sp,sp,#0x18           ;627
0003f4  7849              LDRB     r1,[r1,#1]  ; FS_IS_INITED
0003f6  b171              CBZ      r1,|L1.1046|
;;;634    		return EFS_FS_NOT_INITED;															// НЕТ - Вернуть ошибку "Файловая система не инициализирована" (ошибка -1)
;;;635    	}
;;;636    
;;;637    	if (! FS_GetNameAndType(file_name, name, type)) {						// Выделение имени и типа выполнилось успешно?
0003f8  aa04              ADD      r2,sp,#0x10
0003fa  4669              MOV      r1,sp
0003fc  f7fffffe          BL       FS_GetNameAndType
000400  b160              CBZ      r0,|L1.1052|
;;;638    		return EFS_INVALID_FILE_NAME;															// НЕТ - Вернуть ошибку "Неверный формат имени файла" (ошибка -3)
;;;639    	}
;;;640    
;;;641    	// Проверить использование файла с заданным именем
;;;642    	if (FS_FileUseFCS(name, type) > -1) {									// Файл с заданным именем используется?
000402  a904              ADD      r1,sp,#0x10
000404  4668              MOV      r0,sp
000406  f7fffffe          BL       FS_FileUseFCS
00040a  2800              CMP      r0,#0
00040c  db09              BLT      |L1.1058|
;;;643    		return EFS_FILE_IS_USED;															// ДА - Вернуть ошибку "Файл с заданным именем используется" (ошибка -4)
00040e  f06f0003          MVN      r0,#3
                  |L1.1042|
;;;644    	};
;;;645    
;;;646    	// Получить номер свободной структуры FCS
;;;647    	fcs_num = FS_GetFreeFCS();
;;;648    	if (fcs_num < 0) {														// Свободная структура FCS найдена?
;;;649    		return EFS_NO_FREE_FCS;											// НЕТ - Вернуть ошибку "Нет свободной структуры FCS" (ошибка -2)
;;;650    	}
;;;651    
;;;652    	// Заполнить занятую структуру FCS
;;;653    	pFCSArray[fcs_num]->State = FCS_STATE_OPENED;							// Структура FCS = Открыта
;;;654    	strcpy((char *)pFCSArray[fcs_num]->Name, (char *)name);					// Записать имя файла
;;;655    	strcpy((char *)pFCSArray[fcs_num]->Type, (char *)type);					// Записать тип файла
;;;656    	*f = fcs_num;
;;;657    	return FS_RESULT_OK;															// Вернуть номер открытой структуры FCS
;;;658    }
000412  b006              ADD      sp,sp,#0x18
000414  bd70              POP      {r4-r6,pc}
                  |L1.1046|
000416  f06f0001          MVN      r0,#1                 ;634
00041a  e7fa              B        |L1.1042|
                  |L1.1052|
00041c  f06f0002          MVN      r0,#2                 ;638
000420  e7f7              B        |L1.1042|
                  |L1.1058|
000422  f7fffffe          BL       FS_GetFreeFCS
000426  0004              MOVS     r4,r0                 ;647
000428  d502              BPL      |L1.1072|
00042a  f06f0004          MVN      r0,#4                 ;649
00042e  e7f0              B        |L1.1042|
                  |L1.1072|
000430  4def              LDR      r5,|L1.2032|
000432  2001              MOVS     r0,#1                 ;653
000434  f8551024          LDR      r1,[r5,r4,LSL #2]     ;653
000438  7008              STRB     r0,[r1,#0]            ;653
00043a  f8550024          LDR      r0,[r5,r4,LSL #2]     ;654
00043e  4669              MOV      r1,sp                 ;654
000440  1c40              ADDS     r0,r0,#1              ;654
000442  f7fffffe          BL       strcpy
000446  f8550024          LDR      r0,[r5,r4,LSL #2]     ;655
00044a  a904              ADD      r1,sp,#0x10           ;655
00044c  3010              ADDS     r0,r0,#0x10           ;655
00044e  f7fffffe          BL       strcpy
000452  7034              STRB     r4,[r6,#0]            ;656
000454  2000              MOVS     r0,#0                 ;657
000456  e7dc              B        |L1.1042|
;;;659    
                          ENDP

                  FS_Rewrite PROC
;;;663    //-----------------------------------------------------------------------------
;;;664    s8 FS_Rewrite(tFile fcs_num) {
000458  e92d41f0          PUSH     {r4-r8,lr}
;;;665    	tFCS *p_fcs;															// Указатель на FCS
;;;666    	u32 fnt_num;															// Номер записи в таблице FNT
;;;667    	u16 clust_num;
;;;668    	u8 *full_name;															// Указатель на полное имя файла
;;;669    	u16 k;
;;;670    
;;;671    	// Проверить файловую переменную (ошибка -9)
;;;672    	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
00045c  2808              CMP      r0,#8
00045e  d302              BCC      |L1.1126|
;;;673    		return EFS_INVALID_FSC;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
000460  f06f0005          MVN      r0,#5
;;;674    	}
;;;675    
;;;676    	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;677    
;;;678    	// Проверить состояние структуры FCS (ошибка -1)
;;;679    	if (p_fcs->State != FCS_STATE_OPENED) {									// Структура FCS открыта?
;;;680    		return EFS_FCS_NOT_OPENED;															// НЕТ - Вернуть ошибку "Структура FCS не открыта" (ошибка -1)
;;;681    	}
;;;682    
;;;683    	// Получить полное имя файла ( в форме: Signature1 + имя + тип + Signature2 )
;;;684    	full_name = p_fcs->FNT.FullName;										// Указатель на полное имя файла
;;;685    	FS_GetFullName(p_fcs->Name, p_fcs->Type, full_name);
;;;686    
;;;687    	// Проверить уникальность имени (ошибка -2)
;;;688    	fnt_num = FS_FindFileByName(full_name);									// Найти файл с заданным именем (включая сигнатуру)
;;;689    	if (fnt_num != 0xFFFFFFFF) {											// Найден файл с заданным именем?
;;;690    		return EFS_FILE_NAME_IS_EXIST;															// ДА - Вернуть ошибку "Файл с заданным именем уже существует" (ошибка -2)
;;;691    	}
;;;692    
;;;693    	// Найти свободную запись в таблице FNT (ошибка -3)
;;;694    	fnt_num = FS_FindFreeFNT();
;;;695    	if (fnt_num == 0xFFFFFFFF) {											// Свободная запись FNT найдена?
;;;696    		return EFS_NO_FREE_FNT;															// НЕТ - Вернуть ошибку "Нет свободной записи FNT" (ошибка -3)
;;;697    	}
;;;698    
;;;699    	// Проверить наличие свободного места (ошибка -4)
;;;700    	clust_num = FS_FindFreeCluster();										// Найти свободный кластер в таблице CAT
;;;701    	if (clust_num == 0xFFFF) {												// Свободный кластер найден?
;;;702    		return EFS_NO_FREE_SPACE;															// НЕТ - Вернуть ошибку "Недостаточно места" (ошибка -4)
;;;703    	}
;;;704    
;;;705    	// ОШИБОК НЕТ - ОТКРЫТЬ ФАЙЛ
;;;706    
;;;707    	// Пометить занятые записи в таблицах FNT и CAT
;;;708    	FS_FNTWriteFullName(fnt_num, full_name);								// Пометить запись FNT = "Занято" (записать полное имя файла)
;;;709    	FS_ClusterSetFlag(clust_num, 0xFE);										// Пометить кластер в таблице CAT = "Занято"
;;;710    
;;;711    	// Заполнить начальными значениями структуру FCS.FNT
;;;712    	//p_fcs->FNT.FullName[];												...(полное имя = уже заполнено)
;;;713    	p_fcs->FNT.Attribute = FILE_ATTR_NOATTR;								// Файл без атрибутов
;;;714    	p_fcs->FNT.FirstCluster = clust_num;									// Первый кластер = текущий кластер
;;;715    	p_fcs->FNT.Size = 0;													// Начальный размер = 0
;;;716    
;;;717    	// Заполнить FCS
;;;718    	p_fcs->State = FCS_STATE_OPENED_WRITE;									// Пометить - "Структура FCS открыта для записи файла"
;;;719    	p_fcs->FNT_num = fnt_num;												// Номер записи таблицы FNT
;;;720    	p_fcs->CurrCluster = clust_num;											// Номер текущего кластера
;;;721    	p_fcs->CurrPage = 0;													// Номер текущей страницы в текущем кластере
;;;722    	p_fcs->PageBufPtr = 0;													// Текущий указатель в буфере страницы
;;;723    	//p_fcs->PageBuffer[];													...(буфер текущей страницы флэш-памяти = не определено)
;;;724    
;;;725    //------
;;;726    //<!> ДЛЯ ОТЛАДКИ !!!
;;;727    //ОЧИСТИТЬ БУФЕР СТРАНИЦЫ
;;;728    for (k = 0; k < PAGE_SIZE; k++) {
;;;729    	p_fcs->PageBuffer[k] = 0xFF;
;;;730    }
;;;731    //------
;;;732    
;;;733    	return FS_RESULT_OK;																// Файл для записи успешно открыт
;;;734    }
000464  e6d5              B        |L1.530|
                  |L1.1126|
000466  49e2              LDR      r1,|L1.2032|
000468  f8514020          LDR      r4,[r1,r0,LSL #2]     ;676
00046c  7820              LDRB     r0,[r4,#0]            ;679
00046e  2801              CMP      r0,#1                 ;679
000470  d002              BEQ      |L1.1144|
000472  f06f0006          MVN      r0,#6                 ;680
000476  e6cc              B        |L1.530|
                  |L1.1144|
000478  f2041529          ADD      r5,r4,#0x129          ;684
00047c  462a              MOV      r2,r5                 ;685
00047e  f1040110          ADD      r1,r4,#0x10           ;685
000482  1c60              ADDS     r0,r4,#1              ;685
000484  f7fffffe          BL       FS_GetFullName
000488  4628              MOV      r0,r5                 ;688
00048a  f7fffffe          BL       FS_FindFileByName
00048e  1c40              ADDS     r0,r0,#1              ;688
000490  d002              BEQ      |L1.1176|
000492  f06f0007          MVN      r0,#7                 ;690
000496  e6bc              B        |L1.530|
                  |L1.1176|
000498  f7fffffe          BL       FS_FindFreeFNT
00049c  4607              MOV      r7,r0                 ;694
00049e  1c40              ADDS     r0,r0,#1              ;695
0004a0  d028              BEQ      |L1.1268|
0004a2  f7fffffe          BL       FS_FindFreeCluster
0004a6  f5a0417f          SUB      r1,r0,#0xff00         ;701
0004aa  4606              MOV      r6,r0                 ;700
0004ac  39ff              SUBS     r1,r1,#0xff           ;701
0004ae  d01e              BEQ      |L1.1262|
0004b0  4629              MOV      r1,r5                 ;708
0004b2  4638              MOV      r0,r7                 ;708
0004b4  f7fffffe          BL       FS_FNTWriteFullName
0004b8  21fe              MOVS     r1,#0xfe              ;709
0004ba  4630              MOV      r0,r6                 ;709
0004bc  f7fffffe          BL       FS_ClusterSetFlag
0004c0  21ff              MOVS     r1,#0xff              ;713
0004c2  f884113c          STRB     r1,[r4,#0x13c]        ;713
0004c6  2000              MOVS     r0,#0                 ;715
0004c8  f8a4613d          STRH     r6,[r4,#0x13d]        ;714
0004cc  f8c4013f          STR      r0,[r4,#0x13f]        ;715
0004d0  2203              MOVS     r2,#3                 ;718
0004d2  7022              STRB     r2,[r4,#0]            ;718
0004d4  6167              STR      r7,[r4,#0x14]         ;719
0004d6  8326              STRH     r6,[r4,#0x18]         ;720
0004d8  76a0              STRB     r0,[r4,#0x1a]         ;721
0004da  f8a4001b          STRH     r0,[r4,#0x1b]         ;722
                  |L1.1246|
0004de  1822              ADDS     r2,r4,r0              ;729
0004e0  1c40              ADDS     r0,r0,#1              ;729
0004e2  b280              UXTH     r0,r0                 ;728
0004e4  7751              STRB     r1,[r2,#0x1d]         ;729
0004e6  28ff              CMP      r0,#0xff              ;728
0004e8  d9f9              BLS      |L1.1246|
0004ea  2000              MOVS     r0,#0                 ;733
0004ec  e691              B        |L1.530|
                  |L1.1262|
0004ee  f06f0009          MVN      r0,#9                 ;702
0004f2  e68e              B        |L1.530|
                  |L1.1268|
0004f4  f06f0008          MVN      r0,#8                 ;696
0004f8  e68b              B        |L1.530|
;;;735    
                          ENDP

                  FS_Append PROC
;;;739    //-----------------------------------------------------------------------------
;;;740    s8 FS_Append(tFile fcs_num) {
0004fa  e92d5ff0          PUSH     {r4-r12,lr}
;;;741    	tFCS *p_fcs;															// Указатель на FCS
;;;742    	u8 *full_name;															// Указатель на полное имя файла
;;;743    	u32 fnt_num_old, fnt_num_new;											// Старый и новый номера записей в таблице FNT
;;;744    	u32 addr;																// Адрес флэш-памяти
;;;745    	u8 len;
;;;746    	u32 file_size;															// Размер файла
;;;747    	u16 clust_num;															// Индекс (в таблице CAT) последнего кластера
;;;748    	u8 page_num;															// Номер последней страницы внутри последнего кластера
;;;749    	u32 n_bytes;															// Кол-во байт в последней странице
;;;750    	u16 i;
;;;751    	u16 k;
;;;752    
;;;753    	// Проверить файловую переменную (ошибка -9)
;;;754    	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
0004fe  2808              CMP      r0,#8
000500  d303              BCC      |L1.1290|
;;;755    		return EFS_INVALID_FSC;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
000502  f06f0005          MVN      r0,#5
                  |L1.1286|
;;;756    	}
;;;757    
;;;758    	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;759    
;;;760    	// ПЕРЕД ОТКРЫТИЕМ ФАЙЛА - ПРОВЕРИТЬ ВОЗМОЖНЫЕ ОШИБКИ
;;;761    
;;;762    	// Проверить состояние структуры FCS (ошибка -1)
;;;763    	if (p_fcs->State != FCS_STATE_OPENED) {									// Структура FCS открыта?
;;;764    		return EFS_FCS_NOT_OPENED;															// НЕТ - Вернуть ошибку "Структура FCS не открыта" (ошибка -1)
;;;765    	}
;;;766    
;;;767    	// Получить полное имя файла ( в форме: Signature1 + имя + тип + Signature2 )
;;;768    	full_name = p_fcs->FNT.FullName;										// Указатель на полное имя файла
;;;769    	FS_GetFullName(p_fcs->Name, p_fcs->Type, full_name);
;;;770    
;;;771    	// Поиск запрошенного файла в таблице FNT (ошибка -2)
;;;772    	fnt_num_old = FS_FindFileByName(full_name);								// Найти файл с заданным именем (включая сигнатуру)
;;;773    	if (fnt_num_old == 0xFFFFFFFF) {										// Найден файл с заданным именем?
;;;774    		return EFS_FILE_NOT_FOUND;															// НЕТ - Вернуть ошибку "Файл с заданным именем не найден" (ошибка -2)
;;;775    	}
;;;776    
;;;777    	// Найти свободную запись в таблице FNT (ошибка -3)
;;;778    	fnt_num_new = FS_FindFreeFNT();
;;;779    	if (fnt_num_new == 0xFFFFFFFF) {										// Свободная запись FNT найдена?
;;;780    		return EFS_NO_FREE_FNT;															// НЕТ - Вернуть ошибку "Нет свободной записи FNT" (ошибка -3)
;;;781    	}
;;;782    
;;;783    	// ОШИБОК НЕТ - ПОПЫТКА ОТКРЫТЬ ФАЙЛ
;;;784    
;;;785    	// Заполнить начальными значениями структуру FCS.FNT
;;;786    
;;;787    	//p_fcs->FNT.FullName[];												(полное имя = уже заполнено)
;;;788    
;;;789    	// Копировать в FCS.FNT запись из таблицы FNT файла
;;;790    	addr = FNT_BASE_ADDRESS + fnt_num_old * FNT_RECORD_SIZE;				// Адрес начала FNT открываемого файла
;;;791    	len = 1 + FILE_NAME_LENGTH + FILE_TYPE_LENGTH + 1;						// Длина полного имени
;;;792    	addr += len;															// Пропустить полное имя (полное имя не копировать, оно уже заполнено)
;;;793    	FLASH_Read(full_name + len, addr, FNT_RECORD_SIZE - len);				// Прочитать запись FNT кроме полного имени
;;;794    
;;;795    	// Проверить разрешена или нет запись в файл  (ошибка -4)
;;;796    	if (p_fcs->FNT.Attribute == FILE_ATTR_READONLY) {						// В файл разрешена запись?
;;;797    		return EFS_WRITE_DISABLED;															// НЕТ - Вернуть ошибку "Запись в файл запрещена"  (ошибка -4)
;;;798    	}
;;;799    
;;;800    	file_size = p_fcs->FNT.Size;											// Размер файла
;;;801    	page_num = ( (file_size / PAGE_SIZE) % PAGES_PER_CLUSTER );				// Номер последней страницы внутри кластера
;;;802    	n_bytes = file_size % PAGE_SIZE;										// Количество байт в последней странице
;;;803    
;;;804    	// Вычислить индекс (в таблице CAT) последнего кластера
;;;805    	i = (file_size / CLUSTER_SIZE);											// Кол-во целых кластеров
;;;806    	clust_num = p_fcs->FNT.FirstCluster;									// Начинаем с первого кластера цепочки
;;;807    	while (i--) {															// Идти по цепочке кластеров
;;;808    		clust_num = FS_GetNextCluster(clust_num);
;;;809    	}
;;;810    
;;;811    	// Пометить записи в таблице FNT
;;;812    	FS_FNTSetSignature1(fnt_num_old, 0x00);									// Пометить старую запись FNT = "Удалено"
;;;813    	FS_FNTWriteFullName(fnt_num_new, full_name);							// Пометить новую запись FNT = "Занято" (записать полное имя файла)
;;;814    
;;;815    	// Заполнить FCS
;;;816    	p_fcs->State = FCS_STATE_OPENED_WRITE;									// Пометить - "Структура FCS открыта для записи файла"
;;;817    	p_fcs->FNT_num = fnt_num_new;											// Номер записи таблицы FNT
;;;818    	p_fcs->CurrCluster = clust_num;											// Индекс (в таблице CAT) текущего кластера
;;;819    	p_fcs->CurrPage = page_num;												// Номер текущей страницы в текущем кластере
;;;820    	p_fcs->PageBufPtr = n_bytes;											// Текущий указатель в буфере страницы
;;;821    
;;;822    	// Прочитать последнюю страницу в буфер страницы
;;;823    	if (n_bytes) {															// Первая страница содержит данные?
;;;824    		addr = CLUSTERS_BASE_ADDRESS +										// Адрес страницы в флэш-памяти
;;;825    		       clust_num * CLUSTER_SIZE +
;;;826    		       page_num * PAGE_SIZE;
;;;827    		FLASH_Read(p_fcs->PageBuffer, addr, n_bytes);						// Прочитать страницу
;;;828    	}
;;;829    
;;;830    //------
;;;831    //<!> ДЛЯ ОТЛАДКИ !!!
;;;832    //ОЧИСТИТЬ ОСТАТОК БУФЕРА СТРАНИЦЫ
;;;833    for (k = n_bytes; k < PAGE_SIZE; k++) {
;;;834    	p_fcs->PageBuffer[k] = 0xFF;
;;;835    }
;;;836    //------
;;;837    
;;;838    	return FS_RESULT_OK;																// Файл для записи успешно открыт
;;;839    }
000506  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.1290|
00050a  49b9              LDR      r1,|L1.2032|
00050c  f8514020          LDR      r4,[r1,r0,LSL #2]     ;758
000510  7820              LDRB     r0,[r4,#0]            ;763
000512  2801              CMP      r0,#1                 ;763
000514  d002              BEQ      |L1.1308|
000516  f06f0006          MVN      r0,#6                 ;764
                  |L1.1306|
00051a  e7f4              B        |L1.1286|
                  |L1.1308|
00051c  f2041029          ADD      r0,r4,#0x129          ;768
000520  4683              MOV      r11,r0                ;768
000522  4602              MOV      r2,r0                 ;769
000524  f1040110          ADD      r1,r4,#0x10           ;769
000528  1c60              ADDS     r0,r4,#1              ;769
00052a  f7fffffe          BL       FS_GetFullName
00052e  4658              MOV      r0,r11                ;772
000530  f7fffffe          BL       FS_FindFileByName
000534  4681              MOV      r9,r0                 ;772
000536  f1b03fff          CMP      r0,#0xffffffff        ;773
00053a  d01f              BEQ      |L1.1404|
00053c  f7fffffe          BL       FS_FindFreeFNT
000540  4680              MOV      r8,r0                 ;778
000542  f1b03fff          CMP      r0,#0xffffffff        ;779
000546  d01c              BEQ      |L1.1410|
000548  2120              MOVS     r1,#0x20              ;790
00054a  eb011149          ADD      r1,r1,r9,LSL #5       ;790
00054e  220d              MOVS     r2,#0xd               ;793
000550  f10b0013          ADD      r0,r11,#0x13          ;793
000554  3113              ADDS     r1,r1,#0x13           ;793
000556  f7fffffe          BL       FLASH_Read
00055a  f894013c          LDRB     r0,[r4,#0x13c]        ;796
00055e  28fe              CMP      r0,#0xfe              ;796
000560  d012              BEQ      |L1.1416|
000562  49a2              LDR      r1,|L1.2028|
000564  f8d4013f          LDR      r0,[r4,#0x13f]        ;800
000568  f8b4713d          LDRH     r7,[r4,#0x13d]        ;806
00056c  8989              LDRH     r1,[r1,#0xc]          ;805  ; CLUSTER_SIZE
00056e  f3c02a05          UBFX     r10,r0,#8,#6          ;801
000572  b2c5              UXTB     r5,r0                 ;802
000574  fbb0f0f1          UDIV     r0,r0,r1              ;805
000578  b286              UXTH     r6,r0                 ;805
00057a  e00c              B        |L1.1430|
                  |L1.1404|
00057c  f06f000a          MVN      r0,#0xa               ;774
000580  e7c1              B        |L1.1286|
                  |L1.1410|
000582  f06f0008          MVN      r0,#8                 ;780
000586  e7be              B        |L1.1286|
                  |L1.1416|
000588  f06f000b          MVN      r0,#0xb               ;797
00058c  e7bb              B        |L1.1286|
                  |L1.1422|
00058e  4638              MOV      r0,r7                 ;808
000590  f7fffffe          BL       FS_GetNextCluster
000594  4607              MOV      r7,r0                 ;808
                  |L1.1430|
000596  1e76              SUBS     r6,r6,#1              ;807
000598  b2b6              UXTH     r6,r6                 ;807
00059a  d2f8              BCS      |L1.1422|
00059c  2100              MOVS     r1,#0                 ;812
00059e  4648              MOV      r0,r9                 ;812
0005a0  f7fffffe          BL       FS_FNTSetSignature1
0005a4  4659              MOV      r1,r11                ;813
0005a6  4640              MOV      r0,r8                 ;813
0005a8  f7fffffe          BL       FS_FNTWriteFullName
0005ac  2003              MOVS     r0,#3                 ;816
0005ae  7020              STRB     r0,[r4,#0]            ;816
0005b0  f8c48014          STR      r8,[r4,#0x14]         ;817
0005b4  8327              STRH     r7,[r4,#0x18]         ;818
0005b6  f884a01a          STRB     r10,[r4,#0x1a]        ;819
0005ba  f8a4501b          STRH     r5,[r4,#0x1b]         ;820
0005be  b15d              CBZ      r5,|L1.1496|
0005c0  488a              LDR      r0,|L1.2028|
0005c2  6a82              LDR      r2,[r0,#0x28]         ;824  ; CLUSTERS_BASE_ADDRESS
0005c4  8980              LDRH     r0,[r0,#0xc]          ;824  ; CLUSTER_SIZE
0005c6  eb02210a          ADD      r1,r2,r10,LSL #8      ;824
0005ca  fb071100          MLA      r1,r7,r0,r1           ;824
0005ce  462a              MOV      r2,r5                 ;827
0005d0  f104001d          ADD      r0,r4,#0x1d           ;827
0005d4  f7fffffe          BL       FLASH_Read
                  |L1.1496|
0005d8  20ff              MOVS     r0,#0xff              ;834
0005da  e003              B        |L1.1508|
                  |L1.1500|
0005dc  1961              ADDS     r1,r4,r5              ;834
0005de  1c6d              ADDS     r5,r5,#1              ;834
0005e0  7748              STRB     r0,[r1,#0x1d]         ;834
0005e2  b2ad              UXTH     r5,r5                 ;833
                  |L1.1508|
0005e4  2dff              CMP      r5,#0xff              ;833
0005e6  d9f9              BLS      |L1.1500|
0005e8  2000              MOVS     r0,#0                 ;838
0005ea  e78c              B        |L1.1286|
;;;840    
                          ENDP

                  FS_Reset PROC
;;;844    //-----------------------------------------------------------------------------
;;;845    s8 FS_Reset(tFile fcs_num) {
0005ec  e92d41f0          PUSH     {r4-r8,lr}
;;;846    	tFCS *p_fcs;															// Указатель на FCS
;;;847    	u8 *full_name;															// Указатель на полное имя файла
;;;848    	u32 fnt_num;															// Номер записи в таблице FNT
;;;849    	u8 len;
;;;850    	u32 addr;																// Адрес флэш-памяти
;;;851    	u32 size;
;;;852    	u16 k;
;;;853    
;;;854    	// Проверить файловую переменную (ошибка -9)
;;;855    	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
0005f0  2808              CMP      r0,#8
0005f2  d302              BCC      |L1.1530|
;;;856    		return EFS_INVALID_FSC;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
0005f4  f06f0005          MVN      r0,#5
                  |L1.1528|
;;;857    	}
;;;858    
;;;859    	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;860    
;;;861    	// ПЕРЕД ОТКРЫТИЕМ ФАЙЛА - ПРОВЕРИТЬ ВОЗМОЖНЫЕ ОШИБКИ
;;;862    
;;;863    	// Проверить состояние структуры FCS (ошибка -1)
;;;864    	if (p_fcs->State != FCS_STATE_OPENED) {									// Структура FCS открыта?
;;;865    		return EFS_FCS_NOT_OPENED;															// НЕТ - Вернуть ошибку "Структура FCS не открыта" (ошибка -1)
;;;866    	}
;;;867    
;;;868    	// Получить полное имя файла ( в форме: Signature1 + имя + тип + Signature2 )
;;;869    	full_name = p_fcs->FNT.FullName;										// Указатель на полное имя файла
;;;870    	FS_GetFullName(p_fcs->Name, p_fcs->Type, full_name);
;;;871    
;;;872    	// Поиск запрошенного файла в таблице FNT (ошибка -2)
;;;873    	fnt_num = FS_FindFileByName(full_name);									// Найти файл с заданным именем (включая сигнатуру)
;;;874    	if (fnt_num == 0xFFFFFFFF) {											// Найден файл с заданным именем?
;;;875    		return EFS_FILE_NOT_FOUND;															// НЕТ - Вернуть ошибку "Файл с заданным именем не найден" (ошибка -2)
;;;876    	}
;;;877    
;;;878    	// ОШИБОК НЕТ - ОТКРЫТЬ ФАЙЛ
;;;879    
;;;880    	// Заполнить начальными значениями структуру FCS.FNT
;;;881    	//p_fcs->FNT.FullName[];												...(полное имя = уже заполнено)
;;;882    
;;;883    	// Копировать в FCS.FNT запись из таблицы FNT
;;;884    	addr = FNT_BASE_ADDRESS + fnt_num * FNT_RECORD_SIZE;					// Адрес начала FNT открываемого файла
;;;885    
;;;886    	len = 1 + FILE_NAME_LENGTH + FILE_TYPE_LENGTH + 1;						// Длина полного имени
;;;887    	addr += len;															// Пропустить полное имя (полное имя не копировать, оно уже заполнено)
;;;888    	FLASH_Read(full_name + len, addr, FNT_RECORD_SIZE - len);				// Прочитать запись FNT (кроме полного имени)
;;;889    
;;;890    	// Заполнить FCS
;;;891    	p_fcs->State = FCS_STATE_OPENED_READ;									// Пометить - "Структура FCS открыта для чтения файла"
;;;892    	p_fcs->FNT_num = fnt_num;												// Номер записи таблицы FNT
;;;893    	p_fcs->CurrCluster = p_fcs->FNT.FirstCluster;							// Индекс (в таблице CAT) текущего кластера
;;;894    	p_fcs->CurrPage = 0;													// Номер текущей страницы в текущем кластере
;;;895    	p_fcs->PageBufPtr = 0;													// Текущий указатель в буфере страницы
;;;896    
;;;897    	size = p_fcs->FNT.Size;													// Взять размер файла
;;;898    	p_fcs->RemainSize = size;												// Осталось не прочитано байт
;;;899    
;;;900    	if (size > PAGE_SIZE) {													// Вычислить количество байт в первой странице
;;;901    		size = PAGE_SIZE;
;;;902    	}
;;;903    
;;;904    	// Прочитать первую страницу в буфер страницы
;;;905    	if (size) {																// Первая страница содержит данные?
;;;906    		addr = CLUSTERS_BASE_ADDRESS +										// Адрес страницы в флэш-памяти
;;;907    		       p_fcs->CurrCluster * CLUSTER_SIZE;							// (здесь номер страницы = 0)
;;;908    		FLASH_Read(p_fcs->PageBuffer, addr, size);							// Прочитать страницу
;;;909    	}
;;;910    
;;;911    //------
;;;912    //<!> ДЛЯ ОТЛАДКИ !!!
;;;913    //ОЧИСТИТЬ ОСТАТОК БУФЕРА СТРАНИЦЫ
;;;914    for (k = size; k < PAGE_SIZE; k++) {
;;;915    	p_fcs->PageBuffer[k] = 0xFF;
;;;916    }
;;;917    //------
;;;918    
;;;919    	p_fcs->MinFilePosition = 0;												// Мин. позиция файла в текущей странице
;;;920    	if (size == PAGE_SIZE) {												// Макс. позиция файла в текущей странице
;;;921    		p_fcs->MaxFilePosition = PAGE_SIZE-1;
;;;922    	}
;;;923    	else {
;;;924    		// здесь size < PAGE_SIZE
;;;925    		p_fcs->MaxFilePosition = size;
;;;926    	}
;;;927    
;;;928    	return FS_RESULT_OK;																// Файл для чтения успешно открыт
;;;929    }
0005f8  e60b              B        |L1.530|
                  |L1.1530|
0005fa  497d              LDR      r1,|L1.2032|
0005fc  f8514020          LDR      r4,[r1,r0,LSL #2]     ;859
000600  7820              LDRB     r0,[r4,#0]            ;864
000602  2801              CMP      r0,#1                 ;864
000604  d002              BEQ      |L1.1548|
000606  f06f0006          MVN      r0,#6                 ;865
00060a  e602              B        |L1.530|
                  |L1.1548|
00060c  f2041529          ADD      r5,r4,#0x129          ;869
000610  462a              MOV      r2,r5                 ;870
000612  f1040110          ADD      r1,r4,#0x10           ;870
000616  1c60              ADDS     r0,r4,#1              ;870
000618  f7fffffe          BL       FS_GetFullName
00061c  4628              MOV      r0,r5                 ;873
00061e  f7fffffe          BL       FS_FindFileByName
000622  4606              MOV      r6,r0                 ;873
000624  1c40              ADDS     r0,r0,#1              ;874
000626  d01c              BEQ      |L1.1634|
000628  2020              MOVS     r0,#0x20              ;884
00062a  eb001146          ADD      r1,r0,r6,LSL #5       ;884
00062e  220d              MOVS     r2,#0xd               ;888
000630  f1050013          ADD      r0,r5,#0x13           ;888
000634  3113              ADDS     r1,r1,#0x13           ;888
000636  f7fffffe          BL       FLASH_Read
00063a  2002              MOVS     r0,#2                 ;891
00063c  7020              STRB     r0,[r4,#0]            ;891
00063e  6166              STR      r6,[r4,#0x14]         ;892
000640  f8b4013d          LDRH     r0,[r4,#0x13d]        ;893
000644  8320              STRH     r0,[r4,#0x18]         ;893
000646  2600              MOVS     r6,#0                 ;894
000648  76a6              STRB     r6,[r4,#0x1a]         ;894
00064a  f8a4601b          STRH     r6,[r4,#0x1b]         ;895
00064e  f8d4513f          LDR      r5,[r4,#0x13f]        ;897
000652  f44f7780          MOV      r7,#0x100             ;900
000656  f8c4511d          STR      r5,[r4,#0x11d]        ;898
00065a  42bd              CMP      r5,r7                 ;900
00065c  d904              BLS      |L1.1640|
00065e  463d              MOV      r5,r7                 ;901
000660  e003              B        |L1.1642|
                  |L1.1634|
000662  f06f000a          MVN      r0,#0xa               ;875
000666  e5d4              B        |L1.530|
                  |L1.1640|
000668  b14d              CBZ      r5,|L1.1662|
                  |L1.1642|
00066a  4960              LDR      r1,|L1.2028|
00066c  898a              LDRH     r2,[r1,#0xc]          ;906  ; CLUSTER_SIZE
00066e  6a89              LDR      r1,[r1,#0x28]         ;906  ; CLUSTERS_BASE_ADDRESS
000670  fb001102          MLA      r1,r0,r2,r1           ;906
000674  462a              MOV      r2,r5                 ;908
000676  f104001d          ADD      r0,r4,#0x1d           ;908
00067a  f7fffffe          BL       FLASH_Read
                  |L1.1662|
00067e  b2a8              UXTH     r0,r5                 ;914
000680  21ff              MOVS     r1,#0xff              ;915
000682  e003              B        |L1.1676|
                  |L1.1668|
000684  1822              ADDS     r2,r4,r0              ;915
000686  1c40              ADDS     r0,r0,#1              ;915
000688  7751              STRB     r1,[r2,#0x1d]         ;915
00068a  b280              UXTH     r0,r0                 ;914
                  |L1.1676|
00068c  28ff              CMP      r0,#0xff              ;914
00068e  d9f9              BLS      |L1.1668|
000690  f8c46121          STR      r6,[r4,#0x121]        ;919
000694  42bd              CMP      r5,r7                 ;920
000696  d102              BNE      |L1.1694|
000698  f8c41125          STR      r1,[r4,#0x125]        ;921
00069c  e001              B        |L1.1698|
                  |L1.1694|
00069e  f8c45125          STR      r5,[r4,#0x125]        ;925
                  |L1.1698|
0006a2  2000              MOVS     r0,#0                 ;928
0006a4  e5b5              B        |L1.530|
;;;930    
                          ENDP

                  FS_WriteByte PROC
;;;934    //-----------------------------------------------------------------------------
;;;935    s8 FS_WriteByte(tFile fcs_num, u8 data) {
0006a6  e92d41f0          PUSH     {r4-r8,lr}
;;;936    	tFCS *p_fcs;															// Указатель на FCS
;;;937    	u16 page_buf_ptr;														// Указатель в буфере страницы
;;;938    	u8 curr_page;															// Номер текущей страницы в текущем кластере
;;;939    	u16 clust_num_next;
;;;940    	s8 result;																// Результат записи байта
;;;941    	u16 k;
;;;942    
;;;943    	// Проверить файловую переменную (ошибка -9)
;;;944    	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
0006aa  2808              CMP      r0,#8
0006ac  d302              BCC      |L1.1716|
;;;945    		return EFS_INVALID_FSC;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
0006ae  f06f0005          MVN      r0,#5
;;;946    	}
;;;947    
;;;948    	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;949    
;;;950    	// ПЕРЕД ЗАПИСЬЮ - ПРОВЕРИТЬ ВОЗМОЖНЫЕ ОШИБКИ
;;;951    
;;;952    	// Проверить состояние структуры FCS (ошибка -1)
;;;953    	if (p_fcs->State != FCS_STATE_OPENED_WRITE) {							// Структура FCS открыта для записи файла?
;;;954    		return EFS_FCS_NOT_OPENED_WRITE;															// НЕТ - Вернуть ошибку "Структура FCS не открыта для записи файла" (ошибка -1)
;;;955    	}
;;;956    
;;;957    	// ОШИБОК НЕТ - ЗАПИСАТЬ БАЙТ
;;;958    
;;;959    	p_fcs->FNT.Size++;														// Увеличить размер файла
;;;960    	page_buf_ptr = p_fcs->PageBufPtr;										// Взять текущий указатель в буфере страницы
;;;961    	p_fcs->PageBuffer[page_buf_ptr++] = data;								// Записать байт данных в буфер страницы
;;;962    
;;;963    	result = FS_RESULT_OK;																// Предварительный результат "Байт успешно записан"
;;;964    	if (page_buf_ptr == PAGE_SIZE) {										// Буфер страницы заполнился?
;;;965    		page_buf_ptr = 0;													// ДА - Сбросить текущий указатель в буфере страницы
;;;966    		FS_FlushPageBuffer(p_fcs, PAGE_SIZE);								// Записать буфер страницы в файл
;;;967    
;;;968    //------
;;;969    //<!> ДЛЯ ОТЛАДКИ !!!
;;;970    //ОЧИСТИТЬ БУФЕР СТРАНИЦЫ
;;;971    for (k = 0; k < PAGE_SIZE; k++) {
;;;972    	p_fcs->PageBuffer[k] = 0xFF;
;;;973    }
;;;974    //------
;;;975    		curr_page = p_fcs->CurrPage + 1;									// Увеличить номер текущей страницы
;;;976    		if (curr_page == PAGES_PER_CLUSTER) {								// Кластер заполнился?
;;;977    			curr_page = 0;													// ДА - Обнулить номер текущей страницы
;;;978    
;;;979    			// Проверить наличие свободного места (ошибка -2)
;;;980    			clust_num_next = FS_FindFreeCluster();							// Найти свободный кластер в таблице CAT
;;;981    			if (clust_num_next == 0xFFFF) {									// Свободный кластер найден?
;;;982    				result = EFS_NO_FREE_SPACE;												// НЕТ - Результат "Недостаточно места для последующей записи" (ошибка -2)
;;;983    			}
;;;984    			else {
;;;985    				FS_SetNextCluster(p_fcs->CurrCluster, clust_num_next);		// Записать указатель на следующий кластер в таблице CAT
;;;986    				FS_ClusterSetFlag(clust_num_next, 0xFE);					// Пометить новый кластер в таблице CAT = "Занято"
;;;987    				p_fcs->CurrCluster = clust_num_next;						// Изменить номер текущего кластера
;;;988    			}
;;;989    		}
;;;990    		p_fcs->CurrPage = curr_page;										// Сохранить номер текущей страницы
;;;991    	}
;;;992    	p_fcs->PageBufPtr = page_buf_ptr;										// Обновить текущий указатель в буфере страницы
;;;993    
;;;994    
;;;995    	return result;															// Результат записи байта
;;;996    }
0006b2  e5ae              B        |L1.530|
                  |L1.1716|
0006b4  4a4e              LDR      r2,|L1.2032|
0006b6  f8524020          LDR      r4,[r2,r0,LSL #2]     ;948
0006ba  7820              LDRB     r0,[r4,#0]            ;953
0006bc  2803              CMP      r0,#3                 ;953
0006be  d002              BEQ      |L1.1734|
0006c0  f06f000c          MVN      r0,#0xc               ;954
0006c4  e5a5              B        |L1.530|
                  |L1.1734|
0006c6  f8d4013f          LDR      r0,[r4,#0x13f]        ;959
0006ca  f04f0800          MOV      r8,#0                 ;963
0006ce  1c40              ADDS     r0,r0,#1              ;959
0006d0  f8c4013f          STR      r0,[r4,#0x13f]        ;959
0006d4  f8b4001b          LDRH     r0,[r4,#0x1b]         ;960
0006d8  1822              ADDS     r2,r4,r0              ;961
0006da  1c40              ADDS     r0,r0,#1              ;961
0006dc  7751              STRB     r1,[r2,#0x1d]         ;961
0006de  b286              UXTH     r6,r0                 ;961
0006e0  f44f7180          MOV      r1,#0x100             ;964
0006e4  428e              CMP      r6,r1                 ;964
0006e6  d122              BNE      |L1.1838|
0006e8  2600              MOVS     r6,#0                 ;965
0006ea  4620              MOV      r0,r4                 ;966
0006ec  f7fffffe          BL       FS_FlushPageBuffer
0006f0  2000              MOVS     r0,#0                 ;971
0006f2  21ff              MOVS     r1,#0xff              ;972
                  |L1.1780|
0006f4  1822              ADDS     r2,r4,r0              ;972
0006f6  1c40              ADDS     r0,r0,#1              ;972
0006f8  b280              UXTH     r0,r0                 ;971
0006fa  7751              STRB     r1,[r2,#0x1d]         ;972
0006fc  28ff              CMP      r0,#0xff              ;971
0006fe  d9f9              BLS      |L1.1780|
000700  7ea0              LDRB     r0,[r4,#0x1a]         ;975
000702  1c40              ADDS     r0,r0,#1              ;975
000704  b2c7              UXTB     r7,r0                 ;975
000706  2f40              CMP      r7,#0x40              ;976
000708  d110              BNE      |L1.1836|
00070a  2700              MOVS     r7,#0                 ;977
00070c  f7fffffe          BL       FS_FindFreeCluster
000710  4605              MOV      r5,r0                 ;980
000712  f5a0407f          SUB      r0,r0,#0xff00         ;981
000716  38ff              SUBS     r0,r0,#0xff           ;981
000718  d00d              BEQ      |L1.1846|
00071a  8b20              LDRH     r0,[r4,#0x18]         ;985
00071c  4629              MOV      r1,r5                 ;985
00071e  f7fffffe          BL       FS_SetNextCluster
000722  21fe              MOVS     r1,#0xfe              ;986
000724  4628              MOV      r0,r5                 ;986
000726  f7fffffe          BL       FS_ClusterSetFlag
00072a  8325              STRH     r5,[r4,#0x18]         ;987
                  |L1.1836|
00072c  76a7              STRB     r7,[r4,#0x1a]         ;990
                  |L1.1838|
00072e  f8a4601b          STRH     r6,[r4,#0x1b]         ;992
000732  4640              MOV      r0,r8                 ;995
000734  e56d              B        |L1.530|
                  |L1.1846|
000736  f06f0809          MVN      r8,#9                 ;982
00073a  e7f7              B        |L1.1836|
;;;997    
                          ENDP

                  FS_ReadByte PROC
;;;1001   //-----------------------------------------------------------------------------
;;;1002   s8 FS_ReadByte(tFile fcs_num, u8 *data) {
00073c  e92d47f0          PUSH     {r4-r10,lr}
;;;1003   	tFCS *p_fcs;															// Указатель на FCS
;;;1004   	u16 page_buf_ptr;														// Указатель в буфере страницы
;;;1005   	u8 *page_buffer;
;;;1006   	u16 page_size;															// Размер буфера страницы
;;;1007   	u32 remain_size;														// Оставшийся объем данных в файле
;;;1008   	u8  curr_page;															// Номер текущей страницы в текущем кластере
;;;1009   	u16 clust_num;
;;;1010   	u32 addr;
;;;1011   	u16 k;
;;;1012   
;;;1013   	// Проверить файловую переменную (ошибка -9)
;;;1014   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
000740  2808              CMP      r0,#8
000742  d302              BCC      |L1.1866|
;;;1015   		return EFS_INVALID_FSC;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
000744  f06f0005          MVN      r0,#5
                  |L1.1864|
;;;1016   	}
;;;1017   
;;;1018   	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;1019   
;;;1020   	// Проверить состояние структуры FCS (ошибка -1)
;;;1021   	if (p_fcs->State != FCS_STATE_OPENED_READ) {							// Структура FCS открыта для чтения файла?
;;;1022   		return EFS_FCS_NOT_OPENED_READ;															// НЕТ - Вернуть ошибку "Структура FCS не открыта для чтения файла" (ошибка -1)
;;;1023   	}
;;;1024   
;;;1025   	remain_size = p_fcs->RemainSize;
;;;1026   
;;;1027   	// Проверить кол-во непрочитанных байт (ошибка -2)
;;;1028   	if (! remain_size) {													// Имеются непрочитанные байты?
;;;1029   		return EFS_NO_DATA;															// НЕТ - Вернуть ошибку "Файл пуст" (ошибка -2)
;;;1030   	}
;;;1031   
;;;1032   	// ЗДЕСЬ ИМЕЮТСЯ ДАННЫЕ ДЛЯ ЧТЕНИЯ
;;;1033   
;;;1034   	p_fcs->RemainSize = --remain_size;										// Уменьшить кол-во непрочитанных байт
;;;1035   
;;;1036   	page_buf_ptr = p_fcs->PageBufPtr;										// Взять текущий указатель в буфере страницы
;;;1037   	page_buffer = p_fcs->PageBuffer;										// Взять указатель на буфер страницы
;;;1038   
;;;1039   	// Взять байт данных из буфера страницы
;;;1040   	// и передвинуть указатель в буфере страницы
;;;1041   	*data = page_buffer[page_buf_ptr++];
;;;1042   
;;;1043   	if (page_buf_ptr == PAGE_SIZE) {										// Буфер страницы полностью прочитан?
;;;1044   		page_buf_ptr = 0;													// ДА - Обнулить текущий указатель в буфере страницы
;;;1045   		clust_num = p_fcs->CurrCluster;										// Взять индекс (в таблице CAT) текущего кластера
;;;1046   		curr_page = p_fcs->CurrPage + 1;									// Увеличить номер текущей страницы
;;;1047   		if (curr_page == PAGES_PER_CLUSTER) {								// Кластер полностью прочитан?
;;;1048   			curr_page = 0;													// ДА - Обнулить номер текущей страницы
;;;1049   			clust_num = FS_GetNextCluster(clust_num);						// Следующий кластер в цепочке в таблице CAT
;;;1050   			p_fcs->CurrCluster = clust_num;									// Изменить номер текущего кластера
;;;1051   		}
;;;1052   		p_fcs->CurrPage = curr_page;										// Изменить номер текущей страницы
;;;1053   
;;;1054   		// Получить размер следующей сраницы файла
;;;1055   		if (remain_size > PAGE_SIZE) {
;;;1056   			page_size = PAGE_SIZE;
;;;1057   		}
;;;1058   		else {
;;;1059   			page_size = remain_size;
;;;1060   		}
;;;1061   
;;;1062   		// Прочитать следующую страницу файла в буфер
;;;1063   		if (page_size) {
;;;1064   			addr = CLUSTERS_BASE_ADDRESS +									// Адрес страницы в флэш-памяти
;;;1065   			       clust_num * CLUSTER_SIZE +
;;;1066   				   curr_page * PAGE_SIZE;
;;;1067   			FLASH_Read(page_buffer, addr, page_size);						// Прочитать страницу
;;;1068   		}
;;;1069   
;;;1070   //------
;;;1071   //<!> ДЛЯ ОТЛАДКИ !!!
;;;1072   //ОЧИСТИТЬ ОСТАТОК БУФЕРА СТРАНИЦЫ
;;;1073   for (k = page_size; k < PAGE_SIZE; k++) {
;;;1074   	page_buffer[k] = 0xFF;
;;;1075   }
;;;1076   //------
;;;1077   
;;;1078   		// Изменить диапазон позиции файла в текущей странице
;;;1079   		p_fcs->MinFilePosition += PAGE_SIZE;								// Мин. позиция файла в текущей странице
;;;1080   		if (page_size == PAGE_SIZE) {										// Макс. позиция файла в текущей странице
;;;1081   			p_fcs->MaxFilePosition += PAGE_SIZE;
;;;1082   		}
;;;1083   		else {
;;;1084   			// здесь page_size < PAGE_SIZE
;;;1085   			p_fcs->MaxFilePosition += page_size + 1;
;;;1086   		}
;;;1087   	}
;;;1088   	p_fcs->PageBufPtr = page_buf_ptr;										// Обновить текущий указатель в буфере страницы
;;;1089   
;;;1090   	return FS_RESULT_OK;																// Байт успешно прочитан
;;;1091   }
000748  e5c7              B        |L1.730|
                  |L1.1866|
00074a  4a29              LDR      r2,|L1.2032|
00074c  f8524020          LDR      r4,[r2,r0,LSL #2]     ;1018
000750  7820              LDRB     r0,[r4,#0]            ;1021
000752  2802              CMP      r0,#2                 ;1021
000754  d002              BEQ      |L1.1884|
000756  f06f000d          MVN      r0,#0xd               ;1022
00075a  e5be              B        |L1.730|
                  |L1.1884|
00075c  f8d4511d          LDR      r5,[r4,#0x11d]        ;1025
000760  b1bd              CBZ      r5,|L1.1938|
000762  1e6d              SUBS     r5,r5,#1              ;1028
000764  f8c4511d          STR      r5,[r4,#0x11d]        ;1034
000768  f8b4001b          LDRH     r0,[r4,#0x1b]         ;1036
00076c  f104081d          ADD      r8,r4,#0x1d           ;1037
000770  f44f7980          MOV      r9,#0x100             ;1043
000774  f8182000          LDRB     r2,[r8,r0]            ;1041
000778  1c40              ADDS     r0,r0,#1              ;1041
00077a  b287              UXTH     r7,r0                 ;1041
00077c  700a              STRB     r2,[r1,#0]            ;1041
00077e  454f              CMP      r7,r9                 ;1043
000780  d142              BNE      |L1.2056|
000782  7ea1              LDRB     r1,[r4,#0x1a]         ;1046
000784  2700              MOVS     r7,#0                 ;1044
000786  1c49              ADDS     r1,r1,#1              ;1046
000788  8b20              LDRH     r0,[r4,#0x18]         ;1045
00078a  b2ce              UXTB     r6,r1                 ;1046
00078c  2e40              CMP      r6,#0x40              ;1047
00078e  d003              BEQ      |L1.1944|
000790  e006              B        |L1.1952|
                  |L1.1938|
000792  f06f000e          MVN      r0,#0xe               ;1029
000796  e5a0              B        |L1.730|
                  |L1.1944|
000798  2600              MOVS     r6,#0                 ;1048
00079a  f7fffffe          BL       FS_GetNextCluster
00079e  8320              STRH     r0,[r4,#0x18]         ;1050
                  |L1.1952|
0007a0  76a6              STRB     r6,[r4,#0x1a]         ;1052
0007a2  454d              CMP      r5,r9                 ;1055
0007a4  d901              BLS      |L1.1962|
0007a6  464d              MOV      r5,r9                 ;1056
0007a8  e002              B        |L1.1968|
                  |L1.1962|
0007aa  042d              LSLS     r5,r5,#16             ;1059
0007ac  0c2d              LSRS     r5,r5,#16             ;1059
0007ae  d00c              BEQ      |L1.1994|
                  |L1.1968|
0007b0  490e              LDR      r1,|L1.2028|
0007b2  6a8a              LDR      r2,[r1,#0x28]         ;1064  ; CLUSTERS_BASE_ADDRESS
0007b4  8989              LDRH     r1,[r1,#0xc]          ;1064  ; CLUSTER_SIZE
0007b6  eb022206          ADD      r2,r2,r6,LSL #8       ;1064
0007ba  fb002101          MLA      r1,r0,r1,r2           ;1064
0007be  462a              MOV      r2,r5                 ;1067
0007c0  4640              MOV      r0,r8                 ;1067
0007c2  f7fffffe          BL       FLASH_Read
0007c6  4628              MOV      r0,r5                 ;1073
0007c8  e005              B        |L1.2006|
                  |L1.1994|
0007ca  4628              MOV      r0,r5                 ;1073
                  |L1.1996|
0007cc  22ff              MOVS     r2,#0xff              ;1074
0007ce  f8082000          STRB     r2,[r8,r0]            ;1074
0007d2  1c40              ADDS     r0,r0,#1              ;1074
0007d4  b280              UXTH     r0,r0                 ;1073
                  |L1.2006|
0007d6  28ff              CMP      r0,#0xff              ;1073
0007d8  d9f8              BLS      |L1.1996|
0007da  f8d40121          LDR      r0,[r4,#0x121]        ;1079
0007de  454d              CMP      r5,r9                 ;1080
0007e0  f5007080          ADD      r0,r0,#0x100          ;1079
0007e4  f8c40121          STR      r0,[r4,#0x121]        ;1079
0007e8  e004              B        |L1.2036|
0007ea  0000              DCW      0x0000
                  |L1.2028|
                          DCD      ||.data||
                  |L1.2032|
                          DCD      ||.bss||
                  |L1.2036|
0007f4  f8d40125          LDR      r0,[r4,#0x125]        ;1085
0007f8  d102              BNE      |L1.2048|
0007fa  f5007080          ADD      r0,r0,#0x100          ;1080
0007fe  e001              B        |L1.2052|
                  |L1.2048|
000800  1c6d              ADDS     r5,r5,#1              ;1081
000802  4428              ADD      r0,r0,r5              ;1085
                  |L1.2052|
000804  f8c40125          STR      r0,[r4,#0x125]        ;1081
                  |L1.2056|
000808  f8a4701b          STRH     r7,[r4,#0x1b]         ;1088
00080c  2000              MOVS     r0,#0                 ;1090
00080e  e564              B        |L1.730|
;;;1092   
                          ENDP

                  FS_Write PROC
;;;1097   //-----------------------------------------------------------------------------
;;;1098   s32 FS_Write(tFile fcs_num, const u8 *buffer, u32 size) {
000810  e92d41f0          PUSH     {r4-r8,lr}
000814  4690              MOV      r8,r2
;;;1099   	tFCS *p_fcs;															// Указатель на FCS
;;;1100   	u8 *page_buffer;
;;;1101   	u16 page_buf_ptr;														// Указатель в буфере страницы
;;;1102   	u16 remain_page;														// Размер остатка буфера страницы
;;;1103   	u16 first_size;															// Размер первой страницы
;;;1104   	u16 last_size;															// Размер последней страницы
;;;1105   	u32 full_page_count;													// Кол-во целых страниц
;;;1106   	u8  curr_page;															// Номер текущей страницы в текущем кластере
;;;1107   	u16 clust_num_next;															// Номер текущего кластера
;;;1108   //	u32 addr;
;;;1109   	u16 k;
;;;1110   
;;;1111   	// Проверить файловую переменную (ошибка -9)
;;;1112   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
000816  2808              CMP      r0,#8
000818  d302              BCC      |L1.2080|
;;;1113   		return -9;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
00081a  f06f0008          MVN      r0,#8
;;;1114   	}
;;;1115   
;;;1116   	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;1117   
;;;1118   	// ПЕРЕД ЗАПИСЬЮ - ПРОВЕРИТЬ ВОЗМОЖНЫЕ ОШИБКИ
;;;1119   
;;;1120   	// Проверить состояние структуры FCS (ошибка -1)
;;;1121   	if (p_fcs->State != FCS_STATE_OPENED_WRITE) {							// Структура FCS открыта для записи файла?
;;;1122   		return -1;															// НЕТ - Вернуть ошибку "Структура FCS не открыта для записи файла" (ошибка -1)
;;;1123   	}
;;;1124   
;;;1125   	// ОШИБОК НЕТ - ЗАПИСАТЬ БУФЕР
;;;1126   
;;;1127   	page_buffer = p_fcs->PageBuffer;										// Взять указатель на буфер страницы
;;;1128   	page_buf_ptr = p_fcs->PageBufPtr;										// Взять текущий указатель в буфере страницы
;;;1129   
;;;1130   	// Получить размер первой страницы
;;;1131   	remain_page = PAGE_SIZE - page_buf_ptr;									// Получить размер остатка в буфере страницы
;;;1132   	if (size < remain_page) {
;;;1133   		first_size = size;													// Весь размер запишется в остаток буфера страницы
;;;1134   		full_page_count = 0;												// Кол-во целых страниц = 0
;;;1135   	}
;;;1136   	if (size == remain_page) {
;;;1137   		first_size = remain_page;											// Остаток буфера страницы полностью запишется
;;;1138   		full_page_count = 1;												// Кол-во целых страниц = 1
;;;1139   		last_size = 0;														// Размер последней страницы = 0
;;;1140   	}
;;;1141   	if (size > remain_page) {
;;;1142   		first_size = remain_page;											// Остаток буфера страницы полностью запишется
;;;1143   		full_page_count = (size - remain_page) / PAGE_SIZE + 1;				// Кол-во целых страниц
;;;1144   		last_size = (size - remain_page) % PAGE_SIZE;						// Размер последней страницы
;;;1145   	}
;;;1146   
;;;1147   	// Записать первую страницу
;;;1148   	if (first_size) {														// Имеются байты для записи?
;;;1149   		memcpy(page_buffer + page_buf_ptr, buffer, first_size);				// ДА - Записать в буфер страницы
;;;1150   	}
;;;1151   	else {
;;;1152   		return 0;															// НЕТ - Результат = "Записано 0 байт"
;;;1153   	}
;;;1154   
;;;1155   	// Проверить заполнился ли буфер страницы?
;;;1156   	if (! full_page_count) {												// Буфер страницы не заполнился?
;;;1157   		p_fcs->PageBufPtr += first_size;									// ДА - Обновить текущий указатель в буфере страницы
;;;1158   		return size;														// Результат = "Записано size байт"
;;;1159   	}
;;;1160   	// Здесь завершено без записи буфера страницы в файл
;;;1161   
;;;1162   	// Здесь буфер страницы заполнен
;;;1163   	FS_FlushPageBuffer(p_fcs, PAGE_SIZE);									// Записать буфер страницы в файл
;;;1164   	full_page_count--;
;;;1165   
;;;1166   
;;;1167   
;;;1168   	if (last_size) {
;;;1169   	}
;;;1170   
;;;1171   
;;;1172   
;;;1173   //******************
;;;1174   		if (page_buf_ptr == PAGE_SIZE) {										// Буфер страницы заполнился?
;;;1175   			page_buf_ptr = 0;													// ДА - Сбросить текущий указатель в буфере страницы
;;;1176   			FS_FlushPageBuffer(p_fcs, PAGE_SIZE);								// Записать буфер страницы в файл
;;;1177   	
;;;1178   	//------
;;;1179   	//<!> ДЛЯ ОТЛАДКИ !!!
;;;1180   	//ОЧИСТИТЬ БУФЕР СТРАНИЦЫ
;;;1181   	for (k = 0; k < PAGE_SIZE; k++) {
;;;1182   		p_fcs->PageBuffer[k] = 0xFF;
;;;1183   	}
;;;1184   	//------
;;;1185   			curr_page = p_fcs->CurrPage + 1;									// Увеличить номер текущей страницы
;;;1186   			if (curr_page == PAGES_PER_CLUSTER) {								// Кластер заполнился?
;;;1187   				curr_page = 0;													// ДА - Обнулить номер текущей страницы
;;;1188   	
;;;1189   				// Проверить наличие свободного места (ошибка -2)
;;;1190   				clust_num_next = FS_FindFreeCluster();							// Найти свободный кластер в таблице CAT
;;;1191   				if (clust_num_next == 0xFFFF) {									// Свободный кластер найден?
;;;1192   //					result = -2;												// НЕТ - Результат "Недостаточно места для последующей записи" (ошибка -2)
;;;1193   				}
;;;1194   				else {
;;;1195   					FS_SetNextCluster(p_fcs->CurrCluster, clust_num_next);		// Записать указатель на следующий кластер в таблице CAT
;;;1196   					FS_ClusterSetFlag(clust_num_next, 0xFE);					// Пометить новый кластер в таблице CAT = "Занято"
;;;1197   					p_fcs->CurrCluster = clust_num_next;						// Изменить номер текущего кластера
;;;1198   				}
;;;1199   			}
;;;1200   			p_fcs->CurrPage = curr_page;										// Сохранить номер текущей страницы
;;;1201   		}
;;;1202   		p_fcs->PageBufPtr = page_buf_ptr;										// Обновить текущий указатель в буфере страницы
;;;1203   
;;;1204   
;;;1205   
;;;1206   
;;;1207   
;;;1208   
;;;1209   
;;;1210   
;;;1211   	return 0; // (фиктивный вовзврат)
;;;1212   }
00081e  e4f8              B        |L1.530|
                  |L1.2080|
000820  4af7              LDR      r2,|L1.3072|
000822  f8524020          LDR      r4,[r2,r0,LSL #2]     ;1116
000826  7820              LDRB     r0,[r4,#0]            ;1121
000828  2803              CMP      r0,#3                 ;1121
00082a  d002              BEQ      |L1.2098|
00082c  f04f30ff          MOV      r0,#0xffffffff        ;1122
000830  e4ef              B        |L1.530|
                  |L1.2098|
000832  f8b4601b          LDRH     r6,[r4,#0x1b]         ;1128
000836  f104021d          ADD      r2,r4,#0x1d           ;1127
00083a  f5c67080          RSB      r0,r6,#0x100          ;1131
00083e  b280              UXTH     r0,r0                 ;1131
000840  4580              CMP      r8,r0                 ;1132
000842  d203              BCS      |L1.2124|
000844  fa1ff588          UXTH     r5,r8                 ;1133
000848  f04f0700          MOV      r7,#0                 ;1134
                  |L1.2124|
00084c  d102              BNE      |L1.2132|
00084e  4605              MOV      r5,r0                 ;1137
000850  f04f0701          MOV      r7,#1                 ;1138
                  |L1.2132|
000854  d906              BLS      |L1.2148|
000856  4605              MOV      r5,r0                 ;1142
000858  eba80005          SUB      r0,r8,r5              ;1143
00085c  f04f0301          MOV      r3,#1                 ;1143
000860  eb032710          ADD      r7,r3,r0,LSR #8       ;1143
                  |L1.2148|
000864  b305              CBZ      r5,|L1.2216|
000866  eb020006          ADD      r0,r2,r6              ;1149
00086a  462a              MOV      r2,r5                 ;1149
00086c  f7fffffe          BL       __aeabi_memcpy
000870  b1e7              CBZ      r7,|L1.2220|
000872  f44f7580          MOV      r5,#0x100             ;1163
000876  4629              MOV      r1,r5                 ;1163
000878  4620              MOV      r0,r4                 ;1163
00087a  f7fffffe          BL       FS_FlushPageBuffer
00087e  42ae              CMP      r6,r5                 ;1174
000880  d12c              BNE      |L1.2268|
000882  2600              MOVS     r6,#0                 ;1175
000884  4629              MOV      r1,r5                 ;1176
000886  4620              MOV      r0,r4                 ;1176
000888  f7fffffe          BL       FS_FlushPageBuffer
00088c  2000              MOVS     r0,#0                 ;1181
00088e  21ff              MOVS     r1,#0xff              ;1182
                  |L1.2192|
000890  1822              ADDS     r2,r4,r0              ;1182
000892  1c40              ADDS     r0,r0,#1              ;1182
000894  b280              UXTH     r0,r0                 ;1181
000896  7751              STRB     r1,[r2,#0x1d]         ;1182
000898  28ff              CMP      r0,#0xff              ;1181
00089a  d9f9              BLS      |L1.2192|
00089c  7ea0              LDRB     r0,[r4,#0x1a]         ;1185
00089e  1c40              ADDS     r0,r0,#1              ;1185
0008a0  b2c7              UXTB     r7,r0                 ;1185
0008a2  2f40              CMP      r7,#0x40              ;1186
0008a4  d008              BEQ      |L1.2232|
0008a6  e018              B        |L1.2266|
                  |L1.2216|
0008a8  2000              MOVS     r0,#0                 ;1152
0008aa  e4b2              B        |L1.530|
                  |L1.2220|
0008ac  f8340f1b          LDRH     r0,[r4,#0x1b]!        ;1157
0008b0  4428              ADD      r0,r0,r5              ;1157
0008b2  8020              STRH     r0,[r4,#0]            ;1157
0008b4  4640              MOV      r0,r8                 ;1158
0008b6  e4ac              B        |L1.530|
                  |L1.2232|
0008b8  2700              MOVS     r7,#0                 ;1187
0008ba  f7fffffe          BL       FS_FindFreeCluster
0008be  4605              MOV      r5,r0                 ;1190
0008c0  f5a0407f          SUB      r0,r0,#0xff00         ;1191
0008c4  38ff              SUBS     r0,r0,#0xff           ;1191
0008c6  d008              BEQ      |L1.2266|
0008c8  8b20              LDRH     r0,[r4,#0x18]         ;1195
0008ca  4629              MOV      r1,r5                 ;1195
0008cc  f7fffffe          BL       FS_SetNextCluster
0008d0  21fe              MOVS     r1,#0xfe              ;1196
0008d2  4628              MOV      r0,r5                 ;1196
0008d4  f7fffffe          BL       FS_ClusterSetFlag
0008d8  8325              STRH     r5,[r4,#0x18]         ;1197
                  |L1.2266|
0008da  76a7              STRB     r7,[r4,#0x1a]         ;1200
                  |L1.2268|
0008dc  f8a4601b          STRH     r6,[r4,#0x1b]         ;1202
0008e0  e7e2              B        |L1.2216|
;;;1213   
                          ENDP

                  FS_Read PROC
;;;1218   //-----------------------------------------------------------------------------
;;;1219   s32 FS_Read(tFile fcs_num, u8 *buffer, u32 size) {
0008e2  e92d5ff0          PUSH     {r4-r12,lr}
0008e6  468a              MOV      r10,r1
;;;1220   	tFCS *p_fcs;															// Указатель на FCS
;;;1221   	u8 *page_buffer;
;;;1222   	u16 page_buf_ptr;														// Указатель в буфере страницы
;;;1223   	u16 first_size;															// Размер первой страницы
;;;1224   	u16 last_size;															// Размер последней страницы
;;;1225   	u32 full_page_count;													// Кол-во целых страниц
;;;1226   	u32 remain_size;														// Оставшийся размер файла
;;;1227   	u8  curr_page;															// Номер текущей страницы в текущем кластере
;;;1228   	u16 clust_num;
;;;1229   	u32 addr;
;;;1230   
;;;1231   	// Проверить файловую переменную (ошибка -9)
;;;1232   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
0008e8  2808              CMP      r0,#8
0008ea  d302              BCC      |L1.2290|
;;;1233   		return -9;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
0008ec  f06f0008          MVN      r0,#8
                  |L1.2288|
;;;1234   	}
;;;1235   
;;;1236   	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;1237   
;;;1238   	// Проверить состояние структуры FCS (ошибка -1)
;;;1239   	if (p_fcs->State != FCS_STATE_OPENED_READ) {							// Структура FCS открыта для чтения файла?
;;;1240   		return -1;															// НЕТ - Вернуть ошибку "Структура FCS не открыта для чтения файла" (ошибка -1)
;;;1241   	}
;;;1242   
;;;1243   	// ОШИБОК НЕТ - ПРОЧИТАТЬ БУФЕР
;;;1244   
;;;1245   	remain_size = p_fcs->RemainSize;										// Оставшийся объем данных в файле
;;;1246   
;;;1247   	// Проверить - Конец файла или нет?
;;;1248   	if (! remain_size) {													// Имеются непрочитанные байты файла?
;;;1249   		return 0;															// НЕТ - Вернуть результат "Прочитано 0 байт"
;;;1250   	}
;;;1251   
;;;1252   	if (! size) {															// Запрашиваемый объем > 0?
;;;1253   		return 0;															// НЕТ - Вернуть результат "Прочитано 0 байт"
;;;1254   	}
;;;1255   
;;;1256   	// Скорректировать запрашиваемый объем данных
;;;1257   	// (ограничить запрашиваемый объем до остатка файла)
;;;1258   	if (size > remain_size) {
;;;1259   		size = remain_size;
;;;1260   	}
;;;1261   
;;;1262   	page_buffer = p_fcs->PageBuffer;										// Взять указатель на буфер страницы
;;;1263   	page_buf_ptr = p_fcs->PageBufPtr;										// Взять текущий указатель в буфере страницы
;;;1264   
;;;1265   	// Получить размер первой страницы
;;;1266   	first_size = PAGE_SIZE - page_buf_ptr;									// Получить размер остатка в буфере страницы
;;;1267   	if (first_size >= size) {
;;;1268   		first_size = size;													// Весь запрашиваемый размер содержится в буфере страницы
;;;1269   		full_page_count = 0;												// Кол-во целых страниц = 0
;;;1270   		last_size = 0;														// Размер последней страницы = 0
;;;1271   	}
;;;1272   	else {
;;;1273   		full_page_count = (size - first_size) / PAGE_SIZE;					// Кол-во целых страниц
;;;1274   		last_size = (size - first_size) % PAGE_SIZE;						// Размер последней страницы
;;;1275   	}
;;;1276   
;;;1277   	// Прочитать первую страницу
;;;1278   	// (первая страница всегда есть и находится в буфере страницы)
;;;1279   	memcpy(buffer, page_buffer + page_buf_ptr, first_size);					// Скопировать блок из буфера страницы
;;;1280   	page_buf_ptr += first_size;												// Передвинуть указатель в буфере страницы
;;;1281   	remain_size -= first_size;												// Скорректировать оставшийся размер файла
;;;1282   
;;;1283   	clust_num = p_fcs->CurrCluster;											// Взять индекс (в таблице CAT) текущего кластера
;;;1284   	curr_page = p_fcs->CurrPage;											// Взять номер текущей страницы
;;;1285   
;;;1286   	// Прочитать целые страницы
;;;1287   	if (full_page_count) {
;;;1288   		buffer += first_size;												// Передвинуть позицию входного буфера
;;;1289   	}
;;;1290   	while (full_page_count--) {
;;;1291   		// Загрузить следующую страницу файла
;;;1292   		curr_page++;														// Увеличить номер текущей страницы
;;;1293   		if (curr_page == PAGES_PER_CLUSTER) {								// Кластер полностью прочитан?
;;;1294   			curr_page = 0;													// ДА - Обнулить номер текущей страницы
;;;1295   			clust_num = FS_GetNextCluster(clust_num);						// Следующий кластер в цепочке в таблице CAT
;;;1296   //			p_fcs->CurrCluster = clust_num;									// Изменить номер текущего кластера
;;;1297   		}
;;;1298   //		p_fcs->CurrPage = curr_page;										// Изменить номер текущей страницы
;;;1299   //		page_buf_ptr = 0;													// Обнулить текущий указатель в буфере страницы
;;;1300   
;;;1301   		// Прочитать следующую страницу файла в приемный буфер
;;;1302   		addr = CLUSTERS_BASE_ADDRESS +										// Адрес страницы в флэш-памяти
;;;1303   		       clust_num * CLUSTER_SIZE +
;;;1304   			   curr_page * PAGE_SIZE;
;;;1305   		FLASH_Read(buffer, addr, PAGE_SIZE);								// Прочитать страницу сразу в приемный буфер
;;;1306   
;;;1307   		remain_size -= PAGE_SIZE;											// Скорректировать оставшийся размер файла
;;;1308   		buffer += PAGE_SIZE;												// Передвинуть позицию входного буфера
;;;1309   	}
;;;1310   
;;;1311   	// Прочитать последнюю страницу
;;;1312   	if (last_size) {
;;;1313   		clust_num = p_fcs->CurrCluster;										// Взять индекс (в таблице CAT) текущего кластера
;;;1314   		curr_page = p_fcs->CurrPage;										// Взять номер текущей страницы
;;;1315   	}
;;;1316   
;;;1317   
;;;1318   
;;;1319   
;;;1320   
;;;1321   
;;;1322   
;;;1323   
;;;1324   	p_fcs->CurrCluster = clust_num;											// Изменить номер текущего кластера
;;;1325   	p_fcs->CurrPage = curr_page;											// Изменить номер текущей страницы
;;;1326   
;;;1327   
;;;1328   
;;;1329   
;;;1330   	// Изменить диапазон позиции файла в текущей странице
;;;1331   	p_fcs->MinFilePosition += PAGE_SIZE;									// Мин. позиция файла в текущей странице
;;;1332   	p_fcs->MaxFilePosition += PAGE_SIZE;									// Макс. позиция файла в текущей странице
;;;1333   
;;;1334   
;;;1335   	return 0; // (фиктивный вовзврат)
;;;1336   }
0008f0  e609              B        |L1.1286|
                  |L1.2290|
0008f2  49c3              LDR      r1,|L1.3072|
0008f4  f8514020          LDR      r4,[r1,r0,LSL #2]     ;1236
0008f8  f04f30ff          MOV      r0,#0xffffffff        ;1240
0008fc  7821              LDRB     r1,[r4,#0]            ;1239
0008fe  2902              CMP      r1,#2                 ;1239
000900  d1f6              BNE      |L1.2288|
000902  f8d4011d          LDR      r0,[r4,#0x11d]        ;1245
000906  2800              CMP      r0,#0                 ;1248
000908  d0f2              BEQ      |L1.2288|
00090a  b17a              CBZ      r2,|L1.2348|
00090c  4282              CMP      r2,r0                 ;1258
00090e  d900              BLS      |L1.2322|
000910  4602              MOV      r2,r0                 ;1259
                  |L1.2322|
000912  f8b4001b          LDRH     r0,[r4,#0x1b]         ;1263
000916  f104011d          ADD      r1,r4,#0x1d           ;1262
00091a  f5c07380          RSB      r3,r0,#0x100          ;1266
00091e  b29e              UXTH     r6,r3                 ;1266
000920  4296              CMP      r6,r2                 ;1267
000922  d305              BCC      |L1.2352|
000924  b296              UXTH     r6,r2                 ;1268
000926  2700              MOVS     r7,#0                 ;1269
000928  463a              MOV      r2,r7                 ;1270
00092a  e004              B        |L1.2358|
                  |L1.2348|
00092c  2000              MOVS     r0,#0                 ;1253
00092e  e5ea              B        |L1.1286|
                  |L1.2352|
000930  1b92              SUBS     r2,r2,r6              ;1273
000932  0a17              LSRS     r7,r2,#8              ;1273
000934  b2d2              UXTB     r2,r2                 ;1274
                  |L1.2358|
000936  4691              MOV      r9,r2                 ;1274
000938  4401              ADD      r1,r1,r0              ;1279
00093a  4632              MOV      r2,r6                 ;1279
00093c  4650              MOV      r0,r10                ;1279
00093e  f7fffffe          BL       __aeabi_memcpy
000942  f8b48018          LDRH     r8,[r4,#0x18]         ;1283
000946  7ea5              LDRB     r5,[r4,#0x1a]         ;1284
000948  b1f7              CBZ      r7,|L1.2440|
00094a  4456              ADD      r6,r6,r10             ;1288
00094c  f8dfa2b4          LDR      r10,|L1.3076|
000950  f44f7b80          MOV      r11,#0x100            ;1305
000954  e016              B        |L1.2436|
                  |L1.2390|
000956  1c6d              ADDS     r5,r5,#1              ;1288
000958  b2ed              UXTB     r5,r5                 ;1292
00095a  2d40              CMP      r5,#0x40              ;1293
00095c  d104              BNE      |L1.2408|
00095e  2500              MOVS     r5,#0                 ;1294
000960  4640              MOV      r0,r8                 ;1295
000962  f7fffffe          BL       FS_GetNextCluster
000966  4680              MOV      r8,r0                 ;1295
                  |L1.2408|
000968  f8da1028          LDR      r1,[r10,#0x28]        ;1302  ; CLUSTERS_BASE_ADDRESS
00096c  f8ba000c          LDRH     r0,[r10,#0xc]         ;1302  ; CLUSTER_SIZE
000970  eb012205          ADD      r2,r1,r5,LSL #8       ;1302
000974  fb082100          MLA      r1,r8,r0,r2           ;1302
000978  465a              MOV      r2,r11                ;1305
00097a  4630              MOV      r0,r6                 ;1305
00097c  f7fffffe          BL       FLASH_Read
000980  f5067680          ADD      r6,r6,#0x100          ;1305
                  |L1.2436|
000984  1e7f              SUBS     r7,r7,#1              ;1305
000986  d2e6              BCS      |L1.2390|
                  |L1.2440|
000988  f1b90f00          CMP      r9,#0                 ;1312
00098c  d002              BEQ      |L1.2452|
00098e  f8b48018          LDRH     r8,[r4,#0x18]         ;1313
000992  7ea5              LDRB     r5,[r4,#0x1a]         ;1314
                  |L1.2452|
000994  f8a48018          STRH     r8,[r4,#0x18]         ;1324
000998  76a5              STRB     r5,[r4,#0x1a]         ;1325
00099a  f8d40121          LDR      r0,[r4,#0x121]        ;1331
00099e  f5007080          ADD      r0,r0,#0x100          ;1331
0009a2  f8c40121          STR      r0,[r4,#0x121]        ;1331
0009a6  f8d40125          LDR      r0,[r4,#0x125]        ;1332
0009aa  f5007080          ADD      r0,r0,#0x100          ;1332
0009ae  f8c40125          STR      r0,[r4,#0x125]        ;1332
0009b2  e7bb              B        |L1.2348|
;;;1337   
                          ENDP

                  FS_WriteLn PROC
;;;1342   //-----------------------------------------------------------------------------
;;;1343   s32 FS_WriteLn(tFile fcs_num, const u8 *str) {
0009b4  2808              CMP      r0,#8
0009b6  d302              BCC      |L1.2494|
;;;1344   
;;;1345   	// Проверить файловую переменную (ошибка -9)
;;;1346   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
;;;1347   		return -9;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
0009b8  f06f0008          MVN      r0,#8
                  |L1.2492|
;;;1348   	}
;;;1349   
;;;1350   	return 0; // (фиктивный вовзврат)
;;;1351   }
0009bc  e510              B        |L1.992|
                  |L1.2494|
0009be  2000              MOVS     r0,#0                 ;1350
0009c0  e50e              B        |L1.992|
;;;1352   
                          ENDP

                  FS_ReadLn PROC
;;;1356   //-----------------------------------------------------------------------------
;;;1357   s8 FS_ReadLn(tFile fcs_num, u8 *str, u32 max_size) {
0009c2  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
0009c6  468b              MOV      r11,r1
;;;1358   	tFCS *p_fcs;															// Указатель на FCS
;;;1359   	u8 *page_buffer;
;;;1360   	u16 page_buf_ptr;														// Указатель в буфере страницы
;;;1361   	u16 page_size;															// Размер буфера страницы
;;;1362   	u32 remain_size;														// Оставшийся объем данных в файле
;;;1363   	u8  curr_page;															// Номер текущей страницы в текущем кластере
;;;1364   	u16 clust_num;
;;;1365   	u32 addr;
;;;1366   	u8 s;																	// Символ прочитанный из файла
;;;1367   	u32 i;																	// Индекс символа в строке
;;;1368   	u16 k;
;;;1369   	s8 result;
;;;1370   
;;;1371   	// Проверить файловую переменную (ошибка -9)
;;;1372   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
0009c8  2808              CMP      r0,#8
0009ca  d303              BCC      |L1.2516|
;;;1373   		return -9;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
0009cc  f06f0008          MVN      r0,#8
                  |L1.2512|
;;;1374   	}
;;;1375   
;;;1376   	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;1377   
;;;1378   	// Проверить состояние структуры FCS (ошибка -1)
;;;1379   	if (p_fcs->State != FCS_STATE_OPENED_READ) {							// Структура FCS открыта для чтения файла?
;;;1380   		return -1;															// НЕТ - Вернуть ошибку "Структура FCS не открыта для чтения файла" (ошибка -1)
;;;1381   	}
;;;1382   
;;;1383   	// ОШИБОК НЕТ - ПРОЧИТАТЬ СТРОКУ
;;;1384   
;;;1385   	remain_size = p_fcs->RemainSize;										// Оставшийся объем данных в файле
;;;1386   
;;;1387   	// Проверить - Конец файла или нет?
;;;1388   	if (! remain_size) {													// Имеются непрочитанные байты файла?
;;;1389   		str[0] = 0;															// НЕТ - Вернуть пустую строку
;;;1390   		return -2;															// Вернуть ошибку "Файл пуст" (ошибка -2)
;;;1391   	}
;;;1392   
;;;1393   	page_buffer = p_fcs->PageBuffer;										// Взять указатель на буфер страницы
;;;1394   	page_buf_ptr = p_fcs->PageBufPtr;										// Взять текущий указатель в буфере страницы
;;;1395   
;;;1396   	page_size = PAGE_SIZE - page_buf_ptr;									// Получить размер остатка в буфере сраницы
;;;1397   	if (page_size > remain_size) {
;;;1398   		page_size = remain_size;
;;;1399   	}
;;;1400   
;;;1401   	// Начало чтения строки
;;;1402   	i = 0;																	// Встать в начало строки
;;;1403   	do {
;;;1404   		// Цикл чтения строки из буфера страницы
;;;1405   		while (page_size) {
;;;1406   			s = page_buffer[page_buf_ptr++];								// Взять следующий символ из буфера страницы
;;;1407   			remain_size--;													// Оставшийся объем данных в файле
;;;1408   			if (s == 10) {													// Игнорировать символ #10
;;;1409   				page_size--;												// Оставшийся размер страницы
;;;1410   				continue;
;;;1411   			}
;;;1412   			if (s == 13) {													// Встретился символ #13 ?
;;;1413   				str[i] = 0;													// Завершить прочитанную строку нулевым символом
;;;1414   				result = 0;													// Результат = Строка успешно прочитана
;;;1415   				break;														// Строка прочитана, завершить цикл чтения строки
;;;1416   			}
;;;1417   			if (s == 0) {													// Встретился нулевой байт?
;;;1418   				str[i] = 0;													// ДА - Завершить прочитанную строку нулевым символом
;;;1419   				result = -3;												// Результат = Ошибка: "Нулевой байт" (ошибка -3)
;;;1420   				break;														// Завершить цикл чтения строки
;;;1421   			}
;;;1422   			// Здесь "хороший" символ
;;;1423   			if (i < max_size) {
;;;1424   				str[i++] = s;												// Положить очередной символ в буфер строки
;;;1425   			}
;;;1426   			else {
;;;1427   				str[i] = 0;													// Завершить прочитанную строку нулевым символом
;;;1428   				// Превышено максимальное кол-во прочитанных символов
;;;1429   				page_buf_ptr--;												// Откатить указатель в буфере страницы
;;;1430   				remain_size++;												// Откатить оставшийся объем данных в файле
;;;1431   				result = -4;												// Результат = Ошибка: "Превышена максимальная длина строки" (ошибка -4)
;;;1432   				break;														// Завершить цикл чтения строки
;;;1433   			}
;;;1434   			// (если выходим из цикла по break, то page_size не обнулится)
;;;1435   			page_size--;													// Оставшийся размер страницы
;;;1436   		}
;;;1437   		// Проверить причину завершения цикла чтения строки
;;;1438   		if (page_size) {													// Цикл завершился по break ?
;;;1439   			p_fcs->RemainSize = remain_size;								// ДА - Сохранить оставшийся объем данных в файле
;;;1440   			p_fcs->PageBufPtr = page_buf_ptr;								// Сохранить текущий указатель в буфере страницы
;;;1441   			return result;													// Завершить - Вернуть результат чтения строки
;;;1442   		}
;;;1443   		// Буфер страницы закончился, а строка все еще не прочитана
;;;1444   
;;;1445   		// Проверить - Конец файла или нет?
;;;1446   		if (! remain_size) {												// Имеются еще непрочитанные байты файла?
;;;1447   			str[i] = 0;														// НЕТ - Завершить строку
;;;1448   			p_fcs->RemainSize = 0;											// Сохранить оставшийся объем данных в файле
;;;1449   			p_fcs->PageBufPtr = page_buf_ptr;								// Сохранить текущий указатель в буфере страницы
;;;1450   			return 0;														// Результат = Строка успешно прочитана
;;;1451   		}
;;;1452   
;;;1453   		// Не конец файла - загрузить следующую страницу файла
;;;1454   		clust_num = p_fcs->CurrCluster;										// Взять индекс (в таблице CAT) текущего кластера
;;;1455   		curr_page = p_fcs->CurrPage + 1;									// Увеличить номер текущей страницы
;;;1456   		if (curr_page == PAGES_PER_CLUSTER) {								// Кластер полностью прочитан?
;;;1457   			curr_page = 0;													// ДА - Обнулить номер текущей страницы
;;;1458   			clust_num = FS_GetNextCluster(clust_num);						// Следующий кластер в цепочке в таблице CAT
;;;1459   			p_fcs->CurrCluster = clust_num;									// Изменить номер текущего кластера
;;;1460   		}
;;;1461   		p_fcs->CurrPage = curr_page;										// Изменить номер текущей страницы
;;;1462   		page_buf_ptr = 0;													// Обнулить текущий указатель в буфере страницы
;;;1463   
;;;1464   		// Получить размер следующей сраницы файла
;;;1465   		if (remain_size < PAGE_SIZE) {
;;;1466   			page_size = remain_size;
;;;1467   		}
;;;1468   		else {
;;;1469   			page_size = PAGE_SIZE;
;;;1470   		}
;;;1471   
;;;1472   		// Прочитать следующую страницу файла в буфер страницы
;;;1473   		addr = CLUSTERS_BASE_ADDRESS +										// Адрес страницы в флэш-памяти
;;;1474   		       clust_num * CLUSTER_SIZE +
;;;1475   			   curr_page * PAGE_SIZE;
;;;1476   		FLASH_Read(page_buffer, addr, page_size);							// Прочитать страницу
;;;1477   
;;;1478   //------
;;;1479   //<!> ДЛЯ ОТЛАДКИ !!!
;;;1480   //ОЧИСТИТЬ ОСТАТОК БУФЕРА СТРАНИЦЫ
;;;1481   for (k = page_size; k < PAGE_SIZE; k++) {
;;;1482   	page_buffer[k] = 0xFF;
;;;1483   }
;;;1484   //------
;;;1485   
;;;1486   		// Изменить диапазон позиции файла в текущей странице
;;;1487   		p_fcs->MinFilePosition += PAGE_SIZE;								// Мин. позиция файла в текущей странице
;;;1488   		p_fcs->MaxFilePosition += page_size;								// Макс. позиция файла в текущей странице
;;;1489   
;;;1490   	} while (1);
;;;1491   	// Цикл do... while завершится выходом return внутри цикла
;;;1492   }
0009d0  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.2516|
0009d4  498a              LDR      r1,|L1.3072|
0009d6  f8515020          LDR      r5,[r1,r0,LSL #2]     ;1376
0009da  7828              LDRB     r0,[r5,#0]            ;1379
0009dc  2802              CMP      r0,#2                 ;1379
0009de  d002              BEQ      |L1.2534|
0009e0  f04f30ff          MOV      r0,#0xffffffff        ;1380
0009e4  e7f4              B        |L1.2512|
                  |L1.2534|
0009e6  f8d5611d          LDR      r6,[r5,#0x11d]        ;1385
0009ea  b166              CBZ      r6,|L1.2566|
0009ec  f8b5701b          LDRH     r7,[r5,#0x1b]         ;1394
0009f0  f105081d          ADD      r8,r5,#0x1d           ;1393
0009f4  f5c77080          RSB      r0,r7,#0x100          ;1396
0009f8  b284              UXTH     r4,r0                 ;1396
0009fa  42b4              CMP      r4,r6                 ;1397
0009fc  d900              BLS      |L1.2560|
0009fe  b2b4              UXTH     r4,r6                 ;1398
                  |L1.2560|
000a00  f04f0900          MOV      r9,#0                 ;1402
000a04  e02f              B        |L1.2662|
                  |L1.2566|
000a06  2000              MOVS     r0,#0                 ;1389
000a08  f88b0000          STRB     r0,[r11,#0]           ;1389
000a0c  1e80              SUBS     r0,r0,#2              ;1390
000a0e  e7df              B        |L1.2512|
                  |L1.2576|
000a10  f8180007          LDRB     r0,[r8,r7]            ;1406
000a14  1c7f              ADDS     r7,r7,#1              ;1406
000a16  1e76              SUBS     r6,r6,#1              ;1406
000a18  b2bf              UXTH     r7,r7                 ;1406
000a1a  280a              CMP      r0,#0xa               ;1408
000a1c  d009              BEQ      |L1.2610|
000a1e  280d              CMP      r0,#0xd               ;1412
000a20  d00a              BEQ      |L1.2616|
000a22  b170              CBZ      r0,|L1.2626|
000a24  9a02              LDR      r2,[sp,#8]            ;1423
000a26  4591              CMP      r9,r2                 ;1423
000a28  d210              BCS      |L1.2636|
000a2a  f80b0009          STRB     r0,[r11,r9]           ;1424
000a2e  f1090901          ADD      r9,r9,#1              ;1424
                  |L1.2610|
000a32  1e64              SUBS     r4,r4,#1              ;1424
000a34  b2a4              UXTH     r4,r4                 ;1409
000a36  e016              B        |L1.2662|
                  |L1.2616|
000a38  2200              MOVS     r2,#0                 ;1413
000a3a  f80b2009          STRB     r2,[r11,r9]           ;1413
000a3e  4610              MOV      r0,r2                 ;1414
000a40  e00b              B        |L1.2650|
                  |L1.2626|
000a42  2000              MOVS     r0,#0                 ;1418
000a44  f80b0009          STRB     r0,[r11,r9]           ;1418
000a48  1ec0              SUBS     r0,r0,#3              ;1419
000a4a  e006              B        |L1.2650|
                  |L1.2636|
000a4c  2000              MOVS     r0,#0                 ;1427
000a4e  f80b0009          STRB     r0,[r11,r9]           ;1427
000a52  1e7f              SUBS     r7,r7,#1              ;1427
000a54  1f00              SUBS     r0,r0,#4              ;1431
000a56  b2bf              UXTH     r7,r7                 ;1429
000a58  1c76              ADDS     r6,r6,#1              ;1431
                  |L1.2650|
000a5a  b134              CBZ      r4,|L1.2666|
000a5c  f8c5611d          STR      r6,[r5,#0x11d]        ;1439
000a60  f8a5701b          STRH     r7,[r5,#0x1b]         ;1440
000a64  e7b4              B        |L1.2512|
                  |L1.2662|
000a66  2c00              CMP      r4,#0                 ;1405
000a68  d1d2              BNE      |L1.2576|
                  |L1.2666|
000a6a  b146              CBZ      r6,|L1.2686|
000a6c  7ea9              LDRB     r1,[r5,#0x1a]         ;1455
000a6e  8b28              LDRH     r0,[r5,#0x18]         ;1454
000a70  1c49              ADDS     r1,r1,#1              ;1455
000a72  f0010aff          AND      r10,r1,#0xff          ;1455
000a76  f1ba0f40          CMP      r10,#0x40             ;1456
000a7a  d008              BEQ      |L1.2702|
000a7c  e00c              B        |L1.2712|
                  |L1.2686|
000a7e  2000              MOVS     r0,#0                 ;1447
000a80  f80b0009          STRB     r0,[r11,r9]           ;1447
000a84  f8c5011d          STR      r0,[r5,#0x11d]        ;1448
000a88  f8a5701b          STRH     r7,[r5,#0x1b]         ;1449
000a8c  e7a0              B        |L1.2512|
                  |L1.2702|
000a8e  f04f0a00          MOV      r10,#0                ;1457
000a92  f7fffffe          BL       FS_GetNextCluster
000a96  8328              STRH     r0,[r5,#0x18]         ;1459
                  |L1.2712|
000a98  2700              MOVS     r7,#0                 ;1462
000a9a  f885a01a          STRB     r10,[r5,#0x1a]        ;1461
000a9e  2eff              CMP      r6,#0xff              ;1465
000aa0  d801              BHI      |L1.2726|
000aa2  b2b4              UXTH     r4,r6                 ;1466
000aa4  e001              B        |L1.2730|
                  |L1.2726|
000aa6  f44f7480          MOV      r4,#0x100             ;1469
                  |L1.2730|
000aaa  4956              LDR      r1,|L1.3076|
000aac  6a8b              LDR      r3,[r1,#0x28]         ;1473  ; CLUSTERS_BASE_ADDRESS
000aae  8989              LDRH     r1,[r1,#0xc]          ;1473  ; CLUSTER_SIZE
000ab0  eb03220a          ADD      r2,r3,r10,LSL #8      ;1473
000ab4  fb002101          MLA      r1,r0,r1,r2           ;1473
000ab8  4622              MOV      r2,r4                 ;1476
000aba  4640              MOV      r0,r8                 ;1476
000abc  f7fffffe          BL       FLASH_Read
000ac0  4620              MOV      r0,r4                 ;1481
000ac2  21ff              MOVS     r1,#0xff              ;1482
000ac4  e004              B        |L1.2768|
000ac6  bf00              NOP                            ;1482
                  |L1.2760|
000ac8  f8081000          STRB     r1,[r8,r0]            ;1482
000acc  1c40              ADDS     r0,r0,#1              ;1482
000ace  b280              UXTH     r0,r0                 ;1481
                  |L1.2768|
000ad0  28ff              CMP      r0,#0xff              ;1481
000ad2  d9f9              BLS      |L1.2760|
000ad4  f8d50121          LDR      r0,[r5,#0x121]        ;1487
000ad8  f5007080          ADD      r0,r0,#0x100          ;1487
000adc  f8c50121          STR      r0,[r5,#0x121]        ;1487
000ae0  f8d50125          LDR      r0,[r5,#0x125]        ;1488
000ae4  4420              ADD      r0,r0,r4              ;1488
000ae6  f8c50125          STR      r0,[r5,#0x125]        ;1488
000aea  e7bc              B        |L1.2662|
;;;1493   
                          ENDP

                  FS_ReadPrevLn PROC
;;;1498   //-----------------------------------------------------------------------------
;;;1499   s8 FS_ReadPrevLn(tFile fcs_num, u8 *str, u32 max_size) {
000aec  2808              CMP      r0,#8
000aee  d302              BCC      |L1.2806|
;;;1500   
;;;1501   	// Проверить файловую переменную (ошибка -9)
;;;1502   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
;;;1503   		return -9;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
000af0  f06f0008          MVN      r0,#8
;;;1504   	}
;;;1505   
;;;1506   	return 0; // (фиктивный вовзврат)
;;;1507   }
000af4  e474              B        |L1.992|
                  |L1.2806|
000af6  2000              MOVS     r0,#0                 ;1506
000af8  e472              B        |L1.992|
;;;1508   
                          ENDP

                  FS_RemainSize PROC
;;;1512   //-----------------------------------------------------------------------------
;;;1513   s32 FS_RemainSize(tFile fcs_num) {
000afa  2808              CMP      r0,#8
000afc  d302              BCC      |L1.2820|
;;;1514   	tFCS *p_fcs;															// Указатель на FCS
;;;1515   
;;;1516   	// Проверить файловую переменную (ошибка -9)
;;;1517   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
;;;1518   		return -9;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
000afe  f06f0008          MVN      r0,#8
;;;1519   	}
;;;1520   
;;;1521   	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;1522   
;;;1523   	// Проверить состояние структуры FCS (ошибка -1)
;;;1524   	if (p_fcs->State != FCS_STATE_OPENED_READ) {							// Структура FCS открыта для чтения файла?
;;;1525   		return -1;															// НЕТ - Вернуть ошибку "Структура FCS не открыта для чтения файла" (ошибка -1)
;;;1526   	}
;;;1527   
;;;1528   	return p_fcs->RemainSize;												// Вернуть кол-во непрочитанных байт
;;;1529   }
000b02  e46d              B        |L1.992|
                  |L1.2820|
000b04  493e              LDR      r1,|L1.3072|
000b06  f8510020          LDR      r0,[r1,r0,LSL #2]     ;1521
000b0a  7801              LDRB     r1,[r0,#0]            ;1524
000b0c  2902              CMP      r1,#2                 ;1524
000b0e  d002              BEQ      |L1.2838|
000b10  f04f30ff          MOV      r0,#0xffffffff        ;1525
000b14  e464              B        |L1.992|
                  |L1.2838|
000b16  f8d0011d          LDR      r0,[r0,#0x11d]        ;1528
000b1a  e461              B        |L1.992|
;;;1530   
                          ENDP

                  FS_Seek PROC
;;;1535   // Выполняется "абсолютный" переход по файлу
;;;1536   s8 FS_Seek(tFile fcs_num, u32 position) {
000b1c  e92d47f0          PUSH     {r4-r10,lr}
000b20  460d              MOV      r5,r1
;;;1537   	tFCS *p_fcs;															// Указатель на FCS
;;;1538   	u16 clusters_num;
;;;1539   	u16 clust_num;
;;;1540   	u8  page_num;
;;;1541   	u8  old_page_ptr, new_page_ptr;
;;;1542   	u32 size;
;;;1543   	u32 addr;
;;;1544   	u16 i;
;;;1545   	u16 k;
;;;1546   
;;;1547   	// Проверить файловую переменную (ошибка -9)
;;;1548   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
000b22  2808              CMP      r0,#8
000b24  d302              BCC      |L1.2860|
;;;1549   		return EFS_INVALID_FSC;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
000b26  f06f0005          MVN      r0,#5
;;;1550   	}
;;;1551   
;;;1552   	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;1553   
;;;1554   	// Проверить состояние структуры FCS (ошибка -1)
;;;1555   	if (p_fcs->State != FCS_STATE_OPENED_READ) {							// Структура FCS открыта для чтения файла?
;;;1556   		return EFS_FCS_NOT_OPENED_READ;															// НЕТ - Вернуть ошибку "Структура FCS не открыта для чтения файла" (ошибка -1)
;;;1557   	}
;;;1558   
;;;1559   	// Проверить заданную позицию (ошибка -2)
;;;1560   	if (position > p_fcs->FNT.Size) {										// Позиция в пределах размера файла?
;;;1561   		return EFS_INVALID_POSITION;															// НЕТ - Вернуть ошибку "Заданная позиция не существует" (ошибка -2)
;;;1562   	}
;;;1563   
;;;1564   	// ДАЛЕЕ КОД АНАЛОГИЧЕН ФУНКЦИИ FS_RSeek()
;;;1565   
;;;1566   	page_num = position % CLUSTER_SIZE / PAGE_SIZE;							// Номер текущей страницы в текущем кластере
;;;1567   	new_page_ptr = position % PAGE_SIZE;									// Позиция в текущей странице
;;;1568   
;;;1569   	// Проверить меняется ли страница
;;;1570   	if (position >= p_fcs->MinFilePosition && position <= p_fcs->MaxFilePosition) {
;;;1571   		// Здесь страница не меняется - изменить только текущий указатель в буфере страницы и оставшийся размер
;;;1572   		old_page_ptr = p_fcs->PageBufPtr;
;;;1573   		p_fcs->PageBufPtr = new_page_ptr;
;;;1574   		p_fcs->RemainSize -= new_page_ptr - old_page_ptr;
;;;1575   		return FS_RESULT_OK;														// OK - Завершить
;;;1576   	}
;;;1577   
;;;1578   	// Здесь страница меняется
;;;1579   
;;;1580   	// Пройти по цепочке кластеров от первого до текущего кластера файла
;;;1581   	clusters_num = position / CLUSTER_SIZE;									// Порядковый номер текущего кластера в цепочке
;;;1582   	clust_num = p_fcs->FNT.FirstCluster;									// Индекс (в таблице CAT) первого кластер цепочки
;;;1583   	for (i = 0; i < clusters_num; i++) {									// Получить индекс (в таблице CAT) текущего кластера
;;;1584   		clust_num = FS_GetNextCluster(clust_num);
;;;1585   	}
;;;1586   
;;;1587   	// Изменить некоторые поля FCS
;;;1588   	p_fcs->CurrCluster = clust_num;											// Изменить номер текущего кластера
;;;1589   	p_fcs->CurrPage = page_num;												// Изменить номер текущей страницы в текущем кластере
;;;1590   	p_fcs->PageBufPtr = new_page_ptr;										// Изменить текущий указатель в буфере страницы
;;;1591   
;;;1592   	size = p_fcs->FNT.Size - position;										// Осталось не прочитано байт
;;;1593   	p_fcs->RemainSize = size;
;;;1594   
;;;1595   	// Вычислить количество байт в текущей странице
;;;1596   	size += new_page_ptr;													// Размер от начала текущей страницы до конца файла
;;;1597   	if (size >= PAGE_SIZE) {												// Размер больше чем страница?
;;;1598   		size = PAGE_SIZE;													// ДА - Уменьшить до размера страницы
;;;1599   	}
;;;1600   
;;;1601   	// Прочитать страницу в буфер FCS.Buffer[]
;;;1602   	addr = CLUSTERS_BASE_ADDRESS +											// Адрес страницы в флэш-памяти
;;;1603   	       clust_num * CLUSTER_SIZE +
;;;1604   		   page_num * PAGE_SIZE;
;;;1605   	FLASH_Read(p_fcs->PageBuffer, addr, size);								// Прочитать страницу
;;;1606   
;;;1607   //------
;;;1608   //<!> ДЛЯ ОТЛАДКИ !!!
;;;1609   //ОЧИСТИТЬ ОСТАТОК БУФЕРА СТРАНИЦЫ
;;;1610   for (k = size; k < PAGE_SIZE; k++) {
;;;1611   	p_fcs->PageBuffer[k] = 0xFF;
;;;1612   }
;;;1613   //------
;;;1614   
;;;1615   	p_fcs->MinFilePosition = (position / PAGE_SIZE) * PAGE_SIZE;			// Мин. позиция файла в текущей странице
;;;1616   	p_fcs->MaxFilePosition = p_fcs->MinFilePosition + size-1;				// Макс. позиция файла в текущей странице
;;;1617   
;;;1618   	return FS_RESULT_OK;																// OK - Завершить
;;;1619   }
000b2a  e60d              B        |L1.1864|
                  |L1.2860|
000b2c  4934              LDR      r1,|L1.3072|
000b2e  f8514020          LDR      r4,[r1,r0,LSL #2]     ;1552
000b32  7820              LDRB     r0,[r4,#0]            ;1555
000b34  2802              CMP      r0,#2                 ;1555
000b36  d002              BEQ      |L1.2878|
000b38  f06f000d          MVN      r0,#0xd               ;1556
000b3c  e604              B        |L1.1864|
                  |L1.2878|
000b3e  f8d4013f          LDR      r0,[r4,#0x13f]        ;1560
000b42  42a8              CMP      r0,r5                 ;1560
000b44  d202              BCS      |L1.2892|
000b46  f06f000f          MVN      r0,#0xf               ;1561
000b4a  e5fd              B        |L1.1864|
                  |L1.2892|
000b4c  492d              LDR      r1,|L1.3076|
000b4e  b2ef              UXTB     r7,r5                 ;1567
000b50  8988              LDRH     r0,[r1,#0xc]          ;1566  ; CLUSTER_SIZE
000b52  fbb5f2f0          UDIV     r2,r5,r0              ;1566
000b56  fb005212          MLS      r2,r0,r2,r5           ;1566
000b5a  f3c22807          UBFX     r8,r2,#8,#8           ;1566
000b5e  f8d42121          LDR      r2,[r4,#0x121]        ;1570
000b62  42aa              CMP      r2,r5                 ;1570
000b64  d80d              BHI      |L1.2946|
000b66  f8d42125          LDR      r2,[r4,#0x125]        ;1570
000b6a  42aa              CMP      r2,r5                 ;1570
000b6c  d309              BCC      |L1.2946|
000b6e  7ee0              LDRB     r0,[r4,#0x1b]         ;1572
000b70  f8a4701b          STRH     r7,[r4,#0x1b]         ;1573
000b74  f8d4111d          LDR      r1,[r4,#0x11d]        ;1574
000b78  1a38              SUBS     r0,r7,r0              ;1574
000b7a  1a08              SUBS     r0,r1,r0              ;1574
000b7c  f8c4011d          STR      r0,[r4,#0x11d]        ;1574
000b80  e03b              B        |L1.3066|
                  |L1.2946|
000b82  fbb5f0f0          UDIV     r0,r5,r0              ;1581
000b86  fa1ff980          UXTH     r9,r0                 ;1581
000b8a  468a              MOV      r10,r1                ;1581
000b8c  f8b4013d          LDRH     r0,[r4,#0x13d]        ;1582
000b90  2600              MOVS     r6,#0                 ;1583
000b92  e003              B        |L1.2972|
                  |L1.2964|
000b94  f7fffffe          BL       FS_GetNextCluster
000b98  1c76              ADDS     r6,r6,#1              ;1584
000b9a  b2b6              UXTH     r6,r6                 ;1583
                  |L1.2972|
000b9c  454e              CMP      r6,r9                 ;1583
000b9e  d3f9              BCC      |L1.2964|
000ba0  8320              STRH     r0,[r4,#0x18]         ;1588
000ba2  f884801a          STRB     r8,[r4,#0x1a]         ;1589
000ba6  f8a4701b          STRH     r7,[r4,#0x1b]         ;1590
000baa  f8d4113f          LDR      r1,[r4,#0x13f]        ;1592
000bae  1b49              SUBS     r1,r1,r5              ;1592
000bb0  19ce              ADDS     r6,r1,r7              ;1596
000bb2  f8c4111d          STR      r1,[r4,#0x11d]        ;1593
000bb6  2eff              CMP      r6,#0xff              ;1597
000bb8  d901              BLS      |L1.3006|
000bba  f44f7680          MOV      r6,#0x100             ;1598
                  |L1.3006|
000bbe  f8da3028          LDR      r3,[r10,#0x28]        ;1602  ; CLUSTERS_BASE_ADDRESS
000bc2  f8ba100c          LDRH     r1,[r10,#0xc]         ;1602  ; CLUSTER_SIZE
000bc6  eb032208          ADD      r2,r3,r8,LSL #8       ;1602
000bca  fb002101          MLA      r1,r0,r1,r2           ;1602
000bce  4632              MOV      r2,r6                 ;1605
000bd0  f104001d          ADD      r0,r4,#0x1d           ;1605
000bd4  f7fffffe          BL       FLASH_Read
000bd8  b2b0              UXTH     r0,r6                 ;1610
000bda  21ff              MOVS     r1,#0xff              ;1611
000bdc  e003              B        |L1.3046|
                  |L1.3038|
000bde  1822              ADDS     r2,r4,r0              ;1611
000be0  1c40              ADDS     r0,r0,#1              ;1611
000be2  7751              STRB     r1,[r2,#0x1d]         ;1611
000be4  b280              UXTH     r0,r0                 ;1610
                  |L1.3046|
000be6  28ff              CMP      r0,#0xff              ;1610
000be8  d9f9              BLS      |L1.3038|
000bea  f02500ff          BIC      r0,r5,#0xff           ;1615
000bee  f8c40121          STR      r0,[r4,#0x121]        ;1615
000bf2  1e76              SUBS     r6,r6,#1              ;1615
000bf4  4430              ADD      r0,r0,r6              ;1616
000bf6  f8c40125          STR      r0,[r4,#0x125]        ;1616
                  |L1.3066|
000bfa  2000              MOVS     r0,#0                 ;1618
000bfc  e5a4              B        |L1.1864|
000bfe  0000              DCW      0x0000
                  |L1.3072|
                          DCD      ||.bss||
                  |L1.3076|
                          DCD      ||.data||
                          ENDP

                  FS_RSeek PROC
;;;1627   // При смещении "вперед" если позиция не существует, встать в позицию Size
;;;1628   s8 FS_RSeek(tFile fcs_num, s32 disp) {
000c08  e92d5ff0          PUSH     {r4-r12,lr}
;;;1629   	tFCS *p_fcs;															// Указатель на FCS
;;;1630   	s32 position;
;;;1631   	u16 clusters_num;
;;;1632   	u16 clust_num;
;;;1633   	u8  page_num;
;;;1634   	u8  old_page_ptr, new_page_ptr;
;;;1635   	u32 size;
;;;1636   	u32 addr;
;;;1637   	u16 i;
;;;1638   	u16 k;
;;;1639   
;;;1640   	// Проверить файловую переменную (ошибка -9)
;;;1641   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
000c0c  2808              CMP      r0,#8
000c0e  d302              BCC      |L1.3094|
;;;1642   		return EFS_INVALID_FSC;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
000c10  f06f0005          MVN      r0,#5
;;;1643   	}
;;;1644   
;;;1645   	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;1646   
;;;1647   	// Проверить состояние структуры FCS (ошибка -1)
;;;1648   	if (p_fcs->State != FCS_STATE_OPENED_READ) {							// Структура FCS открыта для чтения файла?
;;;1649   		return EFS_FCS_NOT_OPENED_READ;															// НЕТ - Вернуть ошибку "Структура FCS не открыта для чтения файла" (ошибка -1)
;;;1650   	}
;;;1651   
;;;1652   	size = p_fcs->FNT.Size;													// Размер файла
;;;1653   
;;;1654   	position = size - p_fcs->RemainSize + disp;								// Получить новую позицию
;;;1655   	// здесь p_fcs->FNT.Size - p_fcs->RemainSize - текущая позиция
;;;1656   
;;;1657   	// Скорректировать позицию за пределами файла
;;;1658   	if (position < 0) {
;;;1659   		position = 0;
;;;1660   	}
;;;1661   	if (position > size) {
;;;1662   		position = size;
;;;1663   	}
;;;1664   
;;;1665   	// ДАЛЕЕ КОД АНАЛОГИЧЕН ФУНКЦИИ FS_Seek()
;;;1666   
;;;1667   	page_num = position % CLUSTER_SIZE / PAGE_SIZE;							// Номер текущей страницы в текущем кластере
;;;1668   	new_page_ptr = position % PAGE_SIZE;									// Позиция в текущей странице
;;;1669   
;;;1670   	// Проверить меняется ли страница
;;;1671   	if (position >= p_fcs->MinFilePosition && position <= p_fcs->MaxFilePosition) {
;;;1672   		// Здесь страница не меняется - изменить только текущий указатель в буфере страницы и оставшийся размер
;;;1673   		old_page_ptr = p_fcs->PageBufPtr;
;;;1674   		p_fcs->PageBufPtr = new_page_ptr;
;;;1675   		p_fcs->RemainSize -= new_page_ptr - old_page_ptr;
;;;1676   		return FS_RESULT_OK;														// OK - Завершить
;;;1677   	}
;;;1678   
;;;1679   	// Здесь страница меняется
;;;1680   
;;;1681   	// Пройти по цепочке кластеров от первого до текущего кластера файла
;;;1682   	clusters_num = position / CLUSTER_SIZE;									// Порядковый номер текущего кластера в цепочке
;;;1683   	clust_num = p_fcs->FNT.FirstCluster;									// Индекс (в таблице CAT) первого кластер цепочки
;;;1684   	for (i = 0; i < clusters_num; i++) {									// Получить индекс (в таблице CAT) текущего кластера
;;;1685   		clust_num = FS_GetNextCluster(clust_num);
;;;1686   	}
;;;1687   
;;;1688   	// Изменить некоторые поля FCS
;;;1689   	p_fcs->CurrCluster = clust_num;											// Изменить номер текущего кластера
;;;1690   	p_fcs->CurrPage = page_num;												// Изменить номер текущей страницы в текущем кластере
;;;1691   	p_fcs->PageBufPtr = new_page_ptr;										// Изменить текущий указатель в буфере страницы
;;;1692   
;;;1693   	size = p_fcs->FNT.Size - position;										// Осталось не прочитано байт
;;;1694   	p_fcs->RemainSize = size;
;;;1695   
;;;1696   	// Вычислить количество байт в текущей странице
;;;1697   	size += new_page_ptr;													// Размер от начала текущей страницы до конца файла
;;;1698   	if (size >= PAGE_SIZE) {												// Размер больше чем страница?
;;;1699   		size = PAGE_SIZE;													// ДА - Уменьшить до размера страницы
;;;1700   	}
;;;1701   
;;;1702   	// Прочитать страницу в буфер FCS.Buffer[]
;;;1703   	addr = CLUSTERS_BASE_ADDRESS +											// Адрес страницы в флэш-памяти
;;;1704   	       clust_num * CLUSTER_SIZE +
;;;1705   		   page_num * PAGE_SIZE;
;;;1706   	FLASH_Read(p_fcs->PageBuffer, addr, size);								// Прочитать страницу
;;;1707   
;;;1708   //------
;;;1709   //<!> ДЛЯ ОТЛАДКИ !!!
;;;1710   //ОЧИСТИТЬ ОСТАТОК БУФЕРА СТРАНИЦЫ
;;;1711   for (k = size; k < PAGE_SIZE; k++) {
;;;1712   	p_fcs->PageBuffer[k] = 0xFF;
;;;1713   }
;;;1714   //------
;;;1715   
;;;1716   	p_fcs->MinFilePosition = (position / PAGE_SIZE) * PAGE_SIZE;			// Мин. позиция файла в текущей странице
;;;1717   	p_fcs->MaxFilePosition = p_fcs->MinFilePosition + size-1;				// Макс. позиция файла в текущей странице
;;;1718   
;;;1719   	return FS_RESULT_OK;																// OK - Завершить
;;;1720   }
000c14  e477              B        |L1.1286|
                  |L1.3094|
000c16  4afe              LDR      r2,|L1.4112|
000c18  f8524020          LDR      r4,[r2,r0,LSL #2]     ;1645
000c1c  7820              LDRB     r0,[r4,#0]            ;1648
000c1e  2802              CMP      r0,#2                 ;1648
000c20  d002              BEQ      |L1.3112|
000c22  f06f000d          MVN      r0,#0xd               ;1649
000c26  e46e              B        |L1.1286|
                  |L1.3112|
000c28  f8d4013f          LDR      r0,[r4,#0x13f]        ;1652
000c2c  f8d4211d          LDR      r2,[r4,#0x11d]        ;1654
000c30  1a82              SUBS     r2,r0,r2              ;1654
000c32  1855              ADDS     r5,r2,r1              ;1654
000c34  d500              BPL      |L1.3128|
000c36  2500              MOVS     r5,#0                 ;1659
                  |L1.3128|
000c38  4285              CMP      r5,r0                 ;1661
000c3a  d900              BLS      |L1.3134|
000c3c  4605              MOV      r5,r0                 ;1662
                  |L1.3134|
000c3e  4af5              LDR      r2,|L1.4116|
000c40  8991              LDRH     r1,[r2,#0xc]          ;1667  ; CLUSTER_SIZE
000c42  fb95f0f1          SDIV     r0,r5,r1              ;1667
000c46  fb015010          MLS      r0,r1,r0,r5           ;1667
000c4a  17c3              ASRS     r3,r0,#31             ;1667
000c4c  eb006013          ADD      r0,r0,r3,LSR #24      ;1667
000c50  f3c02807          UBFX     r8,r0,#8,#8           ;1667
000c54  17e8              ASRS     r0,r5,#31             ;1668
000c56  eb056010          ADD      r0,r5,r0,LSR #24      ;1668
000c5a  f0200aff          BIC      r10,r0,#0xff          ;1668
000c5e  eba5000a          SUB      r0,r5,r10             ;1668
000c62  b2c7              UXTB     r7,r0                 ;1668
000c64  f8d40121          LDR      r0,[r4,#0x121]        ;1671
000c68  42a8              CMP      r0,r5                 ;1671
000c6a  d80d              BHI      |L1.3208|
000c6c  f8d40125          LDR      r0,[r4,#0x125]        ;1671
000c70  42a8              CMP      r0,r5                 ;1671
000c72  d309              BCC      |L1.3208|
000c74  7ee0              LDRB     r0,[r4,#0x1b]         ;1673
000c76  f8a4701b          STRH     r7,[r4,#0x1b]         ;1674
000c7a  f8d4111d          LDR      r1,[r4,#0x11d]        ;1675
000c7e  1a38              SUBS     r0,r7,r0              ;1675
000c80  1a08              SUBS     r0,r1,r0              ;1675
000c82  f8c4011d          STR      r0,[r4,#0x11d]        ;1675
000c86  e03b              B        |L1.3328|
                  |L1.3208|
000c88  fb95f0f1          SDIV     r0,r5,r1              ;1682
000c8c  fa1ff980          UXTH     r9,r0                 ;1682
000c90  4693              MOV      r11,r2                ;1682
000c92  f8b4013d          LDRH     r0,[r4,#0x13d]        ;1683
000c96  2600              MOVS     r6,#0                 ;1684
000c98  e004              B        |L1.3236|
000c9a  bf00              NOP                            ;1685
                  |L1.3228|
000c9c  f7fffffe          BL       FS_GetNextCluster
000ca0  1c76              ADDS     r6,r6,#1              ;1685
000ca2  b2b6              UXTH     r6,r6                 ;1684
                  |L1.3236|
000ca4  454e              CMP      r6,r9                 ;1684
000ca6  d3f9              BCC      |L1.3228|
000ca8  8320              STRH     r0,[r4,#0x18]         ;1689
000caa  f884801a          STRB     r8,[r4,#0x1a]         ;1690
000cae  f8a4701b          STRH     r7,[r4,#0x1b]         ;1691
000cb2  f8d4113f          LDR      r1,[r4,#0x13f]        ;1693
000cb6  1b49              SUBS     r1,r1,r5              ;1693
000cb8  19cd              ADDS     r5,r1,r7              ;1697
000cba  f8c4111d          STR      r1,[r4,#0x11d]        ;1694
000cbe  2dff              CMP      r5,#0xff              ;1698
000cc0  d901              BLS      |L1.3270|
000cc2  f44f7580          MOV      r5,#0x100             ;1699
                  |L1.3270|
000cc6  f8db3028          LDR      r3,[r11,#0x28]        ;1703  ; CLUSTERS_BASE_ADDRESS
000cca  f8bb100c          LDRH     r1,[r11,#0xc]         ;1703  ; CLUSTER_SIZE
000cce  eb032208          ADD      r2,r3,r8,LSL #8       ;1703
000cd2  fb002101          MLA      r1,r0,r1,r2           ;1703
000cd6  462a              MOV      r2,r5                 ;1706
000cd8  f104001d          ADD      r0,r4,#0x1d           ;1706
000cdc  f7fffffe          BL       FLASH_Read
000ce0  b2a8              UXTH     r0,r5                 ;1711
000ce2  21ff              MOVS     r1,#0xff              ;1712
000ce4  e003              B        |L1.3310|
                  |L1.3302|
000ce6  1822              ADDS     r2,r4,r0              ;1712
000ce8  1c40              ADDS     r0,r0,#1              ;1712
000cea  7751              STRB     r1,[r2,#0x1d]         ;1712
000cec  b280              UXTH     r0,r0                 ;1711
                  |L1.3310|
000cee  28ff              CMP      r0,#0xff              ;1711
000cf0  d9f9              BLS      |L1.3302|
000cf2  1e6d              SUBS     r5,r5,#1              ;1716
000cf4  f8c4a121          STR      r10,[r4,#0x121]       ;1716
000cf8  eb0a0005          ADD      r0,r10,r5             ;1717
000cfc  f8c40125          STR      r0,[r4,#0x125]        ;1717
                  |L1.3328|
000d00  2000              MOVS     r0,#0                 ;1719
000d02  e40a              B        |L1.1306|
;;;1721   
                          ENDP

                  FS_Close PROC
;;;1725   //-----------------------------------------------------------------------------
;;;1726   s8 FS_Close(tFile *fcs_num) {
000d04  e92d41f0          PUSH     {r4-r8,lr}
000d08  4605              MOV      r5,r0
;;;1727   	tFCS *p_fcs;															// Указатель на FCS
;;;1728   	u8 state;
;;;1729   	u32 flash_addr;
;;;1730   	u8 *addr;
;;;1731   	u8 size;
;;;1732   
;;;1733   	// Проверить файловую переменную (ошибка -9)
;;;1734   	if (*fcs_num < 0 || *fcs_num >= MAX_FILES) {							// Файловая переменная назначена файлу?
000d0a  f9900000          LDRSB    r0,[r0,#0]
000d0e  2808              CMP      r0,#8
000d10  d302              BCC      |L1.3352|
;;;1735   		return EFS_INVALID_FSC;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
000d12  f06f0005          MVN      r0,#5
;;;1736   	}
;;;1737   
;;;1738   	p_fcs = pFCSArray[*fcs_num];											// Получить указатель на FCS
;;;1739   
;;;1740   	// ПЕРЕД ЗАКРЫТИЕМ ФАЙЛА - ПРОВЕРИТЬ ВОЗМОЖНЫЕ ОШИБКИ
;;;1741   
;;;1742   	state = p_fcs->State;													// Взять состояние структуры FCS
;;;1743   
;;;1744   	// Проверить состояние структуры FCS (ошибка -1)
;;;1745   	if (state == FCS_STATE_CLOSED) {										// Структура FCS открыта?
;;;1746   		return EFS_FILE_IS_CLOSED;															// НЕТ - Вернуть ошибку "Структура FCS не открыта" (ошибка -1)
;;;1747   	}
;;;1748   
;;;1749   	// Структура FCS просто открыта или Файл открыт для чтения ?
;;;1750   	if (state == FCS_STATE_OPENED || state == FCS_STATE_OPENED_READ) {
;;;1751   		p_fcs->State = FCS_STATE_CLOSED;									// Пометить = "Структура FCS закрыта"
;;;1752   		*fcs_num = -1;														// Отвязать файловую переменную от структуры FCS
;;;1753   		return FS_RESULT_OK;															// ОК - Файл успешно закрыт
;;;1754   	}
;;;1755   
;;;1756   	// Файл открыт для записи ?
;;;1757   	if (state == FCS_STATE_OPENED_WRITE) {
;;;1758   		if (p_fcs->PageBufPtr) {											// Буфер страницы не пустой?
;;;1759   			FS_FlushPageBuffer(p_fcs, p_fcs->PageBufPtr);					// ДА - Записать буфер страницы в файл
;;;1760   		}
;;;1761   		// Переписать структуру FCS.FNT в запись FNT текущего файла
;;;1762   		flash_addr = FNT_BASE_ADDRESS +										// Адрес FNT текущего файла
;;;1763   		       p_fcs->FNT_num * FNT_RECORD_SIZE +							// (пропустить полное имя файла)
;;;1764   			   1 + FILE_NAME_LENGTH + FILE_TYPE_LENGTH + 1;
;;;1765   		addr = p_fcs->FNT.FullName +										// Указатель на структуру FCS.FNT
;;;1766   			   1 + FILE_NAME_LENGTH + FILE_TYPE_LENGTH + 1;					// (пропустить полное имя файла)
;;;1767   		size = sizeof(tFNT) -
;;;1768   		       1 - FILE_NAME_LENGTH - FILE_TYPE_LENGTH - 1;
;;;1769   		FLASH_Write(flash_addr, addr, size);								// Переписать полностью запись FNT
;;;1770   
;;;1771   		p_fcs->State = FCS_STATE_CLOSED;									// Пометить = "Структура FCS закрыта"
;;;1772   		*fcs_num = -1;														// Отвязать файловую переменную от структуры FCS
;;;1773   		return FS_RESULT_OK;															// ОК - Файл успешно закрыт
;;;1774   	}
;;;1775   	else {
;;;1776   		return EFS_UNKNOWN_FILE_STATE;															// Вернуть ошибку "Неизвестное состояние структуры FCS" (ошибка -2)
;;;1777   	}
;;;1778   }
000d16  e46f              B        |L1.1528|
                  |L1.3352|
000d18  49bd              LDR      r1,|L1.4112|
000d1a  f8514020          LDR      r4,[r1,r0,LSL #2]     ;1738
000d1e  7820              LDRB     r0,[r4,#0]            ;1742
000d20  b150              CBZ      r0,|L1.3384|
000d22  2600              MOVS     r6,#0                 ;1745
000d24  1e77              SUBS     r7,r6,#1              ;1752
000d26  2801              CMP      r0,#1                 ;1750
000d28  d009              BEQ      |L1.3390|
000d2a  2802              CMP      r0,#2                 ;1750
000d2c  d007              BEQ      |L1.3390|
000d2e  2803              CMP      r0,#3                 ;1757
000d30  d009              BEQ      |L1.3398|
000d32  f06f0011          MVN      r0,#0x11              ;1776
000d36  e45f              B        |L1.1528|
                  |L1.3384|
000d38  f06f0010          MVN      r0,#0x10              ;1746
000d3c  e45c              B        |L1.1528|
                  |L1.3390|
000d3e  7026              STRB     r6,[r4,#0]            ;1751
000d40  702f              STRB     r7,[r5,#0]            ;1752
000d42  2000              MOVS     r0,#0                 ;1753
000d44  e458              B        |L1.1528|
                  |L1.3398|
000d46  f8b4101b          LDRH     r1,[r4,#0x1b]         ;1758
000d4a  b111              CBZ      r1,|L1.3410|
000d4c  4620              MOV      r0,r4                 ;1759
000d4e  f7fffffe          BL       FS_FlushPageBuffer
                  |L1.3410|
000d52  6960              LDR      r0,[r4,#0x14]         ;1762
000d54  2133              MOVS     r1,#0x33              ;1762
000d56  eb011040          ADD      r0,r1,r0,LSL #5       ;1762
000d5a  f504719e          ADD      r1,r4,#0x13c          ;1765
000d5e  2207              MOVS     r2,#7                 ;1767
000d60  f7fffffe          BL       FLASH_Write
000d64  e7eb              B        |L1.3390|
;;;1779   
                          ENDP

                  FS_Delete PROC
;;;1783   //-----------------------------------------------------------------------------
;;;1784   s8 FS_Delete(const u8 *file_name) {
000d66  b530              PUSH     {r4,r5,lr}
;;;1785   	u8 name[FILE_NAME_LENGTH + 1];
;;;1786   	u8 type[FILE_TYPE_LENGTH + 1];
;;;1787   	u8 full_name[1 + FILE_NAME_LENGTH + FILE_TYPE_LENGTH + 1];
;;;1788   	u32 fnt_num;
;;;1789   	u32 fnt_addr;
;;;1790   	u32 addr;
;;;1791   	u16 clust_num;
;;;1792   
;;;1793   	// Проверить инициализацию файловой системы (ошибка -1)
;;;1794   	if (! FS_IS_INITED) {													// Файловая система инициализирована?
000d68  49aa              LDR      r1,|L1.4116|
000d6a  b08b              SUB      sp,sp,#0x2c           ;1784
000d6c  7849              LDRB     r1,[r1,#1]  ; FS_IS_INITED
000d6e  b171              CBZ      r1,|L1.3470|
;;;1795   		return EFS_FS_NOT_INITED;															// НЕТ - Вернуть ошибку "Файловая система не инициализирована" (ошибка -1)
;;;1796   	}
;;;1797   
;;;1798   	if (! FS_GetNameAndType(file_name, name, type)) {						// Выделение имени и типа выполнилось успешно?
000d70  aa0a              ADD      r2,sp,#0x28
000d72  4669              MOV      r1,sp
000d74  f7fffffe          BL       FS_GetNameAndType
000d78  b160              CBZ      r0,|L1.3476|
;;;1799   		return EFS_INVALID_FILE_NAME;															// НЕТ - Вернуть ошибку "Неверный формат имени файла" (ошибка -3)
;;;1800   	}
;;;1801   
;;;1802   	// Проверить использование файла с заданным именем
;;;1803   	if (FS_FileUseFCS(name, type) > -1) {									// Файл с заданным именем используется?
000d7a  a90a              ADD      r1,sp,#0x28
000d7c  4668              MOV      r0,sp
000d7e  f7fffffe          BL       FS_FileUseFCS
000d82  2800              CMP      r0,#0
000d84  db09              BLT      |L1.3482|
;;;1804   		return EFS_FILE_IS_USED;															// ДА - Вернуть ошибку "Файл с заданным именем используется" (ошибка -4)
000d86  f06f0003          MVN      r0,#3
                  |L1.3466|
;;;1805   	};
;;;1806   
;;;1807   	// Получить полное имя файла ( в форме: Signature1 + имя + тип + Signature2 )
;;;1808   	FS_GetFullName(name, type, full_name);
;;;1809   
;;;1810   	// Поиск запрошенного файла в таблице FNT
;;;1811   	fnt_num = FS_FindFileByName(full_name);									// Найти файл с заданным именем (включая сигнатуру)
;;;1812   	if (fnt_num == 0xFFFFFFFF) {											// Найден файл с заданным именем?
;;;1813   		return EFS_FILE_NOT_FOUND;															// НЕТ - Вернуть ошибку "Файл с заданным именем не найден" (ошибка -2)
;;;1814   	}
;;;1815   
;;;1816   	// ОШИБОК НЕТ - УДАЛИТЬ ФАЙЛ
;;;1817   
;;;1818   	fnt_addr = FNT_BASE_ADDRESS + fnt_num * FNT_RECORD_SIZE;				// Адрес FNT удаляемого файла
;;;1819   
;;;1820   	addr = fnt_addr + 1 + FILE_NAME_LENGTH + FILE_TYPE_LENGTH + 1 + 1;		// Адрес поля FNT.FirstCluster
;;;1821   	FLASH_Read((u8 *)&clust_num, addr, 2);									// Прочитать индекс (в таблице CAT) первого кластера файла
;;;1822   
;;;1823   	// УДАЛИТЬ КЛАСТЕРА в таблице CAT
;;;1824   	// Пройти по цепочке кластеров от первого до последнего кластера файла
;;;1825   	while (clust_num != 0xFFFF) {
;;;1826   		FS_ClusterSetFlag(clust_num, 0x00);									// Пометить кластер в таблице CAT = "Удалено"
;;;1827   		clust_num = FS_GetNextCluster(clust_num);							// Получить индекс (в таблице CAT) следующего кластера в цепочке
;;;1828   	}
;;;1829   
;;;1830   	// УДАЛИТЬ запись FNT
;;;1831   	FLASH_WriteByte(fnt_addr, 0x00);										// Пометить запись FNT = "Удалено" (Signature1 = 0x00)
;;;1832   
;;;1833   	return FS_RESULT_OK;																// ОК - Файл успешно удален
;;;1834   }
000d8a  b00b              ADD      sp,sp,#0x2c
000d8c  bd30              POP      {r4,r5,pc}
                  |L1.3470|
000d8e  f06f0001          MVN      r0,#1                 ;1795
000d92  e7fa              B        |L1.3466|
                  |L1.3476|
000d94  f06f0002          MVN      r0,#2                 ;1799
000d98  e7f7              B        |L1.3466|
                  |L1.3482|
000d9a  aa04              ADD      r2,sp,#0x10           ;1808
000d9c  a90a              ADD      r1,sp,#0x28           ;1808
000d9e  4668              MOV      r0,sp                 ;1808
000da0  f7fffffe          BL       FS_GetFullName
000da4  a804              ADD      r0,sp,#0x10           ;1811
000da6  f7fffffe          BL       FS_FindFileByName
000daa  1c41              ADDS     r1,r0,#1              ;1812
000dac  d00b              BEQ      |L1.3526|
000dae  2120              MOVS     r1,#0x20              ;1818
000db0  eb011440          ADD      r4,r1,r0,LSL #5       ;1818
000db4  f1040114          ADD      r1,r4,#0x14           ;1820
000db8  2202              MOVS     r2,#2                 ;1821
000dba  a809              ADD      r0,sp,#0x24           ;1821
000dbc  f7fffffe          BL       FLASH_Read
000dc0  f64f75ff          MOV      r5,#0xffff            ;1825
000dc4  e00a              B        |L1.3548|
                  |L1.3526|
000dc6  f06f000a          MVN      r0,#0xa               ;1813
000dca  e7de              B        |L1.3466|
                  |L1.3532|
000dcc  f7fffffe          BL       FS_ClusterSetFlag
000dd0  f8bd0024          LDRH     r0,[sp,#0x24]         ;1827
000dd4  f7fffffe          BL       FS_GetNextCluster
000dd8  f8ad0024          STRH     r0,[sp,#0x24]         ;1827
                  |L1.3548|
000ddc  f8bd0024          LDRH     r0,[sp,#0x24]         ;1825
000de0  f04f0100          MOV      r1,#0                 ;1831
000de4  42a8              CMP      r0,r5                 ;1825
000de6  d1f1              BNE      |L1.3532|
000de8  4620              MOV      r0,r4                 ;1831
000dea  f7fffffe          BL       FLASH_WriteByte
000dee  2000              MOVS     r0,#0                 ;1833
000df0  e7cb              B        |L1.3466|
;;;1835   
                          ENDP

                  FS_GetFileInfo PROC
;;;1840   // Если очередной файл не найден - возвращается 0xFFFFFFFF
;;;1841   s8 FS_GetFileInfo(u32 * fnt_num, u8 *name, u8 *type, u8 *attr, u32 *size, tFile *f) {
000df2  e92d4ff0          PUSH     {r4-r11,lr}
000df6  b089              SUB      sp,sp,#0x24
000df8  4604              MOV      r4,r0
000dfa  e9dd8912          LDRD     r8,r9,[sp,#0x48]
000dfe  460e              MOV      r6,r1
;;;1842   	tFCS *p_fcs;															// Указатель на FCS
;;;1843   	u32 addr;
;;;1844   	__packed union {
;;;1845   		u8 array[FNT_RECORD_SIZE];											// Представление fnt как массива
;;;1846   		tFNT strc;															// Представление fnt как структуры
;;;1847   	} fnt;
;;;1848   	u8 b;
;;;1849   	u8 i,k;
;;;1850   
;;;1851   	// Искать по всем записям от стартовой записи до конца таблицы FNT
;;;1852   	addr = FNT_BASE_ADDRESS + *fnt_num * FNT_RECORD_SIZE;					// Адрес стартовой записи FNT
000e00  6800              LDR      r0,[r0,#0]
000e02  2120              MOVS     r1,#0x20
000e04  eb011040          ADD      r0,r1,r0,LSL #5
000e08  461f              MOV      r7,r3                 ;1841
000e0a  4615              MOV      r5,r2                 ;1841
;;;1853   	while (*fnt_num < FNTRecordsNumber) {
000e0c  f8dfb204          LDR      r11,|L1.4116|
000e10  f04f0a00          MOV      r10,#0
000e14  9000              STR      r0,[sp,#0]            ;1841
000e16  e00b              B        |L1.3632|
                  |L1.3608|
;;;1854   		b = FLASH_ReadByte(addr);											// Прочитать Сигнатуру1
000e18  9800              LDR      r0,[sp,#0]
000e1a  f7fffffe          BL       FLASH_ReadByte
;;;1855   		if (b == 0xFF) {													// Найдена свободная запись FNT?
000e1e  28ff              CMP      r0,#0xff
000e20  d010              BEQ      |L1.3652|
;;;1856   			name[0] = 0;													// ДА - Прекратить поиск файла
;;;1857   			type[0] = 0;													//   и вернуть "пустую" информацию
;;;1858   			*attr = 0xFF;
;;;1859   			*size = 0;
;;;1860   			*f = -1;
;;;1861   			*fnt_num = 0xFFFFFFFF;
;;;1862   			return EFS_FILE_INFO_NOT_FOUND;									// Завершить с результатом "Очередной файл не найден"
;;;1863   		}
;;;1864   		if (b > 0x00) {														// Файл найден?
000e22  b950              CBNZ     r0,|L1.3642|
;;;1865   			break;															// ДА - Прервать поиск файла
;;;1866   		}
;;;1867   		addr += FNT_RECORD_SIZE;											// Адрес следующей записи FNT
000e24  9800              LDR      r0,[sp,#0]
000e26  3020              ADDS     r0,r0,#0x20
;;;1868   		(*fnt_num)++;															// Номер следующей записи FNT
000e28  9000              STR      r0,[sp,#0]
000e2a  6820              LDR      r0,[r4,#0]
000e2c  1c40              ADDS     r0,r0,#1
000e2e  6020              STR      r0,[r4,#0]
                  |L1.3632|
000e30  6821              LDR      r1,[r4,#0]            ;1853
000e32  f8db001c          LDR      r0,[r11,#0x1c]        ;1853  ; FNTRecordsNumber
000e36  4281              CMP      r1,r0                 ;1853
000e38  d3ee              BCC      |L1.3608|
                  |L1.3642|
;;;1869   	}
;;;1870   
;;;1871   	if ((*fnt_num) >= FNTRecordsNumber) {										// Файл найден?
000e3a  6821              LDR      r1,[r4,#0]
000e3c  f8db001c          LDR      r0,[r11,#0x1c]  ; FNTRecordsNumber
000e40  4281              CMP      r1,r0
000e42  d311              BCC      |L1.3688|
                  |L1.3652|
;;;1872   			name[0] = 0;													// НЕТ - Вернуть "пустую" информацию
000e44  f886a000          STRB     r10,[r6,#0]
;;;1873   			type[0] = 0;
000e48  f885a000          STRB     r10,[r5,#0]
;;;1874   			*attr = 0xFF;
000e4c  21ff              MOVS     r1,#0xff
000e4e  7039              STRB     r1,[r7,#0]
;;;1875   			*size = 0;
;;;1876   			*f = -1;
000e50  f04f30ff          MOV      r0,#0xffffffff
000e54  f8c8a000          STR      r10,[r8,#0]
000e58  f8890000          STRB     r0,[r9,#0]
;;;1877   			(*fnt_num) = 0xFFFFFFFF;
;;;1878   			return EFS_FILE_INFO_NOT_FOUND;									// Завершить с результатом "Очередной файл не найден"
000e5c  6020              STR      r0,[r4,#0]
000e5e  f06f0012          MVN      r0,#0x12
                  |L1.3682|
;;;1879   	}
;;;1880   
;;;1881   	// ОЧЕРЕДНОЙ ФАЙЛ НАЙДЕН
;;;1882   	
;;;1883   	// Копировать запись FNT найденного файла
;;;1884   	FLASH_Read(fnt.array, addr, sizeof(tFNT));								// Прочитать запись FNT
;;;1885   
;;;1886   	// Прочитать имя файла
;;;1887   	for (i = 0, k = 1; i < FILE_NAME_LENGTH; i++, k++) {
;;;1888   		b = fnt.strc.FullName[k];
;;;1889   		name[i] = b;
;;;1890   		if (! b) {
;;;1891   			break;
;;;1892   		}
;;;1893   	}
;;;1894   	if (i == FILE_NAME_LENGTH) {
;;;1895   		name[FILE_NAME_LENGTH] = 0;
;;;1896   	}
;;;1897   
;;;1898   	// Прочитать тип файла
;;;1899   	for (i = 0, k = 1 + FILE_NAME_LENGTH; i < FILE_TYPE_LENGTH; i++, k++) {
;;;1900   		b = fnt.strc.FullName[k];
;;;1901   		type[i] = b;
;;;1902   		if (! b) {
;;;1903   			break;
;;;1904   		}
;;;1905   	}
;;;1906   	if (i == FILE_TYPE_LENGTH) {
;;;1907   		type[FILE_TYPE_LENGTH] = 0;
;;;1908   	}
;;;1909   
;;;1910   	*f = FS_FileUseFCS(name, type);											// Проверить использование файла с заданным именем
;;;1911   
;;;1912   	// Найденный файл используется
;;;1913   	if (*f > -1) {															// Файл с заданным именем используется?
;;;1914   		// Взять информацию о файле из соответствующей структуры FCS
;;;1915   		p_fcs = pFCSArray[*f];												// Получить указатель на FCS
;;;1916   		*attr = p_fcs->FNT.Attribute;
;;;1917   		*size = p_fcs->FNT.Size;
;;;1918   	}
;;;1919   	// Найденный файл не используется
;;;1920   	else {
;;;1921   		// Взять информацию о файле из записи FNT
;;;1922   		*attr = fnt.strc.Attribute;
;;;1923   		*size = fnt.strc.Size;
;;;1924   	}
;;;1925   
;;;1926   	return FS_RESULT_OK;															// ОК - Информация о файле успешно получена
;;;1927   }
000e62  b009              ADD      sp,sp,#0x24
000e64  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.3688|
000e68  221a              MOVS     r2,#0x1a              ;1884
000e6a  a801              ADD      r0,sp,#4              ;1884
000e6c  9900              LDR      r1,[sp,#0]            ;1884
000e6e  f7fffffe          BL       FLASH_Read
000e72  2000              MOVS     r0,#0                 ;1887
000e74  2101              MOVS     r1,#1                 ;1887
000e76  aa01              ADD      r2,sp,#4              ;1847
                  |L1.3704|
000e78  5c53              LDRB     r3,[r2,r1]            ;1888
000e7a  5433              STRB     r3,[r6,r0]            ;1889
000e7c  b12b              CBZ      r3,|L1.3722|
000e7e  1c40              ADDS     r0,r0,#1              ;1890
000e80  1c49              ADDS     r1,r1,#1              ;1887
000e82  b2c0              UXTB     r0,r0                 ;1887
000e84  b2c9              UXTB     r1,r1                 ;1887
000e86  280e              CMP      r0,#0xe               ;1887
000e88  d3f6              BCC      |L1.3704|
                  |L1.3722|
000e8a  280e              CMP      r0,#0xe               ;1894
000e8c  d101              BNE      |L1.3730|
000e8e  f886a00e          STRB     r10,[r6,#0xe]         ;1895
                  |L1.3730|
000e92  2000              MOVS     r0,#0                 ;1899
000e94  210f              MOVS     r1,#0xf               ;1899
                  |L1.3734|
000e96  5c53              LDRB     r3,[r2,r1]            ;1900
000e98  542b              STRB     r3,[r5,r0]            ;1901
000e9a  b12b              CBZ      r3,|L1.3752|
000e9c  1c40              ADDS     r0,r0,#1              ;1902
000e9e  1c49              ADDS     r1,r1,#1              ;1899
000ea0  b2c0              UXTB     r0,r0                 ;1899
000ea2  b2c9              UXTB     r1,r1                 ;1899
000ea4  2803              CMP      r0,#3                 ;1899
000ea6  d3f6              BCC      |L1.3734|
                  |L1.3752|
000ea8  2803              CMP      r0,#3                 ;1906
000eaa  d101              BNE      |L1.3760|
000eac  f885a003          STRB     r10,[r5,#3]           ;1907
                  |L1.3760|
000eb0  4629              MOV      r1,r5                 ;1910
000eb2  4630              MOV      r0,r6                 ;1910
000eb4  f7fffffe          BL       FS_FileUseFCS
000eb8  f8890000          STRB     r0,[r9,#0]            ;1910
000ebc  2800              CMP      r0,#0                 ;1913
000ebe  db08              BLT      |L1.3794|
000ec0  4953              LDR      r1,|L1.4112|
000ec2  f8510020          LDR      r0,[r1,r0,LSL #2]     ;1915
000ec6  f890113c          LDRB     r1,[r0,#0x13c]        ;1916
000eca  7039              STRB     r1,[r7,#0]            ;1916
000ecc  f8d0113f          LDR      r1,[r0,#0x13f]        ;1917
000ed0  e004              B        |L1.3804|
                  |L1.3794|
000ed2  f89d0017          LDRB     r0,[sp,#0x17]         ;1922
000ed6  7038              STRB     r0,[r7,#0]            ;1922
000ed8  f8dd101a          LDR      r1,[sp,#0x1a]         ;1923
                  |L1.3804|
000edc  2000              MOVS     r0,#0                 ;1926
000ede  f8c81000          STR      r1,[r8,#0]            ;1926
000ee2  e7be              B        |L1.3682|
;;;1928   
                          ENDP

                  FS_Eof PROC
;;;1932   //-----------------------------------------------------------------------------
;;;1933   s8 FS_Eof(tFile fcs_num) {
000ee4  2808              CMP      r0,#8
000ee6  d302              BCC      |L1.3822|
;;;1934   	tFCS *p_fcs;															// Указатель на FCS
;;;1935   
;;;1936   	// Проверить файловую переменную (ошибка -9)
;;;1937   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
;;;1938   		return EFS_INVALID_FSC;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
000ee8  f06f0005          MVN      r0,#5
;;;1939   	}
;;;1940   
;;;1941   	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;1942   
;;;1943   	// Проверить состояние структуры FCS (ошибка -1)
;;;1944   	if (p_fcs->State != FCS_STATE_OPENED_READ) {							// Структура FCS открыта для чтения файла?
;;;1945   		return EFS_FCS_NOT_OPENED_READ;															// НЕТ - Вернуть ошибку "Структура FCS не открыта для чтения файла" (ошибка -1)
;;;1946   	}
;;;1947   
;;;1948   	// Проверить кол-во непрочитанных байт и вернуть результат
;;;1949   	if (p_fcs->RemainSize) {
;;;1950   		return FS_NOT_EOF;
;;;1951   	}
;;;1952   	else {
;;;1953   		return FS_EOF;
;;;1954   	}
;;;1955   }
000eec  e566              B        |L1.2492|
                  |L1.3822|
000eee  4948              LDR      r1,|L1.4112|
000ef0  f8510020          LDR      r0,[r1,r0,LSL #2]     ;1941
000ef4  7801              LDRB     r1,[r0,#0]            ;1944
000ef6  2902              CMP      r1,#2                 ;1944
000ef8  d002              BEQ      |L1.3840|
000efa  f06f000d          MVN      r0,#0xd               ;1945
000efe  e55d              B        |L1.2492|
                  |L1.3840|
000f00  f8d0011d          LDR      r0,[r0,#0x11d]        ;1949
000f04  b110              CBZ      r0,|L1.3852|
000f06  f06f0013          MVN      r0,#0x13              ;1950
000f0a  e557              B        |L1.2492|
                  |L1.3852|
000f0c  f06f0014          MVN      r0,#0x14              ;1953
000f10  e554              B        |L1.2492|
;;;1956   
                          ENDP

                  FS_Pos PROC
;;;1960   //-----------------------------------------------------------------------------
;;;1961   s8 FS_Pos(tFile fcs_num,s32 * pos) {
000f12  2808              CMP      r0,#8
000f14  d302              BCC      |L1.3868|
;;;1962   	tFCS *p_fcs;															// Указатель на FCS
;;;1963   
;;;1964   	// Проверить файловую переменную (ошибка -9)
;;;1965   	if (fcs_num < 0 || fcs_num >= MAX_FILES) {								// Файловая переменная назначена файлу?
;;;1966   		return EFS_INVALID_FSC;															// НЕТ - Вернуть ошибку "Файловая переменная не назначена файлу" (ошибка -9)
000f16  f06f0005          MVN      r0,#5
;;;1967   	}
;;;1968   
;;;1969   	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
;;;1970   
;;;1971   	// Проверить состояние структуры FCS (ошибка -1)
;;;1972   	if (p_fcs->State != FCS_STATE_OPENED_READ) {							// Структура FCS открыта для чтения файла?
;;;1973   		return EFS_FCS_NOT_OPENED_READ;															// НЕТ - Вернуть ошибку "Структура FCS не открыта для чтения файла" (ошибка -1)
;;;1974   	}
;;;1975   
;;;1976   	// Взять кол-во непрочитанных байт и вернуть результат
;;;1977   	*pos = (p_fcs->FNT.Size - p_fcs->RemainSize);
;;;1978   	return FS_RESULT_OK;
;;;1979   }
000f1a  e54f              B        |L1.2492|
                  |L1.3868|
000f1c  4a3c              LDR      r2,|L1.4112|
000f1e  f8520020          LDR      r0,[r2,r0,LSL #2]     ;1969
000f22  7802              LDRB     r2,[r0,#0]            ;1972
000f24  2a02              CMP      r2,#2                 ;1972
000f26  d002              BEQ      |L1.3886|
000f28  f06f000d          MVN      r0,#0xd               ;1973
000f2c  e546              B        |L1.2492|
                  |L1.3886|
000f2e  f8d0213f          LDR      r2,[r0,#0x13f]        ;1977
000f32  f8d0011d          LDR      r0,[r0,#0x11d]        ;1977
000f36  1a10              SUBS     r0,r2,r0              ;1977
000f38  6008              STR      r0,[r1,#0]            ;1978
000f3a  2000              MOVS     r0,#0                 ;1978
000f3c  e53e              B        |L1.2492|
;;;1980   
                          ENDP

                  FS_GetFCSState PROC
;;;1997   // получить состояние структуры FCS
;;;1998   u8 FS_GetFCSState(u8 fcs_num) {
000f3e  4934              LDR      r1,|L1.4112|
;;;1999   
;;;2000   	return pFCSArray[fcs_num]->State;
000f40  f8510020          LDR      r0,[r1,r0,LSL #2]
000f44  7800              LDRB     r0,[r0,#0]
;;;2001   }
000f46  e539              B        |L1.2492|
;;;2002   
                          ENDP

                  FS_FCS_Show PROC
;;;2004   // отобразить структуру FCS
;;;2005   void FS_FCS_Show( u8 fcs_num, void page_buf_view(u8 *buffer, u32 addr) ) {
000f48  e92d41f0          PUSH     {r4-r8,lr}
000f4c  4607              MOV      r7,r0
;;;2006   	tFCS *p_fcs;															// Указатель на FCS
;;;2007   	u8 *name_buf;
;;;2008   	char ch;
;;;2009   	u8 i;
;;;2010   
;;;2011   	p_fcs = pFCSArray[fcs_num];												// Получить указатель на FCS
000f4e  4830              LDR      r0,|L1.4112|
000f50  460d              MOV      r5,r1                 ;2005
;;;2012   
;;;2013   	Msg(" - FCS %d:\r\n", fcs_num);
000f52  4639              MOV      r1,r7
000f54  f8504027          LDR      r4,[r0,r7,LSL #2]     ;2011
000f58  a02f              ADR      r0,|L1.4120|
000f5a  f7fffffe          BL       Msg
;;;2014   	Msg("   -------------------------\r\n", fcs_num);
000f5e  4639              MOV      r1,r7
000f60  a031              ADR      r0,|L1.4136|
000f62  f7fffffe          BL       Msg
;;;2015   	SMsg();
000f66  f7fffffe          BL       SMsg
;;;2016   	Msg("   State: %d", p_fcs->State);
000f6a  7821              LDRB     r1,[r4,#0]
000f6c  a036              ADR      r0,|L1.4168|
000f6e  f7fffffe          BL       Msg
;;;2017   	SMsg();
000f72  f7fffffe          BL       SMsg
;;;2018   	switch (p_fcs->State) {
000f76  7820              LDRB     r0,[r4,#0]
000f78  b130              CBZ      r0,|L1.3976|
000f7a  2801              CMP      r0,#1
000f7c  d006              BEQ      |L1.3980|
000f7e  2802              CMP      r0,#2
000f80  d044              BEQ      |L1.4108|
000f82  2803              CMP      r0,#3
000f84  d107              BNE      |L1.3990|
000f86  e136              B        |L1.4598|
                  |L1.3976|
;;;2019   		case FCS_STATE_CLOSED: {
;;;2020   			Msg(" (FCS_STATE_CLOSED)\r\n");
000f88  a033              ADR      r0,|L1.4184|
;;;2021   			SMsg();
;;;2022   			break;
000f8a  e000              B        |L1.3982|
                  |L1.3980|
;;;2023   		}
;;;2024   		case FCS_STATE_OPENED: {
;;;2025   			Msg(" (FCS_STATE_OPENED)\r\n");
000f8c  a038              ADR      r0,|L1.4208|
                  |L1.3982|
000f8e  f7fffffe          BL       Msg
000f92  f7fffffe          BL       SMsg
                  |L1.3990|
;;;2026   			SMsg();
;;;2027   			break;
;;;2028   		}
;;;2029   		case FCS_STATE_OPENED_READ: {
;;;2030   			Msg(" (FCS_STATE_OPENED_READ)\r\n");
;;;2031   			SMsg();
;;;2032   			break;
;;;2033   		}
;;;2034   		case FCS_STATE_OPENED_WRITE: {
;;;2035   			Msg(" (FCS_STATE_OPENED_WRITE)\r\n");
;;;2036   			SMsg();
;;;2037   			break;
;;;2038   		}
;;;2039   	}
;;;2040   	Msg("   Name: \"%s\"\r\n", p_fcs->Name);
000f96  1c61              ADDS     r1,r4,#1
000f98  a03b              ADR      r0,|L1.4232|
000f9a  f7fffffe          BL       Msg
;;;2041   	SMsg();
000f9e  f7fffffe          BL       SMsg
;;;2042   	Msg("   Type: \"%s\"\r\n", p_fcs->Type);
000fa2  f1040110          ADD      r1,r4,#0x10
000fa6  a03c              ADR      r0,|L1.4248|
000fa8  f7fffffe          BL       Msg
;;;2043   	SMsg();
000fac  f7fffffe          BL       SMsg
;;;2044   	Msg("   FNT_num: %d\r\n", p_fcs->FNT_num);
000fb0  6961              LDR      r1,[r4,#0x14]
000fb2  a03d              ADR      r0,|L1.4264|
000fb4  f7fffffe          BL       Msg
;;;2045   	SMsg();
000fb8  f7fffffe          BL       SMsg
;;;2046   	Msg("   CurrCluster: %d\r\n", p_fcs->CurrCluster);
000fbc  8b21              LDRH     r1,[r4,#0x18]
000fbe  a03f              ADR      r0,|L1.4284|
000fc0  f7fffffe          BL       Msg
;;;2047   	Msg("   CurrPage: %d\r\n", p_fcs->CurrPage);
000fc4  7ea1              LDRB     r1,[r4,#0x1a]
000fc6  a043              ADR      r0,|L1.4308|
000fc8  f7fffffe          BL       Msg
;;;2048   	SMsg();
000fcc  f7fffffe          BL       SMsg
;;;2049   	Msg("   PageBufPtr: %d\r\n", p_fcs->PageBufPtr);
000fd0  f8b4101b          LDRH     r1,[r4,#0x1b]
000fd4  a044              ADR      r0,|L1.4328|
000fd6  f7fffffe          BL       Msg
;;;2050   	Msg("   RemainSize: %d\r\n", p_fcs->RemainSize);
000fda  f8d4111d          LDR      r1,[r4,#0x11d]
000fde  a047              ADR      r0,|L1.4348|
000fe0  f7fffffe          BL       Msg
;;;2051   	SMsg();
000fe4  f7fffffe          BL       SMsg
;;;2052   	Msg("   MinFilePosition: %d\r\n", p_fcs->MinFilePosition);
000fe8  f8d41121          LDR      r1,[r4,#0x121]
000fec  a048              ADR      r0,|L1.4368|
000fee  f7fffffe          BL       Msg
;;;2053   	SMsg();
000ff2  f7fffffe          BL       SMsg
;;;2054   	Msg("   MaxFilePosition: %d\r\n", p_fcs->MaxFilePosition);
000ff6  f8d41125          LDR      r1,[r4,#0x125]
000ffa  a04c              ADR      r0,|L1.4396|
000ffc  f7fffffe          BL       Msg
;;;2055   	SMsg();
001000  f7fffffe          BL       SMsg
;;;2056   	Msg("   PAGE_BUFFER:\r\n");
001004  a050              ADR      r0,|L1.4424|
001006  f7fffffe          BL       Msg
;;;2057   	page_buf_view(p_fcs->PageBuffer, 0);
00100a  e0a7              B        |L1.4444|
                  |L1.4108|
00100c  e0f1              B        |L1.4594|
00100e  0000              DCW      0x0000
                  |L1.4112|
                          DCD      ||.bss||
                  |L1.4116|
                          DCD      ||.data||
                  |L1.4120|
001018  202d2046          DCB      " - FCS %d:\r\n",0
00101c  43532025
001020  643a0d0a
001024  00      
001025  00                DCB      0
001026  00                DCB      0
001027  00                DCB      0
                  |L1.4136|
001028  2020202d          DCB      "   -------------------------"
00102c  2d2d2d2d
001030  2d2d2d2d
001034  2d2d2d2d
001038  2d2d2d2d
00103c  2d2d2d2d
001040  2d2d2d2d
                  |L1.4164|
001044  0d0a00            DCB      "\r\n",0
001047  00                DCB      0
                  |L1.4168|
001048  20202053          DCB      "   State: %d",0
00104c  74617465
001050  3a202564
001054  00      
001055  00                DCB      0
001056  00                DCB      0
001057  00                DCB      0
                  |L1.4184|
001058  20284643          DCB      " (FCS_STATE_CLOSED)\r\n",0
00105c  535f5354
001060  4154455f
001064  434c4f53
001068  4544290d
00106c  0a00    
00106e  00                DCB      0
00106f  00                DCB      0
                  |L1.4208|
001070  20284643          DCB      " (FCS_STATE_OPENED)\r\n",0
001074  535f5354
001078  4154455f
00107c  4f50454e
001080  4544290d
001084  0a00    
001086  00                DCB      0
001087  00                DCB      0
                  |L1.4232|
001088  2020204e          DCB      "   Name: ""%s""\r\n",0
00108c  616d653a
001090  20222573
001094  220d0a00
                  |L1.4248|
001098  20202054          DCB      "   Type: ""%s""\r\n",0
00109c  7970653a
0010a0  20222573
0010a4  220d0a00
                  |L1.4264|
0010a8  20202046          DCB      "   FNT_num: %d\r\n",0
0010ac  4e545f6e
0010b0  756d3a20
0010b4  25640d0a
0010b8  00      
0010b9  00                DCB      0
0010ba  00                DCB      0
0010bb  00                DCB      0
                  |L1.4284|
0010bc  20202043          DCB      "   CurrCluster: %d\r\n",0
0010c0  75727243
0010c4  6c757374
0010c8  65723a20
0010cc  25640d0a
0010d0  00      
0010d1  00                DCB      0
0010d2  00                DCB      0
0010d3  00                DCB      0
                  |L1.4308|
0010d4  20202043          DCB      "   CurrPage: %d\r\n",0
0010d8  75727250
0010dc  6167653a
0010e0  2025640d
0010e4  0a00    
0010e6  00                DCB      0
0010e7  00                DCB      0
                  |L1.4328|
0010e8  20202050          DCB      "   PageBufPtr: %d\r\n",0
0010ec  61676542
0010f0  75665074
0010f4  723a2025
0010f8  640d0a00
                  |L1.4348|
0010fc  20202052          DCB      "   RemainSize: %d\r\n",0
001100  656d6169
001104  6e53697a
001108  653a2025
00110c  640d0a00
                  |L1.4368|
001110  2020204d          DCB      "   MinFilePosition: %d\r\n",0
001114  696e4669
001118  6c65506f
00111c  73697469
001120  6f6e3a20
001124  25640d0a
001128  00      
001129  00                DCB      0
00112a  00                DCB      0
00112b  00                DCB      0
                  |L1.4396|
00112c  2020204d          DCB      "   MaxFilePosition: %d\r\n",0
001130  61784669
001134  6c65506f
001138  73697469
00113c  6f6e3a20
001140  25640d0a
001144  00      
001145  00                DCB      0
001146  00                DCB      0
001147  00                DCB      0
                  |L1.4424|
001148  20202050          DCB      "   PAGE_BUFFER:\r\n",0
00114c  4147455f
001150  42554646
001154  45523a0d
001158  0a00    
00115a  00                DCB      0
00115b  00                DCB      0
                  |L1.4444|
00115c  2100              MOVS     r1,#0
00115e  f104001d          ADD      r0,r4,#0x1d
001162  47a8              BLX      r5
;;;2058   	SMsg();
001164  f7fffffe          BL       SMsg
;;;2059   	Msg("   FNT:\r\n");
001168  a072              ADR      r0,|L1.4916|
00116a  f7fffffe          BL       Msg
;;;2060   	Msg("   FNT.FullName: ");
00116e  a074              ADR      r0,|L1.4928|
001170  f7fffffe          BL       Msg
;;;2061   	name_buf = p_fcs->FNT.FullName;
001174  f2041629          ADD      r6,r4,#0x129
;;;2062   	for (i=0; i < 1 + FILE_NAME_LENGTH + FILE_TYPE_LENGTH + 1; i++) {
001178  2500              MOVS     r5,#0
                  |L1.4474|
;;;2063   		Msg(" %02X", name_buf[i]);
00117a  a076              ADR      r0,|L1.4948|
00117c  5d71              LDRB     r1,[r6,r5]
00117e  f7fffffe          BL       Msg
001182  1c6d              ADDS     r5,r5,#1
001184  b2ed              UXTB     r5,r5                 ;2062
001186  2d13              CMP      r5,#0x13              ;2062
001188  d3f7              BCC      |L1.4474|
;;;2064   	}
;;;2065   	SMsg();
00118a  f7fffffe          BL       SMsg
;;;2066   	Msg(" | ");
00118e  a073              ADR      r0,|L1.4956|
001190  f7fffffe          BL       Msg
;;;2067   	for (i=0; i < 1 + FILE_NAME_LENGTH + FILE_TYPE_LENGTH + 1; i++) {
001194  2500              MOVS     r5,#0
                  |L1.4502|
;;;2068   		ch = name_buf[i];
001196  5d71              LDRB     r1,[r6,r5]
;;;2069   		if (ch < 32) ch = '.';
001198  2920              CMP      r1,#0x20
00119a  d200              BCS      |L1.4510|
00119c  212e              MOVS     r1,#0x2e
                  |L1.4510|
;;;2070   		Msg("%c", ch);
00119e  a070              ADR      r0,|L1.4960|
0011a0  f7fffffe          BL       Msg
0011a4  1c6d              ADDS     r5,r5,#1
0011a6  b2ed              UXTB     r5,r5                 ;2067
0011a8  2d13              CMP      r5,#0x13              ;2067
0011aa  d3f4              BCC      |L1.4502|
;;;2071   	}
;;;2072   	Msg("\r\n");
0011ac  f2af106c          ADR      r0,|L1.4164|
0011b0  f7fffffe          BL       Msg
;;;2073   	SMsg();
0011b4  f7fffffe          BL       SMsg
;;;2074   	Msg("   FNT.Attribute: 0x%02X\r\n", p_fcs->FNT.Attribute);
0011b8  f894113c          LDRB     r1,[r4,#0x13c]
0011bc  a069              ADR      r0,|L1.4964|
0011be  f7fffffe          BL       Msg
;;;2075   	SMsg();
0011c2  f7fffffe          BL       SMsg
;;;2076   	Msg("   FNT.FirstCluster: %d (0x%04X)\r\n", p_fcs->FNT.FirstCluster, p_fcs->FNT.FirstCluster);
0011c6  f8b4113d          LDRH     r1,[r4,#0x13d]
0011ca  a06d              ADR      r0,|L1.4992|
0011cc  460a              MOV      r2,r1
0011ce  f7fffffe          BL       Msg
;;;2077   	SMsg();
0011d2  f7fffffe          BL       SMsg
;;;2078   	Msg("   FNT.Size: %d\r\n", p_fcs->FNT.Size);
0011d6  f8d4113f          LDR      r1,[r4,#0x13f]
0011da  a072              ADR      r0,|L1.5028|
0011dc  f7fffffe          BL       Msg
;;;2079   	Msg("   -------------------------\r\n", fcs_num);
0011e0  4639              MOV      r1,r7
0011e2  f2af10bc          ADR      r0,|L1.4136|
0011e6  f7fffffe          BL       Msg
;;;2080   	SMsg();
0011ea  e8bd41f0          POP      {r4-r8,lr}
0011ee  f7ffbffe          B.W      SMsg
                  |L1.4594|
0011f2  a071              ADR      r0,|L1.5048|
0011f4  e6cb              B        |L1.3982|
                  |L1.4598|
0011f6  a077              ADR      r0,|L1.5076|
0011f8  e6c9              B        |L1.3982|
;;;2081   }
;;;2082   
                          ENDP

                  FS_Params_Show PROC
;;;2084   // отобразить параметры файловой системы
;;;2085   void FS_Params_Show(void) {
0011fa  b510              PUSH     {r4,lr}
;;;2086   	Msg("MAX_FILES = %d\r\n", MAX_FILES);
0011fc  2108              MOVS     r1,#8
0011fe  a07c              ADR      r0,|L1.5104|
001200  f7fffffe          BL       Msg
;;;2087   	SMsg();
001204  f7fffffe          BL       SMsg
;;;2088   	Msg("BANKS_NUM = %d\r\n", FLASH_BANKS_NUM);
001208  4c7e              LDR      r4,|L1.5124|
00120a  a07f              ADR      r0,|L1.5128|
00120c  7821              LDRB     r1,[r4,#0]  ; FLASH_BANKS_NUM
00120e  f7fffffe          BL       Msg
;;;2089   	SMsg();
001212  f7fffffe          BL       SMsg
;;;2090   	Msg("SECTORS_PER_BANK = %d\r\n", FLASH_SECTORS_PER_BANK);
001216  2140              MOVS     r1,#0x40
001218  a080              ADR      r0,|L1.5148|
00121a  f7fffffe          BL       Msg
;;;2091   	SMsg();
00121e  f7fffffe          BL       SMsg
;;;2092   	Msg("PAGES_PER_SECTOR = %d\r\n", FLASH_PAGES_PER_SECTOR);
001222  f44f6180          MOV      r1,#0x400
001226  a083              ADR      r0,|L1.5172|
001228  f7fffffe          BL       Msg
;;;2093   	SMsg();
00122c  f7fffffe          BL       SMsg
;;;2094   	Msg("PAGE_SIZE = %d\r\n", PAGE_SIZE);
001230  f44f7180          MOV      r1,#0x100
001234  a085              ADR      r0,|L1.5196|
001236  f7fffffe          BL       Msg
;;;2095   	SMsg();
00123a  f7fffffe          BL       SMsg
;;;2096   	Msg("PAGES_PER_CLUSTER = %d\r\n", PAGES_PER_CLUSTER);
00123e  2140              MOVS     r1,#0x40
001240  a087              ADR      r0,|L1.5216|
001242  f7fffffe          BL       Msg
;;;2097   	SMsg();
001246  f7fffffe          BL       SMsg
;;;2098   	Msg("FILE_NAME_LENGTH = %d\r\n", FILE_NAME_LENGTH);
00124a  210e              MOVS     r1,#0xe
00124c  a08b              ADR      r0,|L1.5244|
00124e  f7fffffe          BL       Msg
;;;2099   	SMsg();
001252  f7fffffe          BL       SMsg
;;;2100   	Msg("FILE_TYPE_LENGTH = %d\r\n", FILE_TYPE_LENGTH);
001256  2103              MOVS     r1,#3
001258  a08e              ADR      r0,|L1.5268|
00125a  f7fffffe          BL       Msg
;;;2101   	SMsg();
00125e  f7fffffe          BL       SMsg
;;;2102   	Msg("FNT_RECORD_SIZE = %d\r\n", FNT_RECORD_SIZE);
001262  2120              MOVS     r1,#0x20
001264  a091              ADR      r0,|L1.5292|
001266  f7fffffe          BL       Msg
;;;2103   	SMsg();
00126a  f7fffffe          BL       SMsg
;;;2104   	Msg("CAT_RECORD_SIZE = %d\r\n", CAT_RECORD_SIZE);
00126e  2103              MOVS     r1,#3
001270  a094              ADR      r0,|L1.5316|
001272  f7fffffe          BL       Msg
;;;2105   	Msg("\r\n");
001276  a041              ADR      r0,|L1.4988|
001278  f7fffffe          BL       Msg
;;;2106   	SMsg();
00127c  f7fffffe          BL       SMsg
;;;2107   	Msg("SECTORS_NUMBER = %d\r\n", SECTORS_NUMBER);
001280  88a1              LDRH     r1,[r4,#4]  ; SECTORS_NUMBER
001282  a096              ADR      r0,|L1.5340|
001284  f7fffffe          BL       Msg
;;;2108   	SMsg();
001288  f7fffffe          BL       SMsg
;;;2109   	Msg("SECTOR_SIZE = %d\r\n", SECTOR_SIZE);
00128c  a099              ADR      r0,|L1.5364|
00128e  6961              LDR      r1,[r4,#0x14]  ; SECTOR_SIZE
001290  f7fffffe          BL       Msg
;;;2110   	SMsg();
001294  f7fffffe          BL       SMsg
;;;2111   	Msg("CLUSTERS_PER_SECTOR = %d\r\n", CLUSTERS_PER_SECTOR);
001298  88e1              LDRH     r1,[r4,#6]  ; CLUSTERS_PER_SECTOR
00129a  a09b              ADR      r0,|L1.5384|
00129c  f7fffffe          BL       Msg
;;;2112   	SMsg();
0012a0  f7fffffe          BL       SMsg
;;;2113   	Msg("CLUSTERS_NUMBER = %d\r\n", CLUSTERS_NUMBER);
0012a4  8921              LDRH     r1,[r4,#8]  ; CLUSTERS_NUMBER
0012a6  a09f              ADR      r0,|L1.5412|
0012a8  f7fffffe          BL       Msg
;;;2114   	SMsg();
0012ac  f7fffffe          BL       SMsg
;;;2115   	Msg("ClusterMAX = %d\r\n", ClusterMAX);
0012b0  8961              LDRH     r1,[r4,#0xa]  ; ClusterMAX
0012b2  a0a2              ADR      r0,|L1.5436|
0012b4  f7fffffe          BL       Msg
;;;2116   	SMsg();
0012b8  f7fffffe          BL       SMsg
;;;2117   	Msg("CLUSTER_SIZE = %d\r\n", CLUSTER_SIZE);
0012bc  89a1              LDRH     r1,[r4,#0xc]  ; CLUSTER_SIZE
0012be  a0a4              ADR      r0,|L1.5456|
0012c0  f7fffffe          BL       Msg
;;;2118   	SMsg();
0012c4  f7fffffe          BL       SMsg
;;;2119   	Msg("CAT_Size = %d\r\n", CAT_Size);
0012c8  a0a6              ADR      r0,|L1.5476|
0012ca  69a1              LDR      r1,[r4,#0x18]  ; CAT_Size
0012cc  f7fffffe          BL       Msg
;;;2120   	SMsg();
0012d0  f7fffffe          BL       SMsg
;;;2121   	Msg("CATRecordsNumber = %d\r\n", CATRecordsNumber);
0012d4  89e1              LDRH     r1,[r4,#0xe]  ; CATRecordsNumber
0012d6  a0a7              ADR      r0,|L1.5492|
0012d8  f7fffffe          BL       Msg
;;;2122   	SMsg();
0012dc  f7fffffe          BL       SMsg
;;;2123   	Msg("CATRecordMAX = %d\r\n", CATRecordMAX);
0012e0  8a21              LDRH     r1,[r4,#0x10]  ; CATRecordMAX
0012e2  a0aa              ADR      r0,|L1.5516|
0012e4  f7fffffe          BL       Msg
;;;2124   	SMsg();
0012e8  f7fffffe          BL       SMsg
;;;2125   	Msg("FNTRecordsNumber = %d\r\n", FNTRecordsNumber);
0012ec  a0ac              ADR      r0,|L1.5536|
0012ee  69e1              LDR      r1,[r4,#0x1c]  ; FNTRecordsNumber
0012f0  f7fffffe          BL       Msg
;;;2126   	SMsg();
0012f4  f7fffffe          BL       SMsg
;;;2127   	Msg("FNTRecordMAX = %d\r\n", FNTRecordMAX);
0012f8  a0af              ADR      r0,|L1.5560|
0012fa  6a21              LDR      r1,[r4,#0x20]  ; FNTRecordMAX
0012fc  f7fffffe          BL       Msg
;;;2128   	Msg("\r\n");
001300  a01e              ADR      r0,|L1.4988|
001302  f7fffffe          BL       Msg
;;;2129   	SMsg();
001306  f7fffffe          BL       SMsg
;;;2130   	Msg("FNT_BASE_ADDRESS = %d\r\n", FNT_BASE_ADDRESS);
00130a  2120              MOVS     r1,#0x20
00130c  a0af              ADR      r0,|L1.5580|
00130e  f7fffffe          BL       Msg
;;;2131   	SMsg();
001312  f7fffffe          BL       SMsg
;;;2132   	Msg("CAT_BASE_ADDRESS = %d\r\n", CAT_BASE_ADDRESS);
001316  a0b3              ADR      r0,|L1.5604|
001318  6a61              LDR      r1,[r4,#0x24]  ; CAT_BASE_ADDRESS
00131a  f7fffffe          BL       Msg
;;;2133   	SMsg();
00131e  f7fffffe          BL       SMsg
;;;2134   	Msg("CLUSTERS_BASE_ADDRESS = %d\r\n", CLUSTERS_BASE_ADDRESS);
001322  a0b6              ADR      r0,|L1.5628|
001324  6aa1              LDR      r1,[r4,#0x28]  ; CLUSTERS_BASE_ADDRESS
001326  f7fffffe          BL       Msg
;;;2135   	SMsg();
00132a  e8bd4010          POP      {r4,lr}
00132e  f7ffbffe          B.W      SMsg
;;;2136   }
;;;2137   //-----------------------------------------
                          ENDP

001332  0000              DCW      0x0000
                  |L1.4916|
001334  20202046          DCB      "   FNT:\r\n",0
001338  4e543a0d
00133c  0a00    
00133e  00                DCB      0
00133f  00                DCB      0
                  |L1.4928|
001340  20202046          DCB      "   FNT.FullName: ",0
001344  4e542e46
001348  756c6c4e
00134c  616d653a
001350  2000    
001352  00                DCB      0
001353  00                DCB      0
                  |L1.4948|
001354  20253032          DCB      " %02X",0
001358  5800    
00135a  00                DCB      0
00135b  00                DCB      0
                  |L1.4956|
00135c  207c2000          DCB      " | ",0
                  |L1.4960|
001360  256300            DCB      "%c",0
001363  00                DCB      0
                  |L1.4964|
001364  20202046          DCB      "   FNT.Attribute: 0x%02X"
001368  4e542e41
00136c  74747269
001370  62757465
001374  3a203078
001378  25303258
                  |L1.4988|
00137c  0d0a00            DCB      "\r\n",0
00137f  00                DCB      0
                  |L1.4992|
001380  20202046          DCB      "   FNT.FirstCluster: %d (0x%04X)\r\n",0
001384  4e542e46
001388  69727374
00138c  436c7573
001390  7465723a
001394  20256420
001398  28307825
00139c  30345829
0013a0  0d0a00  
0013a3  00                DCB      0
                  |L1.5028|
0013a4  20202046          DCB      "   FNT.Size: %d\r\n",0
0013a8  4e542e53
0013ac  697a653a
0013b0  2025640d
0013b4  0a00    
0013b6  00                DCB      0
0013b7  00                DCB      0
                  |L1.5048|
0013b8  20284643          DCB      " (FCS_STATE_OPENED_READ)\r\n",0
0013bc  535f5354
0013c0  4154455f
0013c4  4f50454e
0013c8  45445f52
0013cc  45414429
0013d0  0d0a00  
0013d3  00                DCB      0
                  |L1.5076|
0013d4  20284643          DCB      " (FCS_STATE_OPENED_WRITE)\r\n",0
0013d8  535f5354
0013dc  4154455f
0013e0  4f50454e
0013e4  45445f57
0013e8  52495445
0013ec  290d0a00
                  |L1.5104|
0013f0  4d41585f          DCB      "MAX_FILES = %d\r\n",0
0013f4  46494c45
0013f8  53203d20
0013fc  25640d0a
001400  00      
001401  00                DCB      0
001402  00                DCB      0
001403  00                DCB      0
                  |L1.5124|
                          DCD      ||.data||
                  |L1.5128|
001408  42414e4b          DCB      "BANKS_NUM = %d\r\n",0
00140c  535f4e55
001410  4d203d20
001414  25640d0a
001418  00      
001419  00                DCB      0
00141a  00                DCB      0
00141b  00                DCB      0
                  |L1.5148|
00141c  53454354          DCB      "SECTORS_PER_BANK = %d\r\n",0
001420  4f52535f
001424  5045525f
001428  42414e4b
00142c  203d2025
001430  640d0a00
                  |L1.5172|
001434  50414745          DCB      "PAGES_PER_SECTOR = %d\r\n",0
001438  535f5045
00143c  525f5345
001440  43544f52
001444  203d2025
001448  640d0a00
                  |L1.5196|
00144c  50414745          DCB      "PAGE_SIZE = %d\r\n",0
001450  5f53495a
001454  45203d20
001458  25640d0a
00145c  00      
00145d  00                DCB      0
00145e  00                DCB      0
00145f  00                DCB      0
                  |L1.5216|
001460  50414745          DCB      "PAGES_PER_CLUSTER = %d\r\n",0
001464  535f5045
001468  525f434c
00146c  55535445
001470  52203d20
001474  25640d0a
001478  00      
001479  00                DCB      0
00147a  00                DCB      0
00147b  00                DCB      0
                  |L1.5244|
00147c  46494c45          DCB      "FILE_NAME_LENGTH = %d\r\n",0
001480  5f4e414d
001484  455f4c45
001488  4e475448
00148c  203d2025
001490  640d0a00
                  |L1.5268|
001494  46494c45          DCB      "FILE_TYPE_LENGTH = %d\r\n",0
001498  5f545950
00149c  455f4c45
0014a0  4e475448
0014a4  203d2025
0014a8  640d0a00
                  |L1.5292|
0014ac  464e545f          DCB      "FNT_RECORD_SIZE = %d\r\n",0
0014b0  5245434f
0014b4  52445f53
0014b8  495a4520
0014bc  3d202564
0014c0  0d0a00  
0014c3  00                DCB      0
                  |L1.5316|
0014c4  4341545f          DCB      "CAT_RECORD_SIZE = %d\r\n",0
0014c8  5245434f
0014cc  52445f53
0014d0  495a4520
0014d4  3d202564
0014d8  0d0a00  
0014db  00                DCB      0
                  |L1.5340|
0014dc  53454354          DCB      "SECTORS_NUMBER = %d\r\n",0
0014e0  4f52535f
0014e4  4e554d42
0014e8  4552203d
0014ec  2025640d
0014f0  0a00    
0014f2  00                DCB      0
0014f3  00                DCB      0
                  |L1.5364|
0014f4  53454354          DCB      "SECTOR_SIZE = %d\r\n",0
0014f8  4f525f53
0014fc  495a4520
001500  3d202564
001504  0d0a00  
001507  00                DCB      0
                  |L1.5384|
001508  434c5553          DCB      "CLUSTERS_PER_SECTOR = %d\r\n",0
00150c  54455253
001510  5f504552
001514  5f534543
001518  544f5220
00151c  3d202564
001520  0d0a00  
001523  00                DCB      0
                  |L1.5412|
001524  434c5553          DCB      "CLUSTERS_NUMBER = %d\r\n",0
001528  54455253
00152c  5f4e554d
001530  42455220
001534  3d202564
001538  0d0a00  
00153b  00                DCB      0
                  |L1.5436|
00153c  436c7573          DCB      "ClusterMAX = %d\r\n",0
001540  7465724d
001544  4158203d
001548  2025640d
00154c  0a00    
00154e  00                DCB      0
00154f  00                DCB      0
                  |L1.5456|
001550  434c5553          DCB      "CLUSTER_SIZE = %d\r\n",0
001554  5445525f
001558  53495a45
00155c  203d2025
001560  640d0a00
                  |L1.5476|
001564  4341545f          DCB      "CAT_Size = %d\r\n",0
001568  53697a65
00156c  203d2025
001570  640d0a00
                  |L1.5492|
001574  43415452          DCB      "CATRecordsNumber = %d\r\n",0
001578  65636f72
00157c  64734e75
001580  6d626572
001584  203d2025
001588  640d0a00
                  |L1.5516|
00158c  43415452          DCB      "CATRecordMAX = %d\r\n",0
001590  65636f72
001594  644d4158
001598  203d2025
00159c  640d0a00
                  |L1.5536|
0015a0  464e5452          DCB      "FNTRecordsNumber = %d\r\n",0
0015a4  65636f72
0015a8  64734e75
0015ac  6d626572
0015b0  203d2025
0015b4  640d0a00
                  |L1.5560|
0015b8  464e5452          DCB      "FNTRecordMAX = %d\r\n",0
0015bc  65636f72
0015c0  644d4158
0015c4  203d2025
0015c8  640d0a00
                  |L1.5580|
0015cc  464e545f          DCB      "FNT_BASE_ADDRESS = %d\r\n",0
0015d0  42415345
0015d4  5f414444
0015d8  52455353
0015dc  203d2025
0015e0  640d0a00
                  |L1.5604|
0015e4  4341545f          DCB      "CAT_BASE_ADDRESS = %d\r\n",0
0015e8  42415345
0015ec  5f414444
0015f0  52455353
0015f4  203d2025
0015f8  640d0a00
                  |L1.5628|
0015fc  434c5553          DCB      "CLUSTERS_BASE_ADDRESS = %d\r\n",0
001600  54455253
001604  5f424153
001608  455f4144
00160c  44524553
001610  53203d20
001614  25640d0a
001618  00      
001619  00                DCB      0
00161a  00                DCB      0
00161b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pFCSArray
                          %        32
                  FCSArray
                          %        2584

                          AREA ||.data||, DATA, ALIGN=2

                  FLASH_BANKS_NUM
000000  00                DCB      0x00
                  FS_IS_INITED
000001  00                DCB      0x00
                  FS_STATE
000002  0000              DCB      0x00,0x00
                  SECTORS_NUMBER
000004  0000              DCB      0x00,0x00
                  CLUSTERS_PER_SECTOR
000006  0000              DCB      0x00,0x00
                  CLUSTERS_NUMBER
000008  0000              DCB      0x00,0x00
                  ClusterMAX
00000a  0000              DCB      0x00,0x00
                  CLUSTER_SIZE
00000c  0000              DCB      0x00,0x00
                  CATRecordsNumber
00000e  0000              DCB      0x00,0x00
                  CATRecordMAX
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  SECTOR_SIZE
                          DCD      0x00000000
                  CAT_Size
                          DCD      0x00000000
                  FNTRecordsNumber
                          DCD      0x00000000
                  FNTRecordMAX
                          DCD      0x00000000
                  CAT_BASE_ADDRESS
                          DCD      0x00000000
                  CLUSTERS_BASE_ADDRESS
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Main\\FS.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___4_FS_c_6674ac69____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___4_FS_c_6674ac69____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___4_FS_c_6674ac69____REVSH|
#line 462
|__asm___4_FS_c_6674ac69____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___4_FS_c_6674ac69____RRX|
#line 649
|__asm___4_FS_c_6674ac69____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
