; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\flash\lpc17xx_clkpwr.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\lpc17xx_clkpwr.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\Drivers\include -I.\Common -I.\Retarget -ID:\Projects\Frezer\Frezer.keil\01020124\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\LPC1700_DFP\2.3.0\Device\Include -D__UVISION_VERSION=517 -D_RTE_ -DLPC175x_6x --omf_browse=.\flash\lpc17xx_clkpwr.crf Drivers\source\lpc17xx_clkpwr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CLKPWR_SetPCLKDiv PROC
;;;80      						// 4				   0
;;;81     void CLKPWR_SetPCLKDiv (uint32_t ClkType, uint32_t DivVal)
000000  b510              PUSH     {r4,lr}
;;;82     {
;;;83     	uint32_t bitpos;
;;;84     
;;;85     	bitpos = (ClkType < 32) ? (ClkType) : (ClkType - 32);
;;;86     
;;;87     	/* PCLKSEL0 selected */
;;;88     	if (ClkType < 32)
;;;89     	{
;;;90     		/* Clear two bit at bit position */
;;;91     		LPC_SC->PCLKSEL0 &= (~(CLKPWR_PCLKSEL_BITMASK(bitpos)));
000002  4a3d              LDR      r2,|L1.248|
000004  2303              MOVS     r3,#3
000006  2820              CMP      r0,#0x20              ;85
000008  d301              BCC      |L1.14|
00000a  f1a00020          SUB      r0,r0,#0x20           ;85
                  |L1.14|
00000e  d210              BCS      |L1.50|
000010  f8d241a8          LDR      r4,[r2,#0x1a8]
000014  fa03f300          LSL      r3,r3,r0
000018  ea240403          BIC      r4,r4,r3
00001c  f8c241a8          STR      r4,[r2,#0x1a8]
;;;92     
;;;93     		/* Set two selected bit */
;;;94     		LPC_SC->PCLKSEL0 |= (CLKPWR_PCLKSEL_SET(bitpos, DivVal));
000020  f8d231a8          LDR      r3,[r2,#0x1a8]
000024  fa01f100          LSL      r1,r1,r0
000028  ea430301          ORR      r3,r3,r1
00002c  f8c231a8          STR      r3,[r2,#0x1a8]
;;;95     	}
;;;96     	/* PCLKSEL1 selected */
;;;97     	else
;;;98     	{
;;;99     		/* Clear two bit at bit position */	 //(0x3 << 4)  // 4
;;;100    		LPC_SC->PCLKSEL1 &= ~(CLKPWR_PCLKSEL_BITMASK(bitpos));
;;;101    
;;;102    		/* Set two selected bit *///		(0<<4)	  4		   0
;;;103    		LPC_SC->PCLKSEL1 |= (CLKPWR_PCLKSEL_SET(bitpos, DivVal));
;;;104    	}
;;;105    }
000030  bd10              POP      {r4,pc}
                  |L1.50|
000032  f8d241ac          LDR      r4,[r2,#0x1ac]        ;100
000036  fa03f300          LSL      r3,r3,r0              ;100
00003a  ea240403          BIC      r4,r4,r3              ;100
00003e  f8c241ac          STR      r4,[r2,#0x1ac]        ;100
000042  f8d231ac          LDR      r3,[r2,#0x1ac]        ;103
000046  fa01f100          LSL      r1,r1,r0              ;103
00004a  ea430301          ORR      r3,r3,r1              ;103
00004e  f8c231ac          STR      r3,[r2,#0x1ac]        ;103
000052  bd10              POP      {r4,pc}
;;;106    
                          ENDP

                  CLKPWR_GetPCLKSEL PROC
;;;141     **********************************************************************/
;;;142    uint32_t CLKPWR_GetPCLKSEL (uint32_t ClkType)
000054  4928              LDR      r1,|L1.248|
;;;143    {
;;;144    	uint32_t bitpos, retval;
;;;145    
;;;146    	if (ClkType < 32)
000056  2820              CMP      r0,#0x20
000058  d202              BCS      |L1.96|
;;;147    	{
;;;148    		bitpos = ClkType;
;;;149    		retval = LPC_SC->PCLKSEL0;
00005a  f8d111a8          LDR      r1,[r1,#0x1a8]
00005e  e002              B        |L1.102|
                  |L1.96|
;;;150    	}
;;;151    	else
;;;152    	{
;;;153    		bitpos = ClkType - 32;
;;;154    		retval = LPC_SC->PCLKSEL1;
000060  f8d111ac          LDR      r1,[r1,#0x1ac]
000064  3820              SUBS     r0,r0,#0x20
                  |L1.102|
;;;155    	}
;;;156    
;;;157    	retval = CLKPWR_PCLKSEL_GET(bitpos, retval);
000066  40c1              LSRS     r1,r1,r0
000068  f0010003          AND      r0,r1,#3
;;;158    	return retval;
;;;159    }
00006c  4770              BX       lr
;;;160    
                          ENDP

                  CLKPWR_GetPCLK PROC
;;;196     **********************************************************************/
;;;197    uint32_t CLKPWR_GetPCLK (uint32_t ClkType)
00006e  4923              LDR      r1,|L1.252|
;;;198    {
000070  b500              PUSH     {lr}
;;;199    	uint32_t retval, div;
;;;200    
;;;201    	retval = SystemCoreClock;
;;;202    	div = CLKPWR_GetPCLKSEL(ClkType);
000072  680a              LDR      r2,[r1,#0]  ; SystemCoreClock
000074  f7fffffe          BL       CLKPWR_GetPCLKSEL
;;;203    
;;;204    	switch (div)
000078  b130              CBZ      r0,|L1.136|
00007a  2801              CMP      r0,#1
00007c  d007              BEQ      |L1.142|
00007e  2802              CMP      r0,#2
000080  d005              BEQ      |L1.142|
000082  2803              CMP      r0,#3
000084  d103              BNE      |L1.142|
000086  e001              B        |L1.140|
                  |L1.136|
;;;205    	{
;;;206    	case 0:
;;;207    		div = 4;
000088  2004              MOVS     r0,#4
;;;208    		break;
00008a  e000              B        |L1.142|
                  |L1.140|
;;;209    
;;;210    	case 1:
;;;211    		div = 1;
;;;212    		break;
;;;213    
;;;214    	case 2:
;;;215    		div = 2;
;;;216    		break;
;;;217    
;;;218    	case 3:
;;;219    		div = 8;
00008c  2008              MOVS     r0,#8
                  |L1.142|
;;;220    		break;
;;;221    	}
;;;222    	retval /= div;
00008e  fbb2f0f0          UDIV     r0,r2,r0
;;;223    
;;;224    	return retval;
;;;225    }
000092  bd00              POP      {pc}
;;;226    
                          ENDP

                  CLKPWR_ConfigPPWR PROC
;;;266     **********************************************************************/
;;;267    void CLKPWR_ConfigPPWR (uint32_t PPType, FunctionalState NewState)
000094  4a18              LDR      r2,|L1.248|
;;;268    {
;;;269    	if (NewState == ENABLE)
;;;270    	{
;;;271    		LPC_SC->PCONP |= PPType & CLKPWR_PCONP_BITMASK;
000096  4b1a              LDR      r3,|L1.256|
000098  2901              CMP      r1,#1                 ;269
00009a  d007              BEQ      |L1.172|
;;;272    	}
;;;273    	else if (NewState == DISABLE)
00009c  2900              CMP      r1,#0
00009e  d104              BNE      |L1.170|
;;;274    	{
;;;275    		LPC_SC->PCONP &= (~PPType) & CLKPWR_PCONP_BITMASK;
0000a0  f8521fc4          LDR      r1,[r2,#0xc4]!
0000a4  4383              BICS     r3,r3,r0
0000a6  4019              ANDS     r1,r1,r3
                  |L1.168|
0000a8  6011              STR      r1,[r2,#0]            ;271
                  |L1.170|
;;;276    	}
;;;277    }
0000aa  4770              BX       lr
                  |L1.172|
0000ac  f8521fc4          LDR      r1,[r2,#0xc4]!        ;271
0000b0  4018              ANDS     r0,r0,r3              ;271
0000b2  4301              ORRS     r1,r1,r0              ;271
0000b4  e7f8              B        |L1.168|
;;;278    
                          ENDP

                  CLKPWR_Sleep PROC
;;;284     **********************************************************************/
;;;285    void CLKPWR_Sleep(void)
0000b6  4910              LDR      r1,|L1.248|
;;;286    {
;;;287    	LPC_SC->PCON = 0x00;
0000b8  2000              MOVS     r0,#0
0000ba  f8c100c0          STR      r0,[r1,#0xc0]
;;;288    	/* Sleep Mode*/
;;;289    	__WFI();
0000be  bf30              WFI      
;;;290    }
0000c0  4770              BX       lr
;;;291    
                          ENDP

                  CLKPWR_DeepSleep PROC
;;;297     **********************************************************************/
;;;298    void CLKPWR_DeepSleep(void)
0000c2  4910              LDR      r1,|L1.260|
;;;299    {
;;;300        /* Deep-Sleep Mode, set SLEEPDEEP bit */
;;;301    	SCB->SCR = 0x4;
0000c4  2004              MOVS     r0,#4
0000c6  6008              STR      r0,[r1,#0]
;;;302    	LPC_SC->PCON = 0x8;
0000c8  490b              LDR      r1,|L1.248|
0000ca  2008              MOVS     r0,#8
0000cc  f8c100c0          STR      r0,[r1,#0xc0]
;;;303    	/* Deep Sleep Mode*/
;;;304    	__WFI();
0000d0  bf30              WFI      
;;;305    }
0000d2  4770              BX       lr
;;;306    
                          ENDP

                  CLKPWR_PowerDown PROC
;;;312     **********************************************************************/
;;;313    void CLKPWR_PowerDown(void)
0000d4  490b              LDR      r1,|L1.260|
;;;314    {
;;;315        /* Deep-Sleep Mode, set SLEEPDEEP bit */
;;;316    	SCB->SCR = 0x4;
0000d6  2004              MOVS     r0,#4
0000d8  6008              STR      r0,[r1,#0]
;;;317    	LPC_SC->PCON = 0x09;
0000da  4907              LDR      r1,|L1.248|
0000dc  2009              MOVS     r0,#9
0000de  f8c100c0          STR      r0,[r1,#0xc0]
;;;318    	/* Power Down Mode*/
;;;319    	__WFI();
0000e2  bf30              WFI      
;;;320    }
0000e4  4770              BX       lr
;;;321    
                          ENDP

                  CLKPWR_DeepPowerDown PROC
;;;327     **********************************************************************/
;;;328    void CLKPWR_DeepPowerDown(void)
0000e6  4907              LDR      r1,|L1.260|
;;;329    {
;;;330        /* Deep-Sleep Mode, set SLEEPDEEP bit */
;;;331    	SCB->SCR = 0x4;
0000e8  2004              MOVS     r0,#4
0000ea  6008              STR      r0,[r1,#0]
;;;332    	LPC_SC->PCON = 0x03;
0000ec  4902              LDR      r1,|L1.248|
0000ee  2003              MOVS     r0,#3
0000f0  f8c100c0          STR      r0,[r1,#0xc0]
;;;333    	/* Deep Power Down Mode*/
;;;334    	__WFI();
0000f4  bf30              WFI      
;;;335    }
0000f6  4770              BX       lr
;;;336    
                          ENDP

                  |L1.248|
                          DCD      0x400fc000
                  |L1.252|
                          DCD      SystemCoreClock
                  |L1.256|
                          DCD      0xefeff7de
                  |L1.260|
                          DCD      0xe000ed10

;*** Start embedded assembler ***

#line 1 "Drivers\\source\\lpc17xx_clkpwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_lpc17xx_clkpwr_c_5f9c9c89____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_lpc17xx_clkpwr_c_5f9c9c89____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_lpc17xx_clkpwr_c_5f9c9c89____REVSH|
#line 462
|__asm___16_lpc17xx_clkpwr_c_5f9c9c89____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_lpc17xx_clkpwr_c_5f9c9c89____RRX|
#line 649
|__asm___16_lpc17xx_clkpwr_c_5f9c9c89____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
