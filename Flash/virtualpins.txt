; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\flash\virtualpins.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\virtualpins.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\Main -I.\Drivers -I.\Drivers\include -I.\UCNC -ID:\Projects\Frezer\Frezer.keil\01020124\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\LPC1700_DFP\2.3.0\Device\Include -D__UVISION_VERSION=517 -D_RTE_ -DLPC175x_6x --omf_browse=.\flash\virtualpins.crf UCNC\VirtualPins.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SetPinsErrHandler PROC
;;;69     
;;;70     void SetPinsErrHandler(TErrHandler eh){
000000  49fa              LDR      r1,|L1.1004|
;;;71     	pErrHandler = eh;
000002  6008              STR      r0,[r1,#0]  ; pErrHandler
;;;72     }
000004  4770              BX       lr
;;;73     //void (*pErrorFunction)(TPinError * pe); 
                          ENDP

                  CallErrorHandler PROC
;;;106    
;;;107    void CallErrorHandler(u8 n,u16 Code){
000006  b4f0              PUSH     {r4-r7}
;;;108    	if (pErrHandler) { 
000008  4df8              LDR      r5,|L1.1004|
00000a  682c              LDR      r4,[r5,#0]            ;107  ; pErrHandler
00000c  2c00              CMP      r4,#0                 ;107
00000e  d041              BEQ      |L1.148|
;;;109    		// запонить структуру возврвщаемую в обработчике ошибки
;;;110    		// и вызвать обработчик
;;;111    		pe.ErrorCode = Code;	// 
000010  4af7              LDR      r2,|L1.1008|
;;;112    		pe.vNum = n;
;;;113    		pe.sNum = (*pvPins)[n].nPin;
000012  eb000340          ADD      r3,r0,r0,LSL #1
000016  8011              STRH     r1,[r2,#0]            ;111
000018  7090              STRB     r0,[r2,#2]            ;112
00001a  6868              LDR      r0,[r5,#4]  ; pvPins
00001c  5cc1              LDRB     r1,[r0,r3]
00001e  70d1              STRB     r1,[r2,#3]
;;;114    		if ((*pvPins)[n].nPin < PinCount) {
000020  5cc5              LDRB     r5,[r0,r3]
;;;115    			// через switch
;;;116    			if (aPin[(*pvPins)[n].nPin].pPort==LPC_GPIO0) pe.sPort = 0; else
;;;117    			if (aPin[(*pvPins)[n].nPin].pPort==LPC_GPIO1) pe.sPort = 1; else
;;;118    			if (aPin[(*pvPins)[n].nPin].pPort==LPC_GPIO2) pe.sPort = 2; else
;;;119    			if (aPin[(*pvPins)[n].nPin].pPort==LPC_GPIO3) pe.sPort = 3; else
;;;120    				pe.sPort = 0xFF;
000022  21ff              MOVS     r1,#0xff
000024  2d24              CMP      r5,#0x24              ;114
000026  d22d              BCS      |L1.132|
000028  eb050645          ADD      r6,r5,r5,LSL #1       ;116
00002c  4df1              LDR      r5,|L1.1012|
00002e  4ff2              LDR      r7,|L1.1016|
000030  f8556026          LDR      r6,[r5,r6,LSL #2]     ;116
000034  42be              CMP      r6,r7                 ;116
000036  d101              BNE      |L1.60|
000038  2100              MOVS     r1,#0                 ;116
00003a  e010              B        |L1.94|
                  |L1.60|
00003c  4fee              LDR      r7,|L1.1016|
00003e  3720              ADDS     r7,r7,#0x20           ;117
000040  42be              CMP      r6,r7                 ;117
000042  d101              BNE      |L1.72|
000044  2101              MOVS     r1,#1                 ;117
000046  e00a              B        |L1.94|
                  |L1.72|
000048  4feb              LDR      r7,|L1.1016|
00004a  3740              ADDS     r7,r7,#0x40           ;118
00004c  42be              CMP      r6,r7                 ;118
00004e  d101              BNE      |L1.84|
000050  2102              MOVS     r1,#2                 ;118
000052  e004              B        |L1.94|
                  |L1.84|
000054  4fe8              LDR      r7,|L1.1016|
000056  3760              ADDS     r7,r7,#0x60           ;119
000058  42be              CMP      r6,r7                 ;119
00005a  d100              BNE      |L1.94|
00005c  2103              MOVS     r1,#3                 ;119
                  |L1.94|
00005e  7111              STRB     r1,[r2,#4]
;;;121    			pe.sPin = aPin[(*pvPins)[n].nPin].mPin;
000060  5cc1              LDRB     r1,[r0,r3]
000062  eb010141          ADD      r1,r1,r1,LSL #1
000066  eb050181          ADD      r1,r5,r1,LSL #2
00006a  6849              LDR      r1,[r1,#4]
;;;122    			pe.Dir  = aPin[(*pvPins)[n].nPin].DIR;
00006c  6091              STR      r1,[r2,#8]  ; pe
00006e  5cc1              LDRB     r1,[r0,r3]
;;;123    			pe.Inv	= (*pvPins)[n].Inv;
000070  4418              ADD      r0,r0,r3
000072  eb010141          ADD      r1,r1,r1,LSL #1       ;122
000076  eb050181          ADD      r1,r5,r1,LSL #2       ;122
00007a  7a09              LDRB     r1,[r1,#8]            ;122
00007c  7311              STRB     r1,[r2,#0xc]          ;122
00007e  7840              LDRB     r0,[r0,#1]
000080  7350              STRB     r0,[r2,#0xd]
000082  e003              B        |L1.140|
                  |L1.132|
;;;124    		} else {
;;;125    			pe.sPort = 0xFF;
000084  7111              STRB     r1,[r2,#4]
;;;126    			pe.sPin = 0xFF;
;;;127    			pe.Dir  = 0xFF;
000086  6091              STR      r1,[r2,#8]  ; pe
000088  7311              STRB     r1,[r2,#0xc]
;;;128    			pe.Inv	= 0xFF;
00008a  7351              STRB     r1,[r2,#0xd]
                  |L1.140|
;;;129    		}
;;;130    	 	(*pErrHandler)(&pe);
00008c  46a4              MOV      r12,r4
00008e  bcf0              POP      {r4-r7}
000090  48d7              LDR      r0,|L1.1008|
000092  4760              BX       r12
                  |L1.148|
;;;131    	}
;;;132    }
000094  bcf0              POP      {r4-r7}
000096  4770              BX       lr
;;;133    
                          ENDP

                  ClrPin PROC
;;;192    // сброс виртуального пина
;;;193    BOOL ClrPin(u8 n){
000098  b570              PUSH     {r4-r6,lr}
;;;194    	if ((*pvPins)[n].nPin!=0xFF) { // инициализация виртуального пина
00009a  4ad4              LDR      r2,|L1.1004|
00009c  eb000340          ADD      r3,r0,r0,LSL #1
0000a0  6854              LDR      r4,[r2,#4]  ; pvPins
0000a2  5ce1              LDRB     r1,[r4,r3]
0000a4  29ff              CMP      r1,#0xff
0000a6  d026              BEQ      |L1.246|
;;;195    		if(aPin[(*pvPins)[n].nPin].DIR==DIR_OUT)  // направление инициализации статического пина
0000a8  eb010541          ADD      r5,r1,r1,LSL #1
0000ac  49d1              LDR      r1,|L1.1012|
0000ae  eb010585          ADD      r5,r1,r5,LSL #2
0000b2  68ad              LDR      r5,[r5,#8]
0000b4  2d01              CMP      r5,#1
0000b6  d005              BEQ      |L1.196|
;;;196    		{
;;;197    			if ((*pvPins)[n].State) {
;;;198    				(*pvPins)[n].State = 0;
;;;199    				if ((*pvPins)[n].Inv) 
;;;200    					// инверсия
;;;201    					aPin[(*pvPins)[n].nPin].pPort->FIOPIN |=  (aPin[(*pvPins)[n].nPin].mPin);
;;;202    			   	else
;;;203    					aPin[(*pvPins)[n].nPin].pPort->FIOPIN &= ~(aPin[(*pvPins)[n].nPin].mPin);
;;;204    			}
;;;205    		   	return TRUE;
;;;206    		} else {
;;;207    			CallErrorHandler(n,0x31);
0000b8  f05f0131          MOVS.W   r1,#0x31
                  |L1.188|
0000bc  f7fffffe          BL       CallErrorHandler
;;;208    		}
;;;209    	} else {
;;;210    		CallErrorHandler(n,0x30);
;;;211    	}
;;;212    	return FALSE;
0000c0  2000              MOVS     r0,#0
;;;213    }
0000c2  bd70              POP      {r4-r6,pc}
                  |L1.196|
0000c4  1918              ADDS     r0,r3,r4              ;197
0000c6  7884              LDRB     r4,[r0,#2]            ;197
0000c8  b19c              CBZ      r4,|L1.242|
0000ca  2400              MOVS     r4,#0                 ;198
0000cc  7084              STRB     r4,[r0,#2]            ;198
0000ce  6850              LDR      r0,[r2,#4]            ;199  ; pvPins
0000d0  181a              ADDS     r2,r3,r0              ;199
0000d2  5cc0              LDRB     r0,[r0,r3]            ;203
0000d4  7852              LDRB     r2,[r2,#1]            ;199
0000d6  eb000040          ADD      r0,r0,r0,LSL #1       ;203
0000da  2a00              CMP      r2,#0                 ;199
0000dc  f8512020          LDR      r2,[r1,r0,LSL #2]     ;203
0000e0  6953              LDR      r3,[r2,#0x14]         ;203
0000e2  eb010080          ADD      r0,r1,r0,LSL #2       ;203
0000e6  6840              LDR      r0,[r0,#4]            ;203
0000e8  d001              BEQ      |L1.238|
0000ea  4303              ORRS     r3,r3,r0              ;201
0000ec  e000              B        |L1.240|
                  |L1.238|
0000ee  4383              BICS     r3,r3,r0              ;203
                  |L1.240|
0000f0  6153              STR      r3,[r2,#0x14]         ;201
                  |L1.242|
0000f2  2001              MOVS     r0,#1                 ;205
0000f4  bd70              POP      {r4-r6,pc}
                  |L1.246|
0000f6  2130              MOVS     r1,#0x30              ;210
0000f8  e7e0              B        |L1.188|
;;;214    
                          ENDP

                  SetPin PROC
;;;159    // установка виртуального пина
;;;160    BOOL SetPin(u8 n){
0000fa  b570              PUSH     {r4-r6,lr}
;;;161    	if ((*pvPins)[n].nPin!=0xFF) { // инициализация виртуального пина
0000fc  4abb              LDR      r2,|L1.1004|
0000fe  eb000340          ADD      r3,r0,r0,LSL #1
000102  6854              LDR      r4,[r2,#4]  ; pvPins
000104  5ce1              LDRB     r1,[r4,r3]
000106  29ff              CMP      r1,#0xff
000108  d025              BEQ      |L1.342|
;;;162    		if	(aPin[(*pvPins)[n].nPin].DIR==DIR_OUT)  // направление инициализации статического пина
00010a  eb010541          ADD      r5,r1,r1,LSL #1
00010e  49b9              LDR      r1,|L1.1012|
000110  eb010585          ADD      r5,r1,r5,LSL #2
000114  68ad              LDR      r5,[r5,#8]
000116  2d01              CMP      r5,#1
000118  d004              BEQ      |L1.292|
;;;163    		{
;;;164    			if (!(*pvPins)[n].State) {
;;;165    				(*pvPins)[n].State = 1;
;;;166    				if ((*pvPins)[n].Inv) 
;;;167    				     aPin[(*pvPins)[n].nPin].pPort->FIOPIN &= ~(aPin[(*pvPins)[n].nPin].mPin);
;;;168    			   	else aPin[(*pvPins)[n].nPin].pPort->FIOPIN |=  (aPin[(*pvPins)[n].nPin].mPin);
;;;169    			}
;;;170    		   	return TRUE;
;;;171    		} else {
;;;172    			CallErrorHandler(n,0x21);
00011a  2121              MOVS     r1,#0x21
                  |L1.284|
00011c  f7fffffe          BL       CallErrorHandler
;;;173    		}
;;;174    	} else {
;;;175    		CallErrorHandler(n,0x20);
;;;176    	}
;;;177    	return FALSE;
000120  2000              MOVS     r0,#0
;;;178    }
000122  bd70              POP      {r4-r6,pc}
                  |L1.292|
000124  1918              ADDS     r0,r3,r4              ;164
000126  7884              LDRB     r4,[r0,#2]            ;164
000128  b99c              CBNZ     r4,|L1.338|
00012a  2401              MOVS     r4,#1                 ;165
00012c  7084              STRB     r4,[r0,#2]            ;165
00012e  6850              LDR      r0,[r2,#4]            ;166  ; pvPins
000130  181a              ADDS     r2,r3,r0              ;166
000132  5cc0              LDRB     r0,[r0,r3]            ;168
000134  7852              LDRB     r2,[r2,#1]            ;166
000136  eb000040          ADD      r0,r0,r0,LSL #1       ;168
00013a  2a00              CMP      r2,#0                 ;166
00013c  f8512020          LDR      r2,[r1,r0,LSL #2]     ;168
000140  6953              LDR      r3,[r2,#0x14]         ;168
000142  eb010080          ADD      r0,r1,r0,LSL #2       ;168
000146  6840              LDR      r0,[r0,#4]            ;168
000148  d001              BEQ      |L1.334|
00014a  4383              BICS     r3,r3,r0              ;167
00014c  e000              B        |L1.336|
                  |L1.334|
00014e  4303              ORRS     r3,r3,r0              ;168
                  |L1.336|
000150  6153              STR      r3,[r2,#0x14]         ;167
                  |L1.338|
000152  2001              MOVS     r0,#1                 ;170
000154  bd70              POP      {r4-r6,pc}
                  |L1.342|
000156  2120              MOVS     r1,#0x20              ;175
000158  e7e0              B        |L1.284|
;;;179    
                          ENDP

                  InitPin PROC
;;;134    // инициализация виртуального пина
;;;135    BOOL InitPin(u8 n){
00015a  b570              PUSH     {r4-r6,lr}
;;;136    	if ((*pvPins)[n].nPin < PinCount) {
00015c  4aa3              LDR      r2,|L1.1004|
00015e  4604              MOV      r4,r0                 ;135
000160  eb000544          ADD      r5,r0,r4,LSL #1
000164  6850              LDR      r0,[r2,#4]  ; pvPins
000166  5d40              LDRB     r0,[r0,r5]
000168  2824              CMP      r0,#0x24
00016a  d227              BCS      |L1.444|
;;;137    //		Msg("%d %d %d",n,(*pvPins)[n].nPin,(*pvPins)[n].Inv);
;;;138    		switch (aPin[(*pvPins)[n].nPin].DIR) {
00016c  49a1              LDR      r1,|L1.1012|
00016e  eb000040          ADD      r0,r0,r0,LSL #1
000172  eb010380          ADD      r3,r1,r0,LSL #2
000176  689e              LDR      r6,[r3,#8]
000178  b1c6              CBZ      r6,|L1.428|
00017a  2e01              CMP      r6,#1
00017c  d005              BEQ      |L1.394|
;;;139    			case DIR_OUT:
;;;140    //				Msg("O\r\n");
;;;141    				aPin[(*pvPins)[n].nPin].pPort->FIODIR |= (aPin[(*pvPins)[n].nPin].mPin);
;;;142    				(*pvPins)[n].State = 0;
;;;143    				SetPin(n);	// устанавливаем и
;;;144    				ClrPin(n); 	// сбрасываем бит
;;;145    				return TRUE;
;;;146    //				break;
;;;147    			case DIR_IN:
;;;148    //				Msg("I\r\n");
;;;149    				aPin[(*pvPins)[n].nPin].pPort->FIODIR &= ~(aPin[(*pvPins)[n].nPin].mPin);
;;;150    				return TRUE;
;;;151    //				break;
;;;152    			default : CallErrorHandler(n,0x11);
00017e  2111              MOVS     r1,#0x11
                  |L1.384|
000180  4620              MOV      r0,r4
000182  f7fffffe          BL       CallErrorHandler
;;;153    		}
;;;154    	} else {
;;;155    		CallErrorHandler(n,0x10);
;;;156    	}
;;;157    	return FALSE;
000186  2000              MOVS     r0,#0
;;;158    }
000188  bd70              POP      {r4-r6,pc}
                  |L1.394|
00018a  f8510020          LDR      r0,[r1,r0,LSL #2]     ;141
00018e  6801              LDR      r1,[r0,#0]            ;141
000190  685b              LDR      r3,[r3,#4]            ;141
000192  4319              ORRS     r1,r1,r3              ;141
000194  6001              STR      r1,[r0,#0]            ;141
000196  6851              LDR      r1,[r2,#4]            ;142  ; pvPins
000198  2000              MOVS     r0,#0                 ;142
00019a  4429              ADD      r1,r1,r5              ;142
00019c  7088              STRB     r0,[r1,#2]            ;142
00019e  4620              MOV      r0,r4                 ;143
0001a0  f7fffffe          BL       SetPin
0001a4  4620              MOV      r0,r4                 ;144
0001a6  f7fffffe          BL       ClrPin
0001aa  e005              B        |L1.440|
                  |L1.428|
0001ac  f8510020          LDR      r0,[r1,r0,LSL #2]     ;149
0001b0  6801              LDR      r1,[r0,#0]            ;149
0001b2  685a              LDR      r2,[r3,#4]            ;149
0001b4  4391              BICS     r1,r1,r2              ;149
0001b6  6001              STR      r1,[r0,#0]            ;149
                  |L1.440|
0001b8  2001              MOVS     r0,#1                 ;150
0001ba  bd70              POP      {r4-r6,pc}
                  |L1.444|
0001bc  2110              MOVS     r1,#0x10              ;155
0001be  e7df              B        |L1.384|
;;;159    // установка виртуального пина
                          ENDP

                  DefaultInitPins PROC
;;;76     // и в aPin проставлены значения направлений по умолчанию
;;;77     void DefaultInitPins(void) {
0001c0  b570              PUSH     {r4-r6,lr}
;;;78     	u16 i = 0;
;;;79     	for (i = 0; i < VIRTUAL_PINTAB_SIZE; i++) {
;;;80     		if ((*pvPins)[i].nPin !=0xFF) {
0001c2  4d8a              LDR      r5,|L1.1004|
;;;81     			if (aPin[(*pvPins)[i].nPin].DIR!=0xFF) InitPin(i);
0001c4  4e8b              LDR      r6,|L1.1012|
0001c6  2400              MOVS     r4,#0                 ;78
                  |L1.456|
0001c8  6869              LDR      r1,[r5,#4]            ;80  ; pvPins
0001ca  eb040044          ADD      r0,r4,r4,LSL #1       ;80
0001ce  5c08              LDRB     r0,[r1,r0]            ;80
0001d0  28ff              CMP      r0,#0xff              ;80
0001d2  d009              BEQ      |L1.488|
0001d4  eb000040          ADD      r0,r0,r0,LSL #1
0001d8  eb060080          ADD      r0,r6,r0,LSL #2
0001dc  6880              LDR      r0,[r0,#8]
0001de  28ff              CMP      r0,#0xff
0001e0  d002              BEQ      |L1.488|
0001e2  b2e0              UXTB     r0,r4
0001e4  f7fffffe          BL       InitPin
                  |L1.488|
0001e8  1c64              ADDS     r4,r4,#1
0001ea  b2a4              UXTH     r4,r4                 ;79
0001ec  2c24              CMP      r4,#0x24              ;79
0001ee  d3eb              BCC      |L1.456|
;;;82     		}
;;;83     	}
;;;84     }
0001f0  bd70              POP      {r4-r6,pc}
;;;85     
                          ENDP

                  FormQPinTable PROC
;;;86     // формирование таблицы для бытрого доступа к пинам
;;;87     void 	FormQPinTable(void){
0001f2  b5f0              PUSH     {r4-r7,lr}
;;;88     	u16 i = 0,ofs;
;;;89     	for (i = 0; i < VIRTUAL_PINTAB_SIZE; i++) {
;;;90     		// фиксируем смещение в таблице статических пинов 
;;;91     		// чтобы не таскать по всему алгоритму
;;;92     		ofs = (*pvPins)[i].nPin; 
0001f4  497d              LDR      r1,|L1.1004|
;;;93     		// уравниваем инверсии
;;;94     		aVQPIN[i].Inv = (*pvPins)[i].Inv;
;;;95     		if (aVQPIN[i].Inv) {
;;;96     			aVQPIN[i].ClrAddr = &(aPin[ofs].pPort->FIOSET);
0001f6  4a7f              LDR      r2,|L1.1012|
0001f8  2000              MOVS     r0,#0                 ;88
0001fa  684e              LDR      r6,[r1,#4]            ;94  ; pvPins
0001fc  497f              LDR      r1,|L1.1020|
0001fe  bf00              NOP                            ;92
                  |L1.512|
000200  eb000340          ADD      r3,r0,r0,LSL #1       ;92
000204  eb000780          ADD      r7,r0,r0,LSL #2       ;94
000208  5cf4              LDRB     r4,[r6,r3]            ;92
00020a  4433              ADD      r3,r3,r6              ;94
00020c  785d              LDRB     r5,[r3,#1]            ;94
00020e  eb010387          ADD      r3,r1,r7,LSL #2       ;94
000212  2d00              CMP      r5,#0                 ;95
000214  611d              STR      r5,[r3,#0x10]         ;95
;;;97     			aVQPIN[i].SetAddr = &(aPin[ofs].pPort->FIOCLR);
;;;98     		}	else {
;;;99     			aVQPIN[i].ClrAddr = &(aPin[ofs].pPort->FIOCLR);
000216  eb040544          ADD      r5,r4,r4,LSL #1
00021a  f8525025          LDR      r5,[r2,r5,LSL #2]
00021e  d005              BEQ      |L1.556|
000220  f1050c18          ADD      r12,r5,#0x18          ;96
000224  351c              ADDS     r5,r5,#0x1c           ;96
000226  f8c3c004          STR      r12,[r3,#4]           ;97
00022a  e004              B        |L1.566|
                  |L1.556|
00022c  f1050c1c          ADD      r12,r5,#0x1c
000230  3518              ADDS     r5,r5,#0x18
000232  f8c3c004          STR      r12,[r3,#4]
                  |L1.566|
;;;100    			aVQPIN[i].SetAddr = &(aPin[ofs].pPort->FIOSET);
;;;101    		}
;;;102    		aVQPIN[i].GetAddr = &(aPin[ofs].pPort->FIOPIN);
000236  eb040444          ADD      r4,r4,r4,LSL #1
00023a  f8415027          STR      r5,[r1,r7,LSL #2]     ;100
00023e  f8525024          LDR      r5,[r2,r4,LSL #2]
;;;103    		aVQPIN[i].Mask = aPin[ofs].mPin;
000242  eb020484          ADD      r4,r2,r4,LSL #2
000246  3514              ADDS     r5,r5,#0x14           ;102
000248  609d              STR      r5,[r3,#8]
00024a  1c40              ADDS     r0,r0,#1
00024c  6864              LDR      r4,[r4,#4]
00024e  b280              UXTH     r0,r0                 ;89
000250  60dc              STR      r4,[r3,#0xc]          ;89
000252  2824              CMP      r0,#0x24              ;89
000254  d3d4              BCC      |L1.512|
;;;104    	}
;;;105    }	
000256  bdf0              POP      {r4-r7,pc}
;;;106    
                          ENDP

                  QSetPin PROC
;;;179    
;;;180    void QSetPin(u8 n){
000258  eb000140          ADD      r1,r0,r0,LSL #1
;;;181    	if (!(*pvPins)[n].State) { 	//*
00025c  4863              LDR      r0,|L1.1004|
00025e  6842              LDR      r2,[r0,#4]  ; pvPins
000260  440a              ADD      r2,r2,r1
000262  7893              LDRB     r3,[r2,#2]
000264  2b00              CMP      r3,#0                 ;180
000266  d10f              BNE      |L1.648|
;;;182    		(*pvPins)[n].State = 1;		//*
000268  2301              MOVS     r3,#1
00026a  7093              STRB     r3,[r2,#2]
;;;183    		if ((*pvPins)[n].Inv) 
00026c  6842              LDR      r2,[r0,#4]  ; pvPins
00026e  1888              ADDS     r0,r1,r2
;;;184    		     aPin[(*pvPins)[n].nPin].pPort->FIOCLR = aPin[(*pvPins)[n].nPin].mPin;
;;;185    	   	else aPin[(*pvPins)[n].nPin].pPort->FIOSET =  aPin[(*pvPins)[n].nPin].mPin;
000270  5c51              LDRB     r1,[r2,r1]
000272  7843              LDRB     r3,[r0,#1]            ;183
000274  485f              LDR      r0,|L1.1012|
000276  eb010141          ADD      r1,r1,r1,LSL #1
00027a  eb000281          ADD      r2,r0,r1,LSL #2
00027e  f8500021          LDR      r0,[r0,r1,LSL #2]
000282  6852              LDR      r2,[r2,#4]
000284  b10b              CBZ      r3,|L1.650|
000286  61c2              STR      r2,[r0,#0x1c]         ;184
                  |L1.648|
;;;186    	}														//*
;;;187    }
000288  4770              BX       lr
                  |L1.650|
00028a  6182              STR      r2,[r0,#0x18]         ;185
00028c  4770              BX       lr
;;;188    
                          ENDP

                  Q1SetPin PROC
;;;189    void Q1SetPin(u8 n){
00028e  eb000180          ADD      r1,r0,r0,LSL #2
;;;190    		*(aVQPIN[n].SetAddr) = aVQPIN[n].Mask;
000292  485a              LDR      r0,|L1.1020|
000294  eb000281          ADD      r2,r0,r1,LSL #2
000298  f8500021          LDR      r0,[r0,r1,LSL #2]
00029c  68d2              LDR      r2,[r2,#0xc]
00029e  6002              STR      r2,[r0,#0]
;;;191    }
0002a0  4770              BX       lr
;;;192    // сброс виртуального пина
                          ENDP

                  QClrPin PROC
;;;214    
;;;215    void QClrPin(u8 n){
0002a2  4a52              LDR      r2,|L1.1004|
;;;216    	if ((*pvPins)[n].State) {
0002a4  eb000140          ADD      r1,r0,r0,LSL #1
0002a8  6850              LDR      r0,[r2,#4]  ; pvPins
0002aa  4408              ADD      r0,r0,r1
0002ac  7883              LDRB     r3,[r0,#2]
0002ae  2b00              CMP      r3,#0                 ;215
0002b0  d014              BEQ      |L1.732|
;;;217    		(*pvPins)[n].State = 0;
0002b2  2300              MOVS     r3,#0
0002b4  7083              STRB     r3,[r0,#2]
;;;218    		if ((*pvPins)[n].Inv) 
0002b6  6852              LDR      r2,[r2,#4]  ; pvPins
0002b8  1888              ADDS     r0,r1,r2
;;;219    			// инверсия
;;;220    			aPin[(*pvPins)[n].nPin].pPort->FIOPIN |=  (aPin[(*pvPins)[n].nPin].mPin);
;;;221    	   	else
;;;222    			aPin[(*pvPins)[n].nPin].pPort->FIOPIN &= ~(aPin[(*pvPins)[n].nPin].mPin);
0002ba  5c51              LDRB     r1,[r2,r1]
0002bc  7843              LDRB     r3,[r0,#1]            ;218
0002be  484d              LDR      r0,|L1.1012|
0002c0  eb010141          ADD      r1,r1,r1,LSL #1
0002c4  2b00              CMP      r3,#0                 ;218
0002c6  f8502021          LDR      r2,[r0,r1,LSL #2]
0002ca  6953              LDR      r3,[r2,#0x14]
0002cc  eb000081          ADD      r0,r0,r1,LSL #2
0002d0  6840              LDR      r0,[r0,#4]
0002d2  d001              BEQ      |L1.728|
0002d4  4303              ORRS     r3,r3,r0              ;220
0002d6  e000              B        |L1.730|
                  |L1.728|
0002d8  4383              BICS     r3,r3,r0
                  |L1.730|
0002da  6153              STR      r3,[r2,#0x14]
                  |L1.732|
;;;223    	}
;;;224    }
0002dc  4770              BX       lr
;;;225    
                          ENDP

                  Q1ClrPin PROC
;;;226    void Q1ClrPin(u8 n){
0002de  eb000180          ADD      r1,r0,r0,LSL #2
;;;227    		*(aVQPIN[n].ClrAddr) = aVQPIN[n].Mask;
0002e2  4846              LDR      r0,|L1.1020|
0002e4  eb000081          ADD      r0,r0,r1,LSL #2
0002e8  68c1              LDR      r1,[r0,#0xc]
0002ea  6840              LDR      r0,[r0,#4]
0002ec  6001              STR      r1,[r0,#0]
;;;228    }
0002ee  4770              BX       lr
;;;229    
                          ENDP

                  GetPin PROC
;;;230    u32 GetPin(u8 n){
0002f0  e92d41f0          PUSH     {r4-r8,lr}
;;;231    	if ((*pvPins)[n].nPin!=0xFF) { // инициализация виртуального пина
0002f4  493d              LDR      r1,|L1.1004|
0002f6  eb000240          ADD      r2,r0,r0,LSL #1
0002fa  684e              LDR      r6,[r1,#4]  ; pvPins
0002fc  5cb3              LDRB     r3,[r6,r2]
0002fe  2bff              CMP      r3,#0xff
000300  d02f              BEQ      |L1.866|
;;;232    		if(aPin[(*pvPins)[n].nPin].DIR==DIR_IN) // направление инициализации статического пина
000302  eb030543          ADD      r5,r3,r3,LSL #1
000306  4b3b              LDR      r3,|L1.1012|
000308  eb030485          ADD      r4,r3,r5,LSL #2
00030c  68a7              LDR      r7,[r4,#8]
00030e  b14f              CBZ      r7,|L1.804|
;;;233    		{
;;;234    			if ((*pvPins)[n].Inv) {
;;;235    				// инверсия
;;;236    //				return (~(aPin[(*pvPins)[n].nPin].pPort->FIOPIN) & aPin[(*pvPins)[n].nPin].mPin);
;;;237    				if (~(aPin[(*pvPins)[n].nPin].pPort->FIOPIN) & aPin[(*pvPins)[n].nPin].mPin) 
;;;238    				 	 (*pvPins)[n].State = 1;
;;;239    				else (*pvPins)[n].State = 0;
;;;240    				return (*pvPins)[n].State;
;;;241    			} else {
;;;242    //				return (aPin[(*pvPins)[n].nPin].pPort->FIOPIN & aPin[(*pvPins)[n].nPin].mPin);
;;;243    				if (aPin[(*pvPins)[n].nPin].pPort->FIOPIN & aPin[(*pvPins)[n].nPin].mPin) 
;;;244    				 	 (*pvPins)[n].State = 1;
;;;245    				else (*pvPins)[n].State = 0;
;;;246    				return (*pvPins)[n].State;
;;;247    			}
;;;248    		} else {
;;;249    			if(aPin[(*pvPins)[n].nPin].DIR==DIR_OUT) { 
000310  2f01              CMP      r7,#1
000312  d023              BEQ      |L1.860|
;;;250    				return (*pvPins)[n].State;
;;;251    			} else CallErrorHandler(n,0x41);
000314  f05f0141          MOVS.W   r1,#0x41
                  |L1.792|
000318  f7fffffe          BL       CallErrorHandler
;;;252    		}
;;;253    	} else {
;;;254    		CallErrorHandler(n,0x40);
;;;255    	}
;;;256    	return 0xFFFFFFFF; 
00031c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.800|
;;;257    }
000320  e8bd81f0          POP      {r4-r8,pc}
                  |L1.804|
000324  1990              ADDS     r0,r2,r6              ;234
000326  2600              MOVS     r6,#0                 ;234
000328  f890c001          LDRB     r12,[r0,#1]           ;234
00032c  2701              MOVS     r7,#1                 ;238
00032e  f1bc0f00          CMP      r12,#0                ;234
000332  d009              BEQ      |L1.840|
000334  f8533025          LDR      r3,[r3,r5,LSL #2]     ;237
000338  6864              LDR      r4,[r4,#4]            ;237
00033a  695b              LDR      r3,[r3,#0x14]         ;237
00033c  439c              BICS     r4,r4,r3              ;237
00033e  d109              BNE      |L1.852|
000340  e00a              B        |L1.856|
                  |L1.834|
000342  6848              LDR      r0,[r1,#4]            ;240  ; pvPins
000344  4410              ADD      r0,r0,r2              ;240
000346  e00a              B        |L1.862|
                  |L1.840|
000348  f8533025          LDR      r3,[r3,r5,LSL #2]     ;243
00034c  695b              LDR      r3,[r3,#0x14]         ;243
00034e  6864              LDR      r4,[r4,#4]            ;243
000350  4223              TST      r3,r4                 ;243
000352  d001              BEQ      |L1.856|
                  |L1.852|
000354  7087              STRB     r7,[r0,#2]            ;244
000356  e7f4              B        |L1.834|
                  |L1.856|
000358  7086              STRB     r6,[r0,#2]            ;245
00035a  e7f2              B        |L1.834|
                  |L1.860|
00035c  1990              ADDS     r0,r2,r6              ;250
                  |L1.862|
00035e  7880              LDRB     r0,[r0,#2]            ;250
000360  e7de              B        |L1.800|
                  |L1.866|
000362  2140              MOVS     r1,#0x40              ;254
000364  e7d8              B        |L1.792|
;;;258    
                          ENDP

                  Drebezg PROC
;;;259    void	Drebezg(u8 n){
000366  b5f0              PUSH     {r4-r7,lr}
;;;260    	if (((*pvPins)[n].State)!=(adrb[n].DState)) {
000368  4920              LDR      r1,|L1.1004|
00036a  eb000240          ADD      r2,r0,r0,LSL #1
00036e  2500              MOVS     r5,#0
000370  6849              LDR      r1,[r1,#4]  ; pvPins
;;;261    		if (StartedTime(adrb[n].iTime)) {
000372  4b23              LDR      r3,|L1.1024|
000374  4411              ADD      r1,r1,r2              ;260
000376  4a1d              LDR      r2,|L1.1004|
000378  788c              LDRB     r4,[r1,#2]            ;260
00037a  3208              ADDS     r2,r2,#8              ;260
00037c  4611              MOV      r1,r2                 ;260
00037e  eb010140          ADD      r1,r1,r0,LSL #1       ;260
000382  f8126010          LDRB     r6,[r2,r0,LSL #1]     ;260
000386  7849              LDRB     r1,[r1,#1]
000388  42b4              CMP      r4,r6                 ;260
00038a  d015              BEQ      |L1.952|
00038c  f8536021          LDR      r6,[r3,r1,LSL #2]
000390  b1ae              CBZ      r6,|L1.958|
;;;262    			// время запущено
;;;263    			if (GetTime(adrb[n].iTime) > tiMksToTick((*pDrDelay)*100)) { 
000392  4e1c              LDR      r6,|L1.1028|
000394  2764              MOVS     r7,#0x64
000396  6836              LDR      r6,[r6,#0]  ; pDrDelay
000398  f9b66000          LDRSH    r6,[r6,#0]
00039c  437e              MULS     r6,r7,r6
00039e  2732              MOVS     r7,#0x32
0003a0  fb96f6f7          SDIV     r6,r6,r7
0003a4  f8537021          LDR      r7,[r3,r1,LSL #2]
0003a8  b117              CBZ      r7,|L1.944|
0003aa  f8537021          LDR      r7,[r3,r1,LSL #2]
0003ae  1e7f              SUBS     r7,r7,#1
                  |L1.944|
0003b0  42be              CMP      r6,r7
0003b2  d203              BCS      |L1.956|
;;;264    				// промежуток выполнен
;;;265    				// уравниваем состояния
;;;266    				adrb[n].DState = (*pvPins)[n].State;
0003b4  f8024010          STRB     r4,[r2,r0,LSL #1]
                  |L1.952|
;;;267    				// останавливаем время
;;;268    				StopTime(adrb[n].iTime);
;;;269    			}
;;;270    		} else {
;;;271    			// время не запущено запускаем
;;;272    			StartTime(adrb[n].iTime);
;;;273    			// и ничего не делаем
;;;274    		}
;;;275    	} else {
;;;276    		// при равенстве State и DState останавливаем время
;;;277    		StopTime(adrb[n].iTime);
0003b8  f8435021          STR      r5,[r3,r1,LSL #2]
                  |L1.956|
;;;278    	} 
;;;279    
;;;280    	// заглушка чтобы работало по старому
;;;281    	//(*pvPins)[n].DState = (*pvPins)[n].State;
;;;282    }
0003bc  bdf0              POP      {r4-r7,pc}
                  |L1.958|
0003be  2001              MOVS     r0,#1                 ;272
0003c0  f8430021          STR      r0,[r3,r1,LSL #2]     ;272
0003c4  bdf0              POP      {r4-r7,pc}
;;;283    
                          ENDP

                  QGetPin PROC
;;;284    u32 QGetPin(u8 n){
0003c6  b5f0              PUSH     {r4-r7,lr}
0003c8  4604              MOV      r4,r0
;;;285    	if (aPin[(*pvPins)[n].nPin].DIR==DIR_IN) {
0003ca  eb000544          ADD      r5,r0,r4,LSL #1
0003ce  4807              LDR      r0,|L1.1004|
0003d0  4a08              LDR      r2,|L1.1012|
0003d2  6841              LDR      r1,[r0,#4]  ; pvPins
0003d4  5d48              LDRB     r0,[r1,r5]
0003d6  eb000340          ADD      r3,r0,r0,LSL #1
0003da  eb020083          ADD      r0,r2,r3,LSL #2
0003de  6886              LDR      r6,[r0,#8]            ;284
0003e0  b196              CBZ      r6,|L1.1032|
;;;286    		// опрос входного пина
;;;287    		if ((*pvPins)[n].Inv) {
;;;288    			// инверсия
;;;289    //			return (~(aPin[(*pvPins)[n].nPin].pPort->FIOPIN) & aPin[(*pvPins)[n].nPin].mPin);
;;;290    			if (~(aPin[(*pvPins)[n].nPin].pPort->FIOPIN) & aPin[(*pvPins)[n].nPin].mPin) 
;;;291    			 	 (*pvPins)[n].State = 1;
;;;292    			else (*pvPins)[n].State = 0;
;;;293    			// алгоритм дребезга
;;;294    			Drebezg(n);
;;;295    			return adrb[n].DState;
;;;296    		} else {
;;;297    //			return (aPin[(*pvPins)[n].nPin].pPort->FIOPIN & aPin[(*pvPins)[n].nPin].mPin);
;;;298    			if (aPin[(*pvPins)[n].nPin].pPort->FIOPIN & aPin[(*pvPins)[n].nPin].mPin) 
;;;299    			 	 (*pvPins)[n].State = 1;
;;;300    			else (*pvPins)[n].State = 0;
;;;301    			// алгоритм дребезга
;;;302    			Drebezg(n);
;;;303    			return adrb[n].DState;
;;;304    		}
;;;305    	} else {
;;;306    		if (aPin[(*pvPins)[n].nPin].DIR==DIR_OUT) {
0003e2  2e01              CMP      r6,#1
0003e4  d02f              BEQ      |L1.1094|
;;;307    			// опрос выходного пина
;;;308    			return (*pvPins)[n].State;
;;;309    		} else return 0;
0003e6  2000              MOVS     r0,#0
                  |L1.1000|
;;;310    	}
;;;311    }
0003e8  bdf0              POP      {r4-r7,pc}
0003ea  0000              DCW      0x0000
                  |L1.1004|
                          DCD      ||.data||
                  |L1.1008|
                          DCD      ||.bss||+0x2d0
                  |L1.1012|
                          DCD      aPin
                  |L1.1016|
                          DCD      0x2009c000
                  |L1.1020|
                          DCD      ||.bss||
                  |L1.1024|
                          DCD      time
                  |L1.1028|
                          DCD      pDrDelay
                  |L1.1032|
000408  4429              ADD      r1,r1,r5              ;287
00040a  2600              MOVS     r6,#0                 ;287
00040c  f891c001          LDRB     r12,[r1,#1]           ;287
000410  2701              MOVS     r7,#1                 ;291
000412  4d4b              LDR      r5,|L1.1344|
000414  f1bc0f00          CMP      r12,#0                ;287
000418  d00e              BEQ      |L1.1080|
00041a  f8522023          LDR      r2,[r2,r3,LSL #2]     ;290
00041e  6840              LDR      r0,[r0,#4]            ;290
000420  6952              LDR      r2,[r2,#0x14]         ;290
000422  4390              BICS     r0,r0,r2              ;290
000424  d001              BEQ      |L1.1066|
                  |L1.1062|
000426  708f              STRB     r7,[r1,#2]            ;291
000428  e000              B        |L1.1068|
                  |L1.1066|
00042a  708e              STRB     r6,[r1,#2]            ;292
                  |L1.1068|
00042c  4620              MOV      r0,r4                 ;302
00042e  f7fffffe          BL       Drebezg
000432  f8150014          LDRB     r0,[r5,r4,LSL #1]     ;303
000436  e7d7              B        |L1.1000|
                  |L1.1080|
000438  f8522023          LDR      r2,[r2,r3,LSL #2]     ;298
00043c  6952              LDR      r2,[r2,#0x14]         ;298
00043e  6840              LDR      r0,[r0,#4]            ;298
000440  4202              TST      r2,r0                 ;298
000442  d0f2              BEQ      |L1.1066|
000444  e7ef              B        |L1.1062|
                  |L1.1094|
000446  1868              ADDS     r0,r5,r1              ;308
000448  7880              LDRB     r0,[r0,#2]            ;308
00044a  e7cd              B        |L1.1000|
;;;312    
                          ENDP

                  Q1GetPin PROC
;;;313    u32 Q1GetPin(u8 n){
00044c  eb000180          ADD      r1,r0,r0,LSL #2
;;;314    	// без дребезга !!!
;;;315    	if (aVQPIN[n].Inv) {
000450  483c              LDR      r0,|L1.1348|
000452  eb000181          ADD      r1,r0,r1,LSL #2
000456  3108              ADDS     r1,r1,#8
000458  c907              LDM      r1,{r0-r2}
;;;316    		return !(*(aVQPIN[n].GetAddr) & aVQPIN[n].Mask); 
;;;317    	} else {
;;;318    		return (*(aVQPIN[n].GetAddr) & aVQPIN[n].Mask); 
00045a  6800              LDR      r0,[r0,#0]
00045c  2a00              CMP      r2,#0                 ;313
00045e  ea000001          AND      r0,r0,r1
000462  d001              BEQ      |L1.1128|
000464  b108              CBZ      r0,|L1.1130|
000466  2000              MOVS     r0,#0                 ;316
                  |L1.1128|
;;;319    	}
;;;320    }
000468  4770              BX       lr
                  |L1.1130|
00046a  2001              MOVS     r0,#1                 ;316
00046c  4770              BX       lr
;;;321    
                          ENDP

                  ClrGetPin PROC
;;;322    void ClrGetPin(u8 n){
00046e  4b34              LDR      r3,|L1.1344|
;;;323    	(*pvPins)[n].State = 0;
000470  2100              MOVS     r1,#0
000472  3b08              SUBS     r3,r3,#8
000474  eb000240          ADD      r2,r0,r0,LSL #1
000478  685b              LDR      r3,[r3,#4]  ; pvPins
00047a  441a              ADD      r2,r2,r3
00047c  7091              STRB     r1,[r2,#2]
;;;324    	adrb[n].DState = 0;	
00047e  4a30              LDR      r2,|L1.1344|
000480  f8021010          STRB     r1,[r2,r0,LSL #1]
;;;325    }	
000484  4770              BX       lr
;;;326    // следующий набор функций реализован на всякий случай
                          ENDP

                  GetPinDir PROC
;;;327    // чтение направления виртуального пина
;;;328    u8 GetPinDir(u8 n){
000486  492e              LDR      r1,|L1.1344|
000488  b510              PUSH     {r4,lr}
;;;329    	if ((*pvPins)[n].nPin!=0xFF) {
00048a  3908              SUBS     r1,r1,#8
00048c  eb000240          ADD      r2,r0,r0,LSL #1
000490  6849              LDR      r1,[r1,#4]  ; pvPins
000492  5c89              LDRB     r1,[r1,r2]
000494  29ff              CMP      r1,#0xff
000496  d006              BEQ      |L1.1190|
;;;330    		// пин используется - возвращаем направление
;;;331    		return (aPin[(*pvPins)[n].nPin].DIR);
000498  eb010041          ADD      r0,r1,r1,LSL #1
00049c  492a              LDR      r1,|L1.1352|
00049e  eb010080          ADD      r0,r1,r0,LSL #2
0004a2  7a00              LDRB     r0,[r0,#8]
;;;332    	} else {
;;;333    		CallErrorHandler(n,0x50);
;;;334    	}
;;;335    	return 0xFF;
;;;336    }
0004a4  bd10              POP      {r4,pc}
                  |L1.1190|
0004a6  2150              MOVS     r1,#0x50              ;333
0004a8  f7fffffe          BL       CallErrorHandler
0004ac  20ff              MOVS     r0,#0xff              ;335
0004ae  bd10              POP      {r4,pc}
;;;337    
                          ENDP

                  GetPinInv PROC
;;;338    u8 GetPinInv(u8 n){
0004b0  4923              LDR      r1,|L1.1344|
0004b2  b510              PUSH     {r4,lr}
;;;339    	if ((*pvPins)[n].nPin!=0xFF) {
0004b4  3908              SUBS     r1,r1,#8
0004b6  eb000240          ADD      r2,r0,r0,LSL #1
0004ba  6849              LDR      r1,[r1,#4]  ; pvPins
0004bc  5c8b              LDRB     r3,[r1,r2]
0004be  2bff              CMP      r3,#0xff
0004c0  d002              BEQ      |L1.1224|
;;;340    		// пин используется
;;;341    		return ((*pvPins)[n].Inv); // возвращвем инверсию
0004c2  1850              ADDS     r0,r2,r1
0004c4  7840              LDRB     r0,[r0,#1]
;;;342    	} else {
;;;343    		CallErrorHandler(n,0x70);
;;;344    	}
;;;345    	return 0xFF;
;;;346    }
0004c6  bd10              POP      {r4,pc}
                  |L1.1224|
0004c8  2170              MOVS     r1,#0x70              ;343
0004ca  f7fffffe          BL       CallErrorHandler
0004ce  20ff              MOVS     r0,#0xff              ;345
0004d0  bd10              POP      {r4,pc}
;;;347    
                          ENDP

                  SetPinInv PROC
;;;348    void SetPinInv(u8 n,u8 i){
0004d2  b570              PUSH     {r4-r6,lr}
;;;349    	if ((*pvPins)[n].nPin!=0xFF) {
0004d4  4a1a              LDR      r2,|L1.1344|
0004d6  4605              MOV      r5,r0                 ;348
0004d8  3a08              SUBS     r2,r2,#8
0004da  eb000345          ADD      r3,r0,r5,LSL #1
0004de  6850              LDR      r0,[r2,#4]  ; pvPins
0004e0  5cc4              LDRB     r4,[r0,r3]
0004e2  2cff              CMP      r4,#0xff
0004e4  d01e              BEQ      |L1.1316|
;;;350    		// пин используется
;;;351    		if (aPin[(*pvPins)[n].nPin].DIR!=0xFF) {
0004e6  eb040644          ADD      r6,r4,r4,LSL #1
0004ea  4c17              LDR      r4,|L1.1352|
0004ec  eb040686          ADD      r6,r4,r6,LSL #2
0004f0  68b6              LDR      r6,[r6,#8]
0004f2  2eff              CMP      r6,#0xff
0004f4  d011              BEQ      |L1.1306|
;;;352    			// пин инициализирован
;;;353    			(*pvPins)[n].Inv = i; // изменяем значение инверсии
0004f6  4418              ADD      r0,r0,r3
0004f8  7041              STRB     r1,[r0,#1]
;;;354    			if (aPin[(*pvPins)[n].nPin].DIR==DIR_OUT) {
0004fa  6850              LDR      r0,[r2,#4]  ; pvPins
0004fc  5cc0              LDRB     r0,[r0,r3]
0004fe  eb000040          ADD      r0,r0,r0,LSL #1
000502  eb040080          ADD      r0,r4,r0,LSL #2
000506  6880              LDR      r0,[r0,#8]
000508  2801              CMP      r0,#1
00050a  d10d              BNE      |L1.1320|
;;;355    				// если пин выходной
;;;356    				// устанавливаем и сбрасываем его
;;;357    				// тогда поле State примет корректное значение
;;;358    				QSetPin(n);		  
00050c  4628              MOV      r0,r5
00050e  f7fffffe          BL       QSetPin
;;;359    				QClrPin(n);
000512  4628              MOV      r0,r5
000514  e8bd4070          POP      {r4-r6,lr}
000518  e7fe              B        QClrPin
                  |L1.1306|
;;;360    			}
;;;361    		} else { 
;;;362    	 		CallErrorHandler(n,0x82);
00051a  2182              MOVS     r1,#0x82
                  |L1.1308|
;;;363    		}
;;;364    	} else {
;;;365    		// ошибка
;;;366    		CallErrorHandler(n,0x80);
00051c  4628              MOV      r0,r5
00051e  e8bd4070          POP      {r4-r6,lr}
000522  e7fe              B        CallErrorHandler
                  |L1.1316|
000524  2180              MOVS     r1,#0x80
000526  e7f9              B        |L1.1308|
                  |L1.1320|
;;;367    	}
;;;368    }
000528  bd70              POP      {r4-r6,pc}
;;;369    
                          ENDP

                  InitVirtualPins PROC
;;;370    void InitVirtualPins (void) {
00052a  b510              PUSH     {r4,lr}
;;;371    	u8 i;
;;;372    	for (i=0;i<PinCount;i++) InitPin(i);
00052c  2400              MOVS     r4,#0
                  |L1.1326|
00052e  4620              MOV      r0,r4
000530  f7fffffe          BL       InitPin
000534  1c64              ADDS     r4,r4,#1
000536  b2e4              UXTB     r4,r4
000538  2c24              CMP      r4,#0x24
00053a  d3f8              BCC      |L1.1326|
;;;373    }
00053c  bd10              POP      {r4,pc}
;;;374    
                          ENDP

00053e  0000              DCW      0x0000
                  |L1.1344|
                          DCD      ||.data||+0x8
                  |L1.1348|
                          DCD      ||.bss||
                  |L1.1352|
                          DCD      aPin

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  aVQPIN
                          %        720
                  ||pe||
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  pErrHandler
                          DCD      0x00000000
                  pvPins
                          DCD      0x00000000
                  adrb
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  00000000          DCB      0x00,0x00,0x00,0x00
000018  00000000          DCB      0x00,0x00,0x00,0x00
00001c  00000000          DCB      0x00,0x00,0x00,0x00
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  00000000          DCB      0x00,0x00,0x00,0x00
000028  00000000          DCB      0x00,0x00,0x00,0x00
00002c  00000000          DCB      0x00,0x00,0x00,0x00
000030  000b000c          DCB      0x00,0x0b,0x00,0x0c
000034  000d000e          DCB      0x00,0x0d,0x00,0x0e
000038  00100011          DCB      0x00,0x10,0x00,0x11
00003c  00120013          DCB      0x00,0x12,0x00,0x13
000040  00140015          DCB      0x00,0x14,0x00,0x15
000044  00160017          DCB      0x00,0x16,0x00,0x17
000048  00180019          DCB      0x00,0x18,0x00,0x19
00004c  001a001b          DCB      0x00,0x1a,0x00,0x1b

;*** Start embedded assembler ***

#line 1 "UCNC\\VirtualPins.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_VirtualPins_c_adrb____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_VirtualPins_c_adrb____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_VirtualPins_c_adrb____REVSH|
#line 462
|__asm___13_VirtualPins_c_adrb____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_VirtualPins_c_adrb____RRX|
#line 649
|__asm___13_VirtualPins_c_adrb____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
