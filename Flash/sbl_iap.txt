; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\flash\sbl_iap.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\sbl_iap.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\Drivers\include -I.\Common -I.\Retarget -ID:\Projects\Frezer\Frezer.keil\01020124\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\LPC1700_DFP\2.3.0\Device\Include -D__UVISION_VERSION=517 -D_RTE_ -DLPC175x_6x --omf_browse=.\flash\sbl_iap.crf Drivers\sbl_iap.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  enable_interrupts PROC
;;;152    
;;;153    void enable_interrupts(uint32_t interrupts)
000000  b662              CPSIE    i
;;;154    {
;;;155        __enable_irq();
;;;156    }
000002  4770              BX       lr
;;;157    
                          ENDP

                  iap_entry PROC
;;;144    
;;;145    void iap_entry(uint32_t param_tab[],uint32_t result_tab[])
000004  4a59              LDR      r2,|L1.364|
;;;146    {
;;;147        void (*iap)(uint32_t [],uint32_t []);
;;;148    
;;;149        iap = (void (*)(uint32_t [],uint32_t []))IAP_ADDRESS;
;;;150        iap(param_tab,result_tab);
000006  4710              BX       r2
;;;151    }
;;;152    
                          ENDP

                  disable_interrupts PROC
;;;157    
;;;158    void disable_interrupts(uint32_t interrupts)
000008  b672              CPSID    i
;;;159    {
;;;160        __disable_irq();
;;;161    }
00000a  4770              BX       lr
;;;162    
                          ENDP

                  write_data PROC
;;;112    
;;;113    void write_data(uint32_t flash_address,uint32_t * flash_data_buf, uint32_t count)
00000c  b510              PUSH     {r4,lr}
00000e  b672              CPSID    i
;;;114    {
;;;115        uint32_t interrupts;
;;;116    
;;;117    	disable_interrupts(interrupts);
;;;118        param_table[0] = COPY_RAM_TO_FLASH;
000010  2433              MOVS     r4,#0x33
000012  4b57              LDR      r3,|L1.368|
000014  c310              STM      r3!,{r4}  ; param_table
000016  c307              STM      r3!,{r0-r2}
;;;119        param_table[1] = flash_address;
;;;120        param_table[2] = (uint32_t)flash_data_buf;
;;;121        param_table[3] = count;
;;;122        param_table[4] = SystemCoreClock/1000;
000018  4856              LDR      r0,|L1.372|
00001a  f44f717a          MOV      r1,#0x3e8
00001e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000020  fbb0f0f1          UDIV     r0,r0,r1
;;;123        iap_entry(param_table,result_table);
000024  6018              STR      r0,[r3,#0]  ; param_table
000026  1d19              ADDS     r1,r3,#4
000028  4851              LDR      r0,|L1.368|
00002a  f7fffffe          BL       iap_entry
00002e  b662              CPSIE    i
;;;124    	enable_interrupts(interrupts);
;;;125    }
000030  bd10              POP      {r4,pc}
;;;126    
                          ENDP

                  prepare_sector PROC
;;;135    
;;;136    void prepare_sector(uint32_t start_sector,uint32_t end_sector)
000032  4a4f              LDR      r2,|L1.368|
;;;137    {
;;;138        param_table[0] = PREPARE_SECTOR_FOR_WRITE;
000034  2332              MOVS     r3,#0x32
000036  6013              STR      r3,[r2,#0]  ; param_table
000038  e9c20101          STRD     r0,r1,[r2,#4]
;;;139        param_table[1] = start_sector;
;;;140        param_table[2] = end_sector;
;;;141        param_table[3] = SystemCoreClock/1000;
00003c  484d              LDR      r0,|L1.372|
00003e  f44f717a          MOV      r1,#0x3e8
000042  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000044  fbb0f0f1          UDIV     r0,r0,r1
;;;142        iap_entry(param_table,result_table);
000048  60d0              STR      r0,[r2,#0xc]  ; param_table
00004a  f1020114          ADD      r1,r2,#0x14
00004e  4610              MOV      r0,r2
000050  e7fe              B        iap_entry
;;;143    }
;;;144    
                          ENDP

                  erase_sector PROC
;;;126    
;;;127    void erase_sector(uint32_t start_sector,uint32_t end_sector)
000052  4a47              LDR      r2,|L1.368|
;;;128    {
;;;129        param_table[0] = ERASE_SECTOR;
000054  2334              MOVS     r3,#0x34
000056  6013              STR      r3,[r2,#0]  ; param_table
000058  e9c20101          STRD     r0,r1,[r2,#4]
;;;130        param_table[1] = start_sector;
;;;131        param_table[2] = end_sector;
;;;132        param_table[3] = SystemCoreClock/1000;
00005c  4845              LDR      r0,|L1.372|
00005e  f44f717a          MOV      r1,#0x3e8
000062  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000064  fbb0f0f1          UDIV     r0,r0,r1
;;;133        iap_entry(param_table,result_table);
000068  60d0              STR      r0,[r2,#0xc]  ; param_table
00006a  f1020114          ADD      r1,r2,#0x14
00006e  4610              MOV      r0,r2
000070  e7fe              B        iap_entry
;;;134    }
;;;135    
                          ENDP

                  find_erase_prepare_sector PROC
;;;88     
;;;89     void find_erase_prepare_sector(uint32_t flash_address)
000072  b510              PUSH     {r4,lr}
000074  b672              CPSID    i
;;;90     {
;;;91         uint32_t i;
;;;92         uint32_t interrupts;
;;;93     
;;;94     
;;;95     	disable_interrupts(interrupts);
;;;96     
;;;97         for(i=USER_START_SECTOR;i<=MAX_USER_SECTOR;i++)
000076  2402              MOVS     r4,#2
;;;98         {
;;;99             if(flash_address < sector_end_map[i])
000078  493f              LDR      r1,|L1.376|
00007a  bf00              NOP      
                  |L1.124|
00007c  f8512024          LDR      r2,[r1,r4,LSL #2]
000080  4282              CMP      r2,r0
000082  d912              BLS      |L1.170|
;;;100            {
;;;101                if( flash_address == sector_start_map[i])
000084  493c              LDR      r1,|L1.376|
000086  3978              SUBS     r1,r1,#0x78
000088  f8511024          LDR      r1,[r1,r4,LSL #2]
00008c  4281              CMP      r1,r0
00008e  d107              BNE      |L1.160|
;;;102                {
;;;103                    prepare_sector(i,i);
000090  4621              MOV      r1,r4
000092  4608              MOV      r0,r1
000094  f7fffffe          BL       prepare_sector
;;;104                    erase_sector(i,i);
000098  4621              MOV      r1,r4
00009a  4608              MOV      r0,r1
00009c  f7fffffe          BL       erase_sector
                  |L1.160|
;;;105                }
;;;106                prepare_sector(i,i);
0000a0  4621              MOV      r1,r4
0000a2  4608              MOV      r0,r1
0000a4  f7fffffe          BL       prepare_sector
;;;107                break;
0000a8  e002              B        |L1.176|
                  |L1.170|
0000aa  1c64              ADDS     r4,r4,#1
0000ac  2c1d              CMP      r4,#0x1d              ;97
0000ae  d9e5              BLS      |L1.124|
                  |L1.176|
0000b0  b662              CPSIE    i                     ;97
;;;108            }
;;;109        }
;;;110    	enable_interrupts(interrupts);
;;;111    }
0000b2  bd10              POP      {r4,pc}
;;;112    
                          ENDP

                  write_flash PROC
;;;53     
;;;54     uint32_t write_flash(uint32_t * dst, uint8_t * src, uint32_t no_of_bytes)
0000b4  e92d41f0          PUSH     {r4-r8,lr}
;;;55     {
;;;56       uint32_t i;
;;;57     
;;;58         if (flash_address == 0)
0000b8  4c30              LDR      r4,|L1.380|
0000ba  6823              LDR      r3,[r4,#0]            ;55  ; flash_address
0000bc  b903              CBNZ     r3,|L1.192|
;;;59     	{
;;;60     	  /* Store flash start address */
;;;61     	  flash_address = (uint32_t *)dst;
0000be  6020              STR      r0,[r4,#0]  ; flash_address
                  |L1.192|
;;;62     	}
;;;63     	for( i = 0;i<no_of_bytes;i++ )
;;;64     	{
;;;65     	  flash_buf[(byte_ctr+i)] = *(src+i);
0000c0  4d2b              LDR      r5,|L1.368|
0000c2  2000              MOVS     r0,#0                 ;63
0000c4  3528              ADDS     r5,r5,#0x28
0000c6  6863              LDR      r3,[r4,#4]            ;63  ; byte_ctr
0000c8  e003              B        |L1.210|
                  |L1.202|
0000ca  5c0f              LDRB     r7,[r1,r0]
0000cc  181e              ADDS     r6,r3,r0
0000ce  1c40              ADDS     r0,r0,#1
0000d0  55af              STRB     r7,[r5,r6]
                  |L1.210|
0000d2  4290              CMP      r0,r2                 ;63
0000d4  d3f9              BCC      |L1.202|
;;;66         }
;;;67     	byte_ctr = byte_ctr + no_of_bytes;
0000d6  1898              ADDS     r0,r3,r2
;;;68     
;;;69     	if( byte_ctr == FLASH_BUF_SIZE)
0000d8  f44f7680          MOV      r6,#0x100
0000dc  6060              STR      r0,[r4,#4]  ; byte_ctr
0000de  42b0              CMP      r0,r6
0000e0  d113              BNE      |L1.266|
;;;70     	{
;;;71     	  /* We have accumulated enough bytes to trigger a flash write */
;;;72     	  find_erase_prepare_sector((uint32_t)flash_address);
0000e2  6820              LDR      r0,[r4,#0]  ; flash_address
0000e4  f7fffffe          BL       find_erase_prepare_sector
;;;73           if(result_table[0] != CMD_SUCCESS)
0000e8  4d21              LDR      r5,|L1.368|
0000ea  3514              ADDS     r5,r5,#0x14
0000ec  6828              LDR      r0,[r5,#0]  ; result_table
0000ee  b100              CBZ      r0,|L1.242|
                  |L1.240|
;;;74           {
;;;75             while(1); /* No way to recover. Just let Windows report a write failure */
0000f0  e7fe              B        |L1.240|
                  |L1.242|
;;;76           }
;;;77           write_data((uint32_t)flash_address,(uint32_t *)flash_buf,FLASH_BUF_SIZE);
0000f2  491f              LDR      r1,|L1.368|
0000f4  4632              MOV      r2,r6
0000f6  3128              ADDS     r1,r1,#0x28
0000f8  6820              LDR      r0,[r4,#0]  ; flash_address
0000fa  f7fffffe          BL       write_data
;;;78           if(result_table[0] != CMD_SUCCESS)
0000fe  6828              LDR      r0,[r5,#0]  ; result_table
000100  b100              CBZ      r0,|L1.260|
                  |L1.258|
;;;79           {
;;;80             while(1); /* No way to recover. Just let Windows report a write failure */
000102  e7fe              B        |L1.258|
                  |L1.260|
;;;81           }
;;;82     	  /* Reset byte counter and flash address */
;;;83     	  byte_ctr = 0;
000104  2000              MOVS     r0,#0
;;;84     	  flash_address = 0;
000106  6060              STR      r0,[r4,#4]  ; byte_ctr
000108  6020              STR      r0,[r4,#0]  ; flash_address
                  |L1.266|
;;;85     	}
;;;86         return(CMD_SUCCESS);
00010a  2000              MOVS     r0,#0
;;;87     }
00010c  e8bd81f0          POP      {r4-r8,pc}
;;;88     
                          ENDP

                  execute_user_code PROC
;;;168    
;;;169    void execute_user_code(void)
000110  491b              LDR      r1,|L1.384|
;;;170    {
;;;171    	/* Change the Vector Table to the USER_FLASH_START 
;;;172    	in case the user application uses interrupts */
;;;173    	SCB->VTOR = USER_FLASH_START & 0x1FFFFF80;
000112  f44f5000          MOV      r0,#0x2000
000116  6008              STR      r0,[r1,#0]
;;;174    
;;;175    	boot_jump(USER_FLASH_START);
000118  f7ffbffe          B.W      boot_jump
;;;176    }
;;;177    
                          ENDP

                  user_code_present PROC
;;;178    uint32_t user_code_present(void)
00011c  4814              LDR      r0,|L1.368|
;;;179    {
00011e  b510              PUSH     {r4,lr}
;;;180        param_table[0] = BLANK_CHECK_SECTOR;
000120  2135              MOVS     r1,#0x35
;;;181        param_table[1] = USER_START_SECTOR;
000122  6001              STR      r1,[r0,#0]  ; param_table
000124  2102              MOVS     r1,#2
;;;182        param_table[2] = USER_START_SECTOR;
000126  6041              STR      r1,[r0,#4]  ; param_table
;;;183        iap_entry(param_table,result_table);
000128  6081              STR      r1,[r0,#8]  ; param_table
00012a  f1000114          ADD      r1,r0,#0x14
00012e  f7fffffe          BL       iap_entry
;;;184    	if( result_table[0] == CMD_SUCCESS )
000132  480f              LDR      r0,|L1.368|
000134  3014              ADDS     r0,r0,#0x14
000136  6800              LDR      r0,[r0,#0]  ; result_table
000138  2800              CMP      r0,#0
00013a  d000              BEQ      |L1.318|
;;;185    	{
;;;186    	    return (0);
;;;187    	}
;;;188    	else
;;;189    	{
;;;190    	    return (1);
00013c  2001              MOVS     r0,#1
                  |L1.318|
;;;191    	}
;;;192    }
00013e  bd10              POP      {r4,pc}
;;;193    
                          ENDP

                  check_isp_entry_pin PROC
;;;194    void check_isp_entry_pin(void)
000140  4810              LDR      r0,|L1.388|
;;;195    {
;;;196        if( (*(volatile uint32_t *)ISP_ENTRY_GPIO_REG) & (0x1<<ISP_ENTRY_PIN) )
000142  6b40              LDR      r0,[r0,#0x34]
000144  02c0              LSLS     r0,r0,#11
000146  d500              BPL      |L1.330|
;;;197    	{
;;;198    	    execute_user_code();
000148  e7fe              B        execute_user_code
                  |L1.330|
;;;199    	}
;;;200    	else
;;;201    	{
;;;202    	    // Enter ISP mode
;;;203    	}
;;;204    }
00014a  4770              BX       lr
;;;205    
                          ENDP

                  erase_user_flash PROC
;;;206    void erase_user_flash(void)
00014c  b510              PUSH     {r4,lr}
;;;207    {
;;;208        prepare_sector(USER_START_SECTOR,MAX_USER_SECTOR);
00014e  211d              MOVS     r1,#0x1d
000150  2002              MOVS     r0,#2
000152  f7fffffe          BL       prepare_sector
;;;209        erase_sector(USER_START_SECTOR,MAX_USER_SECTOR);
000156  211d              MOVS     r1,#0x1d
000158  2002              MOVS     r0,#2
00015a  f7fffffe          BL       erase_sector
;;;210    	if(result_table[0] != CMD_SUCCESS)
00015e  4804              LDR      r0,|L1.368|
000160  3014              ADDS     r0,r0,#0x14
000162  6800              LDR      r0,[r0,#0]  ; result_table
000164  2800              CMP      r0,#0
000166  d000              BEQ      |L1.362|
                  |L1.360|
;;;211        {
;;;212          while(1); /* No way to recover. Just let Windows report a write failure */
000168  e7fe              B        |L1.360|
                  |L1.362|
;;;213        }
;;;214    }
00016a  bd10              POP      {r4,pc}
                          ENDP

                  |L1.364|
                          DCD      0x1fff1ff1
                  |L1.368|
                          DCD      ||.bss||
                  |L1.372|
                          DCD      SystemCoreClock
                  |L1.376|
                          DCD      ||.constdata||+0x78
                  |L1.380|
                          DCD      ||.data||
                  |L1.384|
                          DCD      0xe000ed08
                  |L1.388|
                          DCD      0x2009c000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  param_table
                          %        20
                  result_table
                          %        20
                  flash_buf
                          %        256

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  sector_start_map
                          DCD      0x00000000
                          DCD      0x00001000
                          DCD      0x00002000
                          DCD      0x00003000
                          DCD      0x00004000
                          DCD      0x00005000
                          DCD      0x00006000
                          DCD      0x00007000
                          DCD      0x00008000
                          DCD      0x00009000
                          DCD      0x0000a000
                          DCD      0x0000b000
                          DCD      0x0000c000
                          DCD      0x0000d000
                          DCD      0x0000e000
                          DCD      0x0000f000
                          DCD      0x00010000
                          DCD      0x00018000
                          DCD      0x00020000
                          DCD      0x00028000
                          DCD      0x00030000
                          DCD      0x00038000
                          DCD      0x00040000
                          DCD      0x00048000
                          DCD      0x00050000
                          DCD      0x00058000
                          DCD      0x00060000
                          DCD      0x00068000
                          DCD      0x00070000
                          DCD      0x00078000
                  sector_end_map
                          DCD      0x00000fff
                          DCD      0x00001fff
                          DCD      0x00002fff
                          DCD      0x00003fff
                          DCD      0x00004fff
                          DCD      0x00005fff
                          DCD      0x00006fff
                          DCD      0x00007fff
                          DCD      0x00008fff
                          DCD      0x00009fff
                          DCD      0x0000afff
                          DCD      0x0000bfff
                          DCD      0x0000cfff
                          DCD      0x0000dfff
                          DCD      0x0000efff
                          DCD      0x0000ffff
                          DCD      0x00017fff
                          DCD      0x0001ffff
                          DCD      0x00027fff
                          DCD      0x0002ffff
                          DCD      0x00037fff
                          DCD      0x0003ffff
                          DCD      0x00047fff
                          DCD      0x0004ffff
                          DCD      0x00057fff
                          DCD      0x0005ffff
                          DCD      0x00067fff
                          DCD      0x0006ffff
                          DCD      0x00077fff
                          DCD      0x0007ffff

                          AREA ||.data||, DATA, ALIGN=2

                  flash_address
                          DCD      0x00000000
                  byte_ctr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Drivers\\sbl_iap.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_sbl_iap_c_2c056f0b____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_sbl_iap_c_2c056f0b____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_sbl_iap_c_2c056f0b____REVSH|
#line 462
|__asm___9_sbl_iap_c_2c056f0b____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_sbl_iap_c_2c056f0b____RRX|
#line 649
|__asm___9_sbl_iap_c_2c056f0b____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |boot_jump|
#line 163 "Drivers\\sbl_iap.c"
|boot_jump| PROC
#line 163

 LDR SP, [R0] 
 LDR PC, [R0, #4] 
	ENDP

;*** End   embedded assembler ***
