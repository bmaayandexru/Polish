; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\flash\lpc17xx_uart.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\lpc17xx_uart.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\Drivers\include -I.\Common -I.\Retarget -ID:\Projects\Frezer\Frezer.keil\01020124\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\LPC1700_DFP\2.3.0\Device\Include -D__UVISION_VERSION=517 -D_RTE_ -DLPC175x_6x --omf_browse=.\flash\lpc17xx_uart.crf Drivers\source\lpc17xx_uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart_set_divisors PROC
;;;64      **********************************************************************/
;;;65     static Status uart_set_divisors(LPC_UART_TypeDef *UARTx, uint32_t baudrate)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;66     {
000004  4689              MOV      r9,r1
;;;67     	Status errorStatus = ERROR;
000006  2100              MOVS     r1,#0
;;;68     
;;;69     	uint32_t uClk;
;;;70     	uint32_t d, m, bestd, bestm, tmp;
;;;71     	uint64_t best_divisor, divisor;
;;;72     	uint32_t current_error, best_error;
;;;73     	uint32_t recalcbaud;
;;;74     
;;;75     	/* get UART block clock */
;;;76     	if (UARTx == LPC_UART0)
000008  9103              STR      r1,[sp,#0xc]
00000a  49f9              LDR      r1,|L1.1008|
00000c  4605              MOV      r5,r0                 ;66
00000e  4288              CMP      r0,r1
000010  d101              BNE      |L1.22|
;;;77     	{
;;;78     		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART0);
000012  2006              MOVS     r0,#6
000014  e00d              B        |L1.50|
                  |L1.22|
;;;79     	}
;;;80     	else if (UARTx == (LPC_UART_TypeDef *)LPC_UART1)
000016  49f7              LDR      r1,|L1.1012|
000018  428d              CMP      r5,r1
00001a  d101              BNE      |L1.32|
;;;81     	{
;;;82     		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART1);
00001c  2008              MOVS     r0,#8
00001e  e008              B        |L1.50|
                  |L1.32|
;;;83     	}
;;;84     	else if (UARTx == LPC_UART2)
000020  49f5              LDR      r1,|L1.1016|
000022  428d              CMP      r5,r1
000024  d101              BNE      |L1.42|
;;;85     	{
;;;86     		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART2);
000026  2030              MOVS     r0,#0x30
000028  e003              B        |L1.50|
                  |L1.42|
;;;87     	}
;;;88     	else if (UARTx == LPC_UART3)
00002a  49f4              LDR      r1,|L1.1020|
00002c  428d              CMP      r5,r1
00002e  d102              BNE      |L1.54|
;;;89     	{
;;;90     		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART3);
000030  2032              MOVS     r0,#0x32
                  |L1.50|
000032  f7fffffe          BL       CLKPWR_GetPCLK
                  |L1.54|
;;;91     	}
;;;92     
;;;93     
;;;94     	/* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
;;;95     	* The formula is :
;;;96     	* BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
;;;97     	* It involves floating point calculations. That's the reason the formulae are adjusted with
;;;98     	* Multiply and divide method.*/
;;;99     	/* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
;;;100    	* 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15 */
;;;101    	best_error = 0xFFFFFFFF; /* Worst case */
;;;102    	bestd = 0;
000036  2100              MOVS     r1,#0
;;;103    	bestm = 0;
000038  468b              MOV      r11,r1
00003a  460c              MOV      r4,r1
;;;104    	best_divisor = 0;
00003c  468a              MOV      r10,r1
;;;105    	for (m = 1 ; m <= 15 ;m++)
;;;106    	{
;;;107    		for (d = 0 ; d < m ; d++)
00003e  460f              MOV      r7,r1
;;;108    		{
;;;109    		  divisor = ((uint64_t)uClk<<28)*m/(baudrate*(m+d));
000040  9102              STR      r1,[sp,#8]
000042  2601              MOVS     r6,#1                 ;105
000044  0901              LSRS     r1,r0,#4
000046  0700              LSLS     r0,r0,#28
000048  e9cd1000          STRD     r1,r0,[sp,#0]
00004c  f04f38ff          MOV      r8,#0xffffffff        ;101
000050  e001              B        |L1.86|
                  |L1.82|
000052  2700              MOVS     r7,#0                 ;107
000054  e023              B        |L1.158|
                  |L1.86|
000056  e9dd2300          LDRD     r2,r3,[sp,#0]
00005a  19f0              ADDS     r0,r6,r7
00005c  fb00fe09          MUL      lr,r0,r9
000060  fba30c06          UMULL    r0,r12,r3,r6
000064  fb02c206          MLA      r2,r2,r6,r12
000068  2100              MOVS     r1,#0
00006a  fb032101          MLA      r1,r3,r1,r2
00006e  4672              MOV      r2,lr
000070  2300              MOVS     r3,#0
000072  f7fffffe          BL       __aeabi_uldivmod
;;;110    		  current_error = divisor & 0xFFFFFFFF;
;;;111    
;;;112    		  tmp = divisor>>32;
;;;113    
;;;114    		  /* Adjust error */
;;;115    		  if(current_error > ((uint32_t)1<<31)){
000076  f1b04f00          CMP      r0,#0x80000000
00007a  d901              BLS      |L1.128|
;;;116    			current_error = -current_error;
00007c  4240              RSBS     r0,r0,#0
00007e  1c49              ADDS     r1,r1,#1
                  |L1.128|
;;;117    			tmp++;
;;;118    			}
;;;119    
;;;120    		  if(tmp<1 || tmp>65536) /* Out of range */
000080  1e4a              SUBS     r2,r1,#1
000082  f5b23f80          CMP      r2,#0x10000
000086  d209              BCS      |L1.156|
;;;121    		  continue;
;;;122    
;;;123    		  if( current_error < best_error){
000088  4540              CMP      r0,r8
00008a  d207              BCS      |L1.156|
;;;124    			best_error = current_error;
00008c  ea5f0800          MOVS     r8,r0
;;;125    			best_divisor = tmp;
000090  f04f0a00          MOV      r10,#0
000094  460c              MOV      r4,r1
;;;126    			bestd = d;
;;;127    			bestm = m;
000096  46b3              MOV      r11,r6
;;;128    			if(best_error == 0) break;
000098  9702              STR      r7,[sp,#8]
00009a  d008              BEQ      |L1.174|
                  |L1.156|
00009c  1c7f              ADDS     r7,r7,#1
                  |L1.158|
00009e  42b7              CMP      r7,r6                 ;107
0000a0  d3d9              BCC      |L1.86|
;;;129    			}
;;;130    		} /* end of inner for loop */
;;;131    
;;;132    		if (best_error == 0)
0000a2  f1b80f00          CMP      r8,#0
0000a6  d002              BEQ      |L1.174|
0000a8  1c76              ADDS     r6,r6,#1
0000aa  2e0f              CMP      r6,#0xf               ;105
0000ac  d9d1              BLS      |L1.82|
                  |L1.174|
;;;133    		  break;
;;;134    	} /* end of outer for loop  */
;;;135    
;;;136    	if(best_divisor == 0) return ERROR; /* can not find best match */
0000ae  ea54000a          ORRS     r0,r4,r10
0000b2  d014              BEQ      |L1.222|
;;;137    
;;;138    	recalcbaud = (uClk>>4) * bestm/(best_divisor * (bestm + bestd));
0000b4  9a02              LDR      r2,[sp,#8]
0000b6  2100              MOVS     r1,#0
0000b8  eb0b0302          ADD      r3,r11,r2
0000bc  fba32704          UMULL    r2,r7,r3,r4
0000c0  fb017104          MLA      r1,r1,r4,r7
0000c4  9800              LDR      r0,[sp,#0]
0000c6  fb03130a          MLA      r3,r3,r10,r1
0000ca  fb00f00b          MUL      r0,r0,r11
0000ce  2100              MOVS     r1,#0
0000d0  f7fffffe          BL       __aeabi_uldivmod
;;;139    
;;;140    	/* reuse best_error to evaluate baud error*/
;;;141    	if(baudrate>recalcbaud) best_error = baudrate - recalcbaud;
0000d4  4581              CMP      r9,r0
0000d6  d906              BLS      |L1.230|
0000d8  eba90000          SUB      r0,r9,r0
0000dc  e005              B        |L1.234|
                  |L1.222|
0000de  2000              MOVS     r0,#0                 ;136
                  |L1.224|
;;;142    	else best_error = recalcbaud -baudrate;
;;;143    
;;;144    	best_error = best_error * 100 / baudrate;
;;;145    
;;;146    	if (best_error < UART_ACCEPTED_BAUDRATE_ERROR)
;;;147    		{
;;;148    			if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;149    			{
;;;150    				((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_DLAB_EN;
;;;151    				((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/DLM = UART_LOAD_DLM(best_divisor);
;;;152    				((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/DLL = UART_LOAD_DLL(best_divisor);
;;;153    				/* Then reset DLAB bit */
;;;154    				((LPC_UART1_TypeDef *)UARTx)->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;155    				((LPC_UART1_TypeDef *)UARTx)->FDR = (UART_FDR_MULVAL(bestm) \
;;;156    						| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;157    			}
;;;158    			else
;;;159    			{
;;;160    				UARTx->LCR |= UART_LCR_DLAB_EN;
;;;161    				UARTx->/*DLIER.*/DLM = UART_LOAD_DLM(best_divisor);
;;;162    				UARTx->/*RBTHDLR.*/DLL = UART_LOAD_DLL(best_divisor);
;;;163    				/* Then reset DLAB bit */
;;;164    				UARTx->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;165    				UARTx->FDR = (UART_FDR_MULVAL(bestm) \
;;;166    						| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;167    			}
;;;168    			errorStatus = SUCCESS;
;;;169    		}
;;;170    
;;;171    		return errorStatus;
;;;172    }
0000e0  b004              ADD      sp,sp,#0x10
0000e2  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.230|
0000e6  eba00009          SUB      r0,r0,r9              ;142
                  |L1.234|
0000ea  2164              MOVS     r1,#0x64              ;144
0000ec  4348              MULS     r0,r1,r0              ;144
0000ee  fbb0f0f9          UDIV     r0,r0,r9              ;144
0000f2  2803              CMP      r0,#3                 ;146
0000f4  d301              BCC      |L1.250|
0000f6  9803              LDR      r0,[sp,#0xc]          ;168
0000f8  e7f2              B        |L1.224|
                  |L1.250|
0000fa  48be              LDR      r0,|L1.1012|
0000fc  4285              CMP      r5,r0                 ;148
0000fe  7b28              LDRB     r0,[r5,#0xc]          ;160
000100  f0400080          ORR      r0,r0,#0x80           ;160
000104  7328              STRB     r0,[r5,#0xc]          ;160
000106  ea4f2014          LSR      r0,r4,#8              ;161
00010a  ea40600a          ORR      r0,r0,r10,LSL #24     ;161
00010e  7128              STRB     r0,[r5,#4]            ;161
000110  702c              STRB     r4,[r5,#0]            ;162
000112  7b28              LDRB     r0,[r5,#0xc]          ;164
000114  f000007f          AND      r0,r0,#0x7f           ;164
000118  7328              STRB     r0,[r5,#0xc]          ;164
00011a  ea4f100b          LSL      r0,r11,#4             ;164
00011e  d106              BNE      |L1.302|
000120  9902              LDR      r1,[sp,#8]            ;155
000122  b2c0              UXTB     r0,r0                 ;155
000124  f001010f          AND      r1,r1,#0xf            ;155
000128  4308              ORRS     r0,r0,r1              ;155
00012a  62a8              STR      r0,[r5,#0x28]         ;155
00012c  e005              B        |L1.314|
                  |L1.302|
00012e  9902              LDR      r1,[sp,#8]            ;165
000130  f001010f          AND      r1,r1,#0xf            ;165
000134  4308              ORRS     r0,r0,r1              ;165
000136  f8850028          STRB     r0,[r5,#0x28]         ;165
                  |L1.314|
00013a  2001              MOVS     r0,#1                 ;168
00013c  9003              STR      r0,[sp,#0xc]          ;168
00013e  e7cf              B        |L1.224|
;;;173    
                          ENDP

                  UART_Init PROC
;;;194     *********************************************************************/
;;;195    void UART_Init(LPC_UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct)
000140  e92d47f0          PUSH     {r4-r10,lr}
;;;196    {
000144  460e              MOV      r6,r1
000146  4604              MOV      r4,r0
;;;197    	uint32_t tmp;
;;;198    
;;;199    	// For debug mode
;;;200    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;201    	CHECK_PARAM(PARAM_UART_DATABIT(UART_ConfigStruct->Databits));
;;;202    	CHECK_PARAM(PARAM_UART_STOPBIT(UART_ConfigStruct->Stopbits));
;;;203    	CHECK_PARAM(PARAM_UART_PARITY(UART_ConfigStruct->Parity));
;;;204    
;;;205    #ifdef _UART0
;;;206    	if(UARTx == LPC_UART0)
000148  49a9              LDR      r1,|L1.1008|
;;;207    	{
;;;208    		/* Set up clock and power for UART module */
;;;209    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, ENABLE);
;;;210    	}
;;;211    #endif
;;;212    
;;;213    #ifdef _UART1
;;;214    	if(((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;215    	{
;;;216    		/* Set up clock and power for UART module */
;;;217    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, ENABLE);
;;;218    	}
;;;219    #endif
;;;220    
;;;221    #ifdef _UART2
;;;222    	if(UARTx == LPC_UART2)
00014a  48ab              LDR      r0,|L1.1016|
;;;223    	{
;;;224    		/* Set up clock and power for UART module */
;;;225    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, ENABLE);
;;;226    	}
;;;227    #endif
;;;228    
;;;229    #ifdef _UART3
;;;230    	if(UARTx == LPC_UART3)
00014c  f8dfa2ac          LDR      r10,|L1.1020|
000150  2700              MOVS     r7,#0
000152  4da8              LDR      r5,|L1.1012|
;;;231    	{
;;;232    		/* Set up clock and power for UART module */
;;;233    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, ENABLE);
;;;234    	}
;;;235    #endif
;;;236    
;;;237    	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;238    	{
;;;239    		/* FIFOs are empty */
;;;240    		((LPC_UART1_TypeDef *)UARTx)->/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN \
;;;241    				| UART_FCR_RX_RS | UART_FCR_TX_RS);
;;;242    		// Disable FIFO
;;;243    		((LPC_UART1_TypeDef *)UARTx)->/*IIFCR.*/FCR = 0;
;;;244    
;;;245    		// Dummy reading
;;;246    		while (((LPC_UART1_TypeDef *)UARTx)->LSR & UART_LSR_RDR)
;;;247    		{
;;;248    			tmp = ((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/RBR;
;;;249    		}
;;;250    
;;;251    		((LPC_UART1_TypeDef *)UARTx)->TER = UART_TER_TXEN;
000154  f04f0880          MOV      r8,#0x80
000158  f04f0907          MOV      r9,#7                 ;240
00015c  428c              CMP      r4,r1                 ;206
00015e  d102              BNE      |L1.358|
000160  2101              MOVS     r1,#1                 ;209
000162  2008              MOVS     r0,#8                 ;209
000164  e011              B        |L1.394|
                  |L1.358|
000166  42ac              CMP      r4,r5                 ;214
000168  d104              BNE      |L1.372|
00016a  2101              MOVS     r1,#1                 ;217
00016c  2010              MOVS     r0,#0x10              ;217
00016e  f7fffffe          BL       CLKPWR_ConfigPPWR
000172  e006              B        |L1.386|
                  |L1.372|
000174  4284              CMP      r4,r0                 ;222
000176  d104              BNE      |L1.386|
000178  2101              MOVS     r1,#1                 ;225
00017a  0608              LSLS     r0,r1,#24             ;225
00017c  f7fffffe          BL       CLKPWR_ConfigPPWR
000180  e006              B        |L1.400|
                  |L1.386|
000182  4554              CMP      r4,r10                ;230
000184  d104              BNE      |L1.400|
000186  2101              MOVS     r1,#1                 ;233
000188  0648              LSLS     r0,r1,#25             ;233
                  |L1.394|
00018a  f7fffffe          BL       CLKPWR_ConfigPPWR
00018e  e01d              B        |L1.460|
                  |L1.400|
000190  42ac              CMP      r4,r5                 ;237
000192  d11b              BNE      |L1.460|
000194  f8849008          STRB     r9,[r4,#8]            ;240
000198  7227              STRB     r7,[r4,#8]            ;243
00019a  e000              B        |L1.414|
                  |L1.412|
00019c  7820              LDRB     r0,[r4,#0]            ;248
                  |L1.414|
00019e  7d20              LDRB     r0,[r4,#0x14]         ;246
0001a0  07c0              LSLS     r0,r0,#31             ;246
0001a2  d1fb              BNE      |L1.412|
0001a4  f8848030          STRB     r8,[r4,#0x30]
                  |L1.424|
;;;252    		// Wait for current transmit complete
;;;253    		while (!(((LPC_UART1_TypeDef *)UARTx)->LSR & UART_LSR_THRE));
0001a8  7d20              LDRB     r0,[r4,#0x14]
0001aa  0680              LSLS     r0,r0,#26
0001ac  d5fc              BPL      |L1.424|
;;;254    		// Disable Tx
;;;255    		((LPC_UART1_TypeDef *)UARTx)->TER = 0;
0001ae  f8847030          STRB     r7,[r4,#0x30]
;;;256    
;;;257    		// Disable interrupt
;;;258    		((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/IER = 0;
0001b2  6067              STR      r7,[r4,#4]
;;;259    		// Set LCR to default state
;;;260    		((LPC_UART1_TypeDef *)UARTx)->LCR = 0;
0001b4  7327              STRB     r7,[r4,#0xc]
;;;261    		// Set ACR to default state
;;;262    		((LPC_UART1_TypeDef *)UARTx)->ACR = 0;
0001b6  6227              STR      r7,[r4,#0x20]
;;;263    		// Set Modem Control to default state
;;;264    		((LPC_UART1_TypeDef *)UARTx)->MCR = 0;
0001b8  7427              STRB     r7,[r4,#0x10]
;;;265    		// Set RS485 control to default state
;;;266    		((LPC_UART1_TypeDef *)UARTx)->RS485CTRL = 0;
0001ba  f884704c          STRB     r7,[r4,#0x4c]
;;;267    		// Set RS485 delay timer to default state
;;;268    		((LPC_UART1_TypeDef *)UARTx)->RS485DLY = 0;
0001be  f8847054          STRB     r7,[r4,#0x54]
;;;269    		// Set RS485 addr match to default state
;;;270    		((LPC_UART1_TypeDef *)UARTx)->ADRMATCH = 0;
0001c2  f8847050          STRB     r7,[r4,#0x50]
;;;271    		//Dummy Reading to Clear Status
;;;272    		tmp = ((LPC_UART1_TypeDef *)UARTx)->MSR;
0001c6  7e20              LDRB     r0,[r4,#0x18]
;;;273    		tmp = ((LPC_UART1_TypeDef *)UARTx)->LSR;
0001c8  7d20              LDRB     r0,[r4,#0x14]
0001ca  e016              B        |L1.506|
                  |L1.460|
;;;274    	}
;;;275    	else
;;;276    	{
;;;277    		/* FIFOs are empty */
;;;278    		UARTx->/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
0001cc  f8849008          STRB     r9,[r4,#8]
;;;279    		// Disable FIFO
;;;280    		UARTx->/*IIFCR.*/FCR = 0;
0001d0  7227              STRB     r7,[r4,#8]
;;;281    
;;;282    		// Dummy reading
;;;283    		while (UARTx->LSR & UART_LSR_RDR)
0001d2  e000              B        |L1.470|
                  |L1.468|
;;;284    		{
;;;285    			tmp = UARTx->/*RBTHDLR.*/RBR;
0001d4  7820              LDRB     r0,[r4,#0]
                  |L1.470|
0001d6  7d20              LDRB     r0,[r4,#0x14]         ;283
0001d8  07c0              LSLS     r0,r0,#31             ;283
0001da  d1fb              BNE      |L1.468|
;;;286    		}
;;;287    
;;;288    		UARTx->TER = UART_TER_TXEN;
0001dc  f8848030          STRB     r8,[r4,#0x30]
                  |L1.480|
;;;289    		// Wait for current transmit complete
;;;290    		while (!(UARTx->LSR & UART_LSR_THRE));
0001e0  7d20              LDRB     r0,[r4,#0x14]
0001e2  0680              LSLS     r0,r0,#26
0001e4  d5fc              BPL      |L1.480|
;;;291    		// Disable Tx
;;;292    		UARTx->TER = 0;
0001e6  f8847030          STRB     r7,[r4,#0x30]
;;;293    
;;;294    		// Disable interrupt
;;;295    		UARTx->/*DLIER.*/IER = 0;
0001ea  6067              STR      r7,[r4,#4]
;;;296    		// Set LCR to default state
;;;297    		UARTx->LCR = 0;
0001ec  7327              STRB     r7,[r4,#0xc]
;;;298    		// Set ACR to default state
;;;299    		UARTx->ACR = 0;
0001ee  6227              STR      r7,[r4,#0x20]
;;;300    		// Dummy reading
;;;301    		tmp = UARTx->LSR;
0001f0  7d20              LDRB     r0,[r4,#0x14]
;;;302    	}
;;;303    
;;;304    	if (UARTx == LPC_UART3)
0001f2  4554              CMP      r4,r10
0001f4  d101              BNE      |L1.506|
;;;305    	{
;;;306    		// Set IrDA to default state
;;;307    		UARTx->ICR = 0;
0001f6  f8847024          STRB     r7,[r4,#0x24]
                  |L1.506|
;;;308    	}
;;;309    
;;;310    	// Set Line Control register ----------------------------
;;;311    
;;;312    	uart_set_divisors(UARTx, (UART_ConfigStruct->Baud_rate));
0001fa  4620              MOV      r0,r4
0001fc  6831              LDR      r1,[r6,#0]
0001fe  f7fffffe          BL       uart_set_divisors
;;;313    
;;;314    	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;315    	{
;;;316    		tmp = (((LPC_UART1_TypeDef *)UARTx)->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
;;;317    				& UART_LCR_BITMASK;
;;;318    	}
;;;319    	else
;;;320    	{
;;;321    		tmp = (UARTx->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) & UART_LCR_BITMASK;
000202  7b20              LDRB     r0,[r4,#0xc]
;;;322    	}
;;;323    
;;;324    	switch (UART_ConfigStruct->Databits){
000204  7971              LDRB     r1,[r6,#5]
000206  f00000c0          AND      r0,r0,#0xc0           ;321
00020a  b129              CBZ      r1,|L1.536|
00020c  2901              CMP      r1,#1
00020e  d010              BEQ      |L1.562|
000210  2902              CMP      r1,#2
000212  d011              BEQ      |L1.568|
;;;325    	case UART_DATABIT_5:
;;;326    		tmp |= UART_LCR_WLEN5;
;;;327    		break;
;;;328    	case UART_DATABIT_6:
;;;329    		tmp |= UART_LCR_WLEN6;
;;;330    		break;
;;;331    	case UART_DATABIT_7:
;;;332    		tmp |= UART_LCR_WLEN7;
;;;333    		break;
;;;334    	case UART_DATABIT_8:
;;;335    	default:
;;;336    		tmp |= UART_LCR_WLEN8;
000214  f0400003          ORR      r0,r0,#3
                  |L1.536|
;;;337    		break;
;;;338    	}
;;;339    
;;;340    	if (UART_ConfigStruct->Parity == UART_PARITY_NONE)
000218  7931              LDRB     r1,[r6,#4]
00021a  b1c1              CBZ      r1,|L1.590|
;;;341    	{
;;;342    		// Do nothing...
;;;343    	}
;;;344    	else
;;;345    	{
;;;346    		tmp |= UART_LCR_PARITY_EN;
00021c  f0400008          ORR      r0,r0,#8
;;;347    		switch (UART_ConfigStruct->Parity)
000220  2901              CMP      r1,#1
000222  d014              BEQ      |L1.590|
000224  2902              CMP      r1,#2
000226  d00a              BEQ      |L1.574|
000228  2903              CMP      r1,#3
00022a  d00b              BEQ      |L1.580|
00022c  2904              CMP      r1,#4
00022e  d10e              BNE      |L1.590|
000230  e00b              B        |L1.586|
                  |L1.562|
000232  f0400001          ORR      r0,r0,#1              ;329
000236  e7ef              B        |L1.536|
                  |L1.568|
000238  f0400002          ORR      r0,r0,#2              ;332
00023c  e7ec              B        |L1.536|
                  |L1.574|
;;;348    		{
;;;349    		case UART_PARITY_ODD:
;;;350    			tmp |= UART_LCR_PARITY_ODD;
;;;351    			break;
;;;352    
;;;353    		case UART_PARITY_EVEN:
;;;354    			tmp |= UART_LCR_PARITY_EVEN;
00023e  f0400010          ORR      r0,r0,#0x10
;;;355    			break;
000242  e004              B        |L1.590|
                  |L1.580|
;;;356    
;;;357    		case UART_PARITY_SP_1:
;;;358    			tmp |= UART_LCR_PARITY_F_1;
000244  f0400020          ORR      r0,r0,#0x20
;;;359    			break;
000248  e001              B        |L1.590|
                  |L1.586|
;;;360    
;;;361    		case UART_PARITY_SP_0:
;;;362    			tmp |= UART_LCR_PARITY_F_0;
00024a  f0400030          ORR      r0,r0,#0x30
                  |L1.590|
;;;363    			break;
;;;364    		default:
;;;365    			break;
;;;366    		}
;;;367    	}
;;;368    
;;;369    	switch (UART_ConfigStruct->Stopbits){
00024e  79b1              LDRB     r1,[r6,#6]
000250  2901              CMP      r1,#1
000252  d101              BNE      |L1.600|
;;;370    	case UART_STOPBIT_2:
;;;371    		tmp |= UART_LCR_STOPBIT_SEL;
000254  f0400004          ORR      r0,r0,#4
                  |L1.600|
;;;372    		break;
;;;373    	case UART_STOPBIT_1:
;;;374    	default:
;;;375    		// Do no thing
;;;376    		break;
;;;377    	}
;;;378    
;;;379    
;;;380    	// Write back to LCR, configure FIFO and Disable Tx
;;;381    	if (((LPC_UART1_TypeDef *)UARTx) ==  LPC_UART1)
;;;382    	{
;;;383    		((LPC_UART1_TypeDef *)UARTx)->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
000258  7320              STRB     r0,[r4,#0xc]
;;;384    	}
;;;385    	else
;;;386    	{
;;;387    		UARTx->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
;;;388    	}
;;;389    }
00025a  e8bd87f0          POP      {r4-r10,pc}
;;;390    
                          ENDP

                  UART_TxCmd PROC
;;;1025    **********************************************************************/
;;;1026   void UART_TxCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState)
00025e  4a65              LDR      r2,|L1.1012|
;;;1027   {
;;;1028   	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;1029   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1030   
;;;1031   	if (NewState == ENABLE)
000260  2901              CMP      r1,#1
000262  d004              BEQ      |L1.622|
;;;1032   	{
;;;1033   		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;1034   		{
;;;1035   			((LPC_UART1_TypeDef *)UARTx)->TER |= UART_TER_TXEN;
;;;1036   		}
;;;1037   		else
;;;1038   		{
;;;1039   			UARTx->TER |= UART_TER_TXEN;
;;;1040   		}
;;;1041   	}
;;;1042   	else
;;;1043   	{
;;;1044   		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;1045   		{
;;;1046   			((LPC_UART1_TypeDef *)UARTx)->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
000264  f8102f30          LDRB     r2,[r0,#0x30]!
000268  2100              MOVS     r1,#0                 ;1027
                  |L1.618|
00026a  7001              STRB     r1,[r0,#0]            ;1039
;;;1047   		}
;;;1048   		else
;;;1049   		{
;;;1050   			UARTx->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
;;;1051   		}
;;;1052   	}
;;;1053   }
00026c  4770              BX       lr
                  |L1.622|
00026e  f8101f30          LDRB     r1,[r0,#0x30]!        ;1039
000272  f0410180          ORR      r1,r1,#0x80           ;1039
000276  e7f8              B        |L1.618|
;;;1054   
                          ENDP

                  UART_DeInit PROC
;;;400     **********************************************************************/
;;;401    void UART_DeInit(LPC_UART_TypeDef* UARTx)
000278  b570              PUSH     {r4-r6,lr}
;;;402    {
00027a  4604              MOV      r4,r0
;;;403    	// For debug mode
;;;404    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;405    
;;;406    	UART_TxCmd(UARTx, DISABLE);
00027c  2100              MOVS     r1,#0
00027e  f7fffffe          BL       UART_TxCmd
;;;407    
;;;408    #ifdef _UART0
;;;409    	if (UARTx == LPC_UART0)
000282  4a5b              LDR      r2,|L1.1008|
;;;410    	{
;;;411    		/* Set up clock and power for UART module */
;;;412    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, DISABLE);
;;;413    	}
;;;414    #endif
;;;415    
;;;416    #ifdef _UART1
;;;417    	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
000284  495b              LDR      r1,|L1.1012|
;;;418    	{
;;;419    		/* Set up clock and power for UART module */
;;;420    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, DISABLE);
;;;421    	}
;;;422    #endif
;;;423    
;;;424    #ifdef _UART2
;;;425    	if (UARTx == LPC_UART2)
000286  485c              LDR      r0,|L1.1016|
;;;426    	{
;;;427    		/* Set up clock and power for UART module */
;;;428    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, DISABLE);
;;;429    	}
;;;430    #endif
;;;431    
;;;432    #ifdef _UART3
;;;433    	if (UARTx == LPC_UART3)
000288  4d5c              LDR      r5,|L1.1020|
00028a  4294              CMP      r4,r2                 ;409
00028c  d102              BNE      |L1.660|
00028e  2100              MOVS     r1,#0                 ;412
000290  2008              MOVS     r0,#8                 ;412
000292  e011              B        |L1.696|
                  |L1.660|
000294  428c              CMP      r4,r1                 ;417
000296  d104              BNE      |L1.674|
000298  2100              MOVS     r1,#0                 ;420
00029a  2010              MOVS     r0,#0x10              ;420
00029c  f7fffffe          BL       CLKPWR_ConfigPPWR
0002a0  e005              B        |L1.686|
                  |L1.674|
0002a2  4284              CMP      r4,r0                 ;425
0002a4  d103              BNE      |L1.686|
0002a6  2100              MOVS     r1,#0                 ;428
0002a8  f04f7080          MOV      r0,#0x1000000         ;428
0002ac  e004              B        |L1.696|
                  |L1.686|
0002ae  42ac              CMP      r4,r5
0002b0  d106              BNE      |L1.704|
;;;434    	{
;;;435    		/* Set up clock and power for UART module */
;;;436    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, DISABLE);
0002b2  2100              MOVS     r1,#0
0002b4  f04f7000          MOV      r0,#0x2000000
                  |L1.696|
0002b8  e8bd4070          POP      {r4-r6,lr}
0002bc  f7ffbffe          B.W      CLKPWR_ConfigPPWR
                  |L1.704|
;;;437    	}
;;;438    #endif
;;;439    }
0002c0  bd70              POP      {r4-r6,pc}
;;;440    
                          ENDP

                  UART_ConfigStructInit PROC
;;;450    *******************************************************************************/
;;;451    void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct)
0002c2  f44f5116          MOV      r1,#0x2580
;;;452    {
;;;453    	UART_InitStruct->Baud_rate = 9600;
;;;454    	UART_InitStruct->Databits = UART_DATABIT_8;
0002c6  6001              STR      r1,[r0,#0]
0002c8  2103              MOVS     r1,#3
0002ca  7141              STRB     r1,[r0,#5]
;;;455    	UART_InitStruct->Parity = UART_PARITY_NONE;
0002cc  2100              MOVS     r1,#0
0002ce  7101              STRB     r1,[r0,#4]
;;;456    	UART_InitStruct->Stopbits = UART_STOPBIT_1;
0002d0  7181              STRB     r1,[r0,#6]
;;;457    }
0002d2  4770              BX       lr
;;;458    
                          ENDP

                  UART_SendByte PROC
;;;469     **********************************************************************/
;;;470    void UART_SendByte(LPC_UART_TypeDef* UARTx, uint8_t Data)
0002d4  4a47              LDR      r2,|L1.1012|
;;;471    {
;;;472    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;473    
;;;474    	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;475    	{
;;;476    		((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/THR = Data & UART_THR_MASKBIT;
0002d6  7001              STRB     r1,[r0,#0]
;;;477    	}
;;;478    	else
;;;479    	{
;;;480    		UARTx->/*RBTHDLR.*/THR = Data & UART_THR_MASKBIT;
;;;481    	}
;;;482    }
0002d8  4770              BX       lr
;;;483    
                          ENDP

                  UART_ReceiveByte PROC
;;;493     **********************************************************************/
;;;494    uint8_t UART_ReceiveByte(LPC_UART_TypeDef* UARTx)
0002da  4946              LDR      r1,|L1.1012|
;;;495    {
;;;496    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;497    
;;;498    	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;499    	{
;;;500    		return (((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/RBR & UART_RBR_MASKBIT);
;;;501    	}
;;;502    	else
;;;503    	{
;;;504    		return (UARTx->/*RBTHDLR.*/RBR & UART_RBR_MASKBIT);
0002dc  7800              LDRB     r0,[r0,#0]
;;;505    	}
;;;506    }
0002de  4770              BX       lr
;;;507    
                          ENDP

                  UART_Send PROC
;;;523     **********************************************************************/
;;;524    uint32_t UART_Send(LPC_UART_TypeDef *UARTx, uint8_t *txbuf,
0002e0  b500              PUSH     {lr}
;;;525    		uint32_t buflen, TRANSFER_BLOCK_Type flag)
;;;526    {
;;;527    //	uint32_t bToSend, bSent, timeOut, fifo_cnt;
;;;528    //	uint8_t *pChar = txbuf;
;;;529    
;;;530    //	bToSend = buflen;
;;;531    
;;;532    	// blocking mode
;;;533    //	if (flag == BLOCKING) {
;;;534    //		bSent = 0;
;;;535    //		while (bToSend){
;;;536    //			timeOut = UART_BLOCKING_TIMEOUT;
;;;537    //			// Wait for THR empty with timeout
;;;538    //			while (!(UARTx->LSR & UART_LSR_THRE)) {
;;;539    //				if (timeOut == 0) break;
;;;540    //				timeOut--;
;;;541    //			}
;;;542    //			// Time out!
;;;543    //			if(timeOut == 0) break;
;;;544    //			fifo_cnt = UART_TX_FIFO_SIZE;
;;;545    //			while (fifo_cnt && bToSend){
;;;546    //				UART_SendByte(UARTx, (*pChar++));
;;;547    //				fifo_cnt--;
;;;548    //				bToSend--;
;;;549    //				bSent++;
;;;550    //			}
;;;551    //		}
;;;552    //	}
;;;553    //	// None blocking mode
;;;554    //	else 
;;;555    //	{
;;;556    //		bSent = 0;
;;;557    //		while (bToSend) {
;;;558    			if (!(UARTx->LSR & UART_LSR_THRE)){
0002e2  7d02              LDRB     r2,[r0,#0x14]
0002e4  0692              LSLS     r2,r2,#26
0002e6  d401              BMI      |L1.748|
;;;559    				return 0;//break;
0002e8  2000              MOVS     r0,#0
;;;560    			}
;;;561    //			fifo_cnt = UART_TX_FIFO_SIZE;
;;;562    //			while (fifo_cnt && bToSend) {
;;;563    //				UART_SendByte(UARTx, (*pChar++));
;;;564    				UART_SendByte(UARTx, (*txbuf));
;;;565    //				bToSend--;
;;;566    //				fifo_cnt--;
;;;567    //				bSent++;
;;;568    //			}
;;;569    //		}
;;;570    //	}
;;;571    //	return bSent;
;;;572    	return 1;
;;;573    }
0002ea  bd00              POP      {pc}
                  |L1.748|
0002ec  7809              LDRB     r1,[r1,#0]            ;564
0002ee  f7fffffe          BL       UART_SendByte
0002f2  2001              MOVS     r0,#1                 ;572
0002f4  bd00              POP      {pc}
;;;574    //******************** Наши функции детализированы под быструю работу и персонализацию UARTов
                          ENDP

                  UART0_Send PROC
;;;575    // UART0_Send - передает 1 байт по неблокирующему соединению UATR0
;;;576    uint32_t UART0_Send(uint8_t Data)
0002f6  493e              LDR      r1,|L1.1008|
;;;577    {
;;;578    		if (!(LPC_UART0->LSR & UART_LSR_THRE)) return 0; // ничего не вышло
0002f8  7d0a              LDRB     r2,[r1,#0x14]
0002fa  0692              LSLS     r2,r2,#26
0002fc  d401              BMI      |L1.770|
0002fe  2000              MOVS     r0,#0
;;;579    		LPC_UART0->THR = Data & UART_THR_MASKBIT;		// тут передаем
;;;580    		return 1; // все ок
;;;581    }
000300  4770              BX       lr
                  |L1.770|
000302  7008              STRB     r0,[r1,#0]            ;579
000304  2001              MOVS     r0,#1                 ;580
000306  4770              BX       lr
;;;582    // UART1_Send - передает 1 байт по неблокирующему соединению UATR1
                          ENDP

                  UART1_Send PROC
;;;583    uint32_t UART1_Send(uint8_t Data)
000308  493a              LDR      r1,|L1.1012|
;;;584    {
;;;585    		if (!(LPC_UART1->LSR & UART_LSR_THRE)) return 0; // ничего не вышло
00030a  7d0a              LDRB     r2,[r1,#0x14]
00030c  0692              LSLS     r2,r2,#26
00030e  d401              BMI      |L1.788|
000310  2000              MOVS     r0,#0
;;;586    		LPC_UART1->THR = Data & UART_THR_MASKBIT;		// тут передаем
;;;587    		return 1; // все ок
;;;588    }
000312  4770              BX       lr
                  |L1.788|
000314  7008              STRB     r0,[r1,#0]            ;586
000316  2001              MOVS     r0,#1                 ;587
000318  4770              BX       lr
;;;589    //********************
                          ENDP

                  UART_Receive PROC
;;;606     **********************************************************************/
;;;607    uint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, \
00031a  b5f0              PUSH     {r4-r7,lr}
;;;608    		uint32_t buflen, TRANSFER_BLOCK_Type flag)
;;;609    {
;;;610    	uint32_t bToRecv, bRecv, timeOut;
;;;611    	uint8_t *pChar = rxbuf;
;;;612    //	uint8_t badChar;
;;;613    
;;;614    	bToRecv = buflen;
;;;615    
;;;616    	// Blocking mode
;;;617    	if (flag == BLOCKING) {
00031c  2b01              CMP      r3,#1
00031e  4606              MOV      r6,r0                 ;609
000320  460c              MOV      r4,r1                 ;611
;;;618    		bRecv = 0;
;;;619    		while (bToRecv){
;;;620    			timeOut = UART_BLOCKING_TIMEOUT;
;;;621    			// ждем 0-й бит в регистре LSR если от 1 то FIFO UARTa не пуста
;;;622    			while (!(UARTx->LSR & UART_LSR_RDR)){
;;;623    				if (timeOut == 0) break;
;;;624    				timeOut--;
;;;625    			}
;;;626    			// Time out!
;;;627    			if(timeOut == 0) break; // не дождались выходим
;;;628    			// Get data from the buffer
;;;629    			(*pChar++) = UART_ReceiveByte(UARTx); // читаем регистр RBR
;;;630    			bToRecv--;
;;;631    			bRecv++;
;;;632    		}
;;;633    	}
;;;634    	// None blocking mode
;;;635    	else {
;;;636    		bRecv = 0;
000322  f04f0300          MOV      r3,#0
000326  d11d              BNE      |L1.868|
000328  1e5f              SUBS     r7,r3,#1              ;620
00032a  e00e              B        |L1.842|
                  |L1.812|
00032c  463d              MOV      r5,r7                 ;620
00032e  e001              B        |L1.820|
                  |L1.816|
000330  b1d5              CBZ      r5,|L1.872|
000332  1e6d              SUBS     r5,r5,#1              ;623
                  |L1.820|
000334  7d30              LDRB     r0,[r6,#0x14]         ;622
000336  07c0              LSLS     r0,r0,#31             ;622
000338  d0fa              BEQ      |L1.816|
00033a  b1ad              CBZ      r5,|L1.872|
00033c  4630              MOV      r0,r6                 ;629
00033e  f7fffffe          BL       UART_ReceiveByte
000342  1e52              SUBS     r2,r2,#1              ;629
000344  f8040b01          STRB     r0,[r4],#1            ;629
000348  1c5b              ADDS     r3,r3,#1              ;629
                  |L1.842|
00034a  2a00              CMP      r2,#0                 ;619
00034c  d1ee              BNE      |L1.812|
00034e  e00b              B        |L1.872|
                  |L1.848|
;;;637    		while (bToRecv) {
;;;638    			if (!(UARTx->LSR & UART_LSR_RDR)) {
000350  7d30              LDRB     r0,[r6,#0x14]
000352  07c0              LSLS     r0,r0,#31
000354  d008              BEQ      |L1.872|
;;;639    				break;
;;;640    			} else {
;;;641    				// моя проверка паритета
;;;642    //				if (!(UARTx->LSR & UART_LSR_PE)) {
;;;643    					// нет ошибки
;;;644    					(*pChar++) = UART_ReceiveByte(UARTx);
000356  4630              MOV      r0,r6
000358  f7fffffe          BL       UART_ReceiveByte
00035c  1e52              SUBS     r2,r2,#1
00035e  f8040b01          STRB     r0,[r4],#1
000362  1c5b              ADDS     r3,r3,#1
                  |L1.868|
000364  2a00              CMP      r2,#0                 ;637
000366  d1f3              BNE      |L1.848|
                  |L1.872|
;;;645    					bRecv++;
;;;646    					bToRecv--;
;;;647    //				} 
;;;648    				// ошибка паритета
;;;649    //				else badChar = UART_ReceiveByte(UARTx); 
;;;650    			}
;;;651    		}
;;;652    	}
;;;653    	return bRecv;
000368  4618              MOV      r0,r3
;;;654    }
00036a  bdf0              POP      {r4-r7,pc}
;;;655    
                          ENDP

                  UART_ForceBreak PROC
;;;665     **********************************************************************/
;;;666    void UART_ForceBreak(LPC_UART_TypeDef* UARTx)
00036c  4921              LDR      r1,|L1.1012|
;;;667    {
;;;668    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;669    
;;;670    	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;671    	{
;;;672    		((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_BREAK_EN;
00036e  7b01              LDRB     r1,[r0,#0xc]
000370  f0410140          ORR      r1,r1,#0x40
000374  7301              STRB     r1,[r0,#0xc]
;;;673    	}
;;;674    	else
;;;675    	{
;;;676    		UARTx->LCR |= UART_LCR_BREAK_EN;
;;;677    	}
;;;678    }
000376  4770              BX       lr
;;;679    
                          ENDP

                  UART_IntConfig PROC
;;;702     *********************************************************************/
;;;703    void UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, FunctionalState NewState)
000378  b510              PUSH     {r4,lr}
;;;704    {
;;;705    	uint32_t tmp;
;;;706    
;;;707    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;708    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;709    
;;;710    	switch(UARTIntCfg){
00037a  2907              CMP      r1,#7
00037c  d214              BCS      |L1.936|
00037e  e8dff001          TBB      [pc,r1]
000382  0406              DCB      0x04,0x06
000384  080a0c0e          DCB      0x08,0x0a,0x0c,0x0e
000388  1100              DCB      0x11,0x00
;;;711    		case UART_INTCFG_RBR:
;;;712    			tmp = UART_IER_RBRINT_EN;
00038a  2301              MOVS     r3,#1
;;;713    			break;
00038c  e00c              B        |L1.936|
;;;714    		case UART_INTCFG_THRE:
;;;715    			tmp = UART_IER_THREINT_EN;
00038e  2302              MOVS     r3,#2
;;;716    			break;
000390  e00a              B        |L1.936|
;;;717    		case UART_INTCFG_RLS:
;;;718    			tmp = UART_IER_RLSINT_EN;
000392  2304              MOVS     r3,#4
;;;719    			break;
000394  e008              B        |L1.936|
;;;720    		case UART1_INTCFG_MS:
;;;721    			tmp = UART1_IER_MSINT_EN;
000396  2308              MOVS     r3,#8
;;;722    			break;
000398  e006              B        |L1.936|
;;;723    		case UART1_INTCFG_CTS:
;;;724    			tmp = UART1_IER_CTSINT_EN;
00039a  2380              MOVS     r3,#0x80
;;;725    			break;
00039c  e004              B        |L1.936|
;;;726    		case UART_INTCFG_ABEO:
;;;727    			tmp = UART_IER_ABEOINT_EN;
00039e  f44f7380          MOV      r3,#0x100
;;;728    			break;
0003a2  e001              B        |L1.936|
;;;729    		case UART_INTCFG_ABTO:
;;;730    			tmp = UART_IER_ABTOINT_EN;
0003a4  f44f7300          MOV      r3,#0x200
                  |L1.936|
;;;731    			break;
;;;732    	}
;;;733    
;;;734    	if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
;;;735    	{
;;;736    		CHECK_PARAM((PARAM_UART_INTCFG(UARTIntCfg)) || (PARAM_UART1_INTCFG(UARTIntCfg)));
;;;737    	}
;;;738    	else
;;;739    	{
;;;740    		CHECK_PARAM(PARAM_UART_INTCFG(UARTIntCfg));
;;;741    	}
;;;742    
;;;743    	if (NewState == ENABLE)
;;;744    	{
;;;745    		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
0003a8  4912              LDR      r1,|L1.1012|
0003aa  2a01              CMP      r2,#1                 ;743
0003ac  d005              BEQ      |L1.954|
;;;746    		{
;;;747    			((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/IER |= tmp;
;;;748    		}
;;;749    		else
;;;750    		{
;;;751    			UARTx->/*DLIER.*/IER |= tmp;
;;;752    		}
;;;753    	}
;;;754    	else
;;;755    	{
;;;756    		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
0003ae  4288              CMP      r0,r1
;;;757    		{
;;;758    			((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/IER &= (~tmp) & UART1_IER_BITMASK;
;;;759    		}
;;;760    		else
;;;761    		{
;;;762    			UARTx->/*DLIER.*/IER &= (~tmp) & UART_IER_BITMASK;
0003b0  6841              LDR      r1,[r0,#4]
0003b2  d105              BNE      |L1.960|
0003b4  f240328f          MOV      r2,#0x38f             ;758
0003b8  e004              B        |L1.964|
                  |L1.954|
0003ba  6841              LDR      r1,[r0,#4]            ;751
0003bc  4319              ORRS     r1,r1,r3              ;751
0003be  e003              B        |L1.968|
                  |L1.960|
0003c0  f2403207          MOV      r2,#0x307
                  |L1.964|
0003c4  439a              BICS     r2,r2,r3              ;758
0003c6  4011              ANDS     r1,r1,r2              ;758
                  |L1.968|
0003c8  6041              STR      r1,[r0,#4]            ;751
;;;763    		}
;;;764    	}
;;;765    }
0003ca  bd10              POP      {r4,pc}
;;;766    
                          ENDP

                  UART_GetLineStatus PROC
;;;783     *********************************************************************/
;;;784    uint8_t UART_GetLineStatus(LPC_UART_TypeDef* UARTx)
0003cc  4909              LDR      r1,|L1.1012|
;;;785    {
;;;786    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;787    
;;;788    	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
0003ce  4288              CMP      r0,r1
0003d0  d101              BNE      |L1.982|
;;;789    	{
;;;790    		return ((((LPC_UART1_TypeDef *)LPC_UART1)->LSR) & UART_LSR_BITMASK);
0003d2  7d08              LDRB     r0,[r1,#0x14]
;;;791    	}
;;;792    	else
;;;793    	{
;;;794    		return ((UARTx->LSR) & UART_LSR_BITMASK);
;;;795    	}
;;;796    }
0003d4  4770              BX       lr
                  |L1.982|
0003d6  7d00              LDRB     r0,[r0,#0x14]         ;794
0003d8  4770              BX       lr
;;;797    
                          ENDP

                  UART_GetIntId PROC
;;;806     *********************************************************************/
;;;807    uint32_t UART_GetIntId(LPC_UART_TypeDef* UARTx)
0003da  6880              LDR      r0,[r0,#8]
;;;808    {
;;;809    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;810    	return (UARTx->IIR & 0x03CF);
0003dc  f24031cf          MOV      r1,#0x3cf
0003e0  4008              ANDS     r0,r0,r1
;;;811    }
0003e2  4770              BX       lr
;;;812    
                          ENDP

                  UART_CheckBusy PROC
;;;821     **********************************************************************/
;;;822    FlagStatus UART_CheckBusy(LPC_UART_TypeDef *UARTx)
0003e4  7d00              LDRB     r0,[r0,#0x14]
;;;823    {				   /*0010 0000*/
;;;824    	if (UARTx->LSR & UART_LSR_TEMT){
0003e6  0640              LSLS     r0,r0,#25
0003e8  d50a              BPL      |L1.1024|
;;;825    //1 UnTHR and the UnTSR are empty.
;;;826    		return RESET;
0003ea  2000              MOVS     r0,#0
                  |L1.1004|
;;;827    	} else {
;;;828    //0 UnTHR and/or the UnTSR contains valid data.
;;;829    		return SET;
;;;830    	}
;;;831    }
0003ec  4770              BX       lr
0003ee  0000              DCW      0x0000
                  |L1.1008|
                          DCD      0x4000c000
                  |L1.1012|
                          DCD      0x40010000
                  |L1.1016|
                          DCD      0x40098000
                  |L1.1020|
                          DCD      0x4009c000
                  |L1.1024|
000400  2001              MOVS     r0,#1                 ;829
000402  e7f3              B        |L1.1004|
;;;832    
                          ENDP

                  UART_FIFOConfig PROC
;;;844     **********************************************************************/
;;;845    void UART_FIFOConfig(LPC_UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg)
000404  78cb              LDRB     r3,[r1,#3]
;;;846    {
;;;847    	uint8_t tmp = 0;
;;;848    
;;;849    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;850    	CHECK_PARAM(PARAM_UART_FIFO_LEVEL(FIFOCfg->FIFO_Level));
;;;851    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_DMAMode));
;;;852    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_ResetRxBuf));
;;;853    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_ResetTxBuf));
;;;854    
;;;855    	tmp |= UART_FCR_FIFO_EN;
000406  2201              MOVS     r2,#1
000408  b123              CBZ      r3,|L1.1044|
;;;856    	switch (FIFOCfg->FIFO_Level){
00040a  2b01              CMP      r3,#1
00040c  d006              BEQ      |L1.1052|
00040e  2b02              CMP      r3,#2
000410  d006              BEQ      |L1.1056|
;;;857    	case UART_FIFO_TRGLEV0:
;;;858    		tmp |= UART_FCR_TRG_LEV0;
;;;859    		break;
;;;860    	case UART_FIFO_TRGLEV1:
;;;861    		tmp |= UART_FCR_TRG_LEV1;
;;;862    		break;
;;;863    	case UART_FIFO_TRGLEV2:
;;;864    		tmp |= UART_FCR_TRG_LEV2;
;;;865    		break;
;;;866    	case UART_FIFO_TRGLEV3:
;;;867    	default:
;;;868    		tmp |= UART_FCR_TRG_LEV3;
000412  22c1              MOVS     r2,#0xc1
                  |L1.1044|
;;;869    		break;
;;;870    	}
;;;871    
;;;872    	if (FIFOCfg->FIFO_ResetTxBuf == ENABLE)
000414  784b              LDRB     r3,[r1,#1]
000416  2b01              CMP      r3,#1
000418  d004              BEQ      |L1.1060|
00041a  e005              B        |L1.1064|
                  |L1.1052|
00041c  2241              MOVS     r2,#0x41              ;861
00041e  e7f9              B        |L1.1044|
                  |L1.1056|
000420  2281              MOVS     r2,#0x81              ;864
000422  e7f7              B        |L1.1044|
                  |L1.1060|
;;;873    	{
;;;874    		tmp |= UART_FCR_TX_RS;
000424  f0420204          ORR      r2,r2,#4
                  |L1.1064|
;;;875    	}
;;;876    	if (FIFOCfg->FIFO_ResetRxBuf == ENABLE)
000428  780b              LDRB     r3,[r1,#0]
00042a  2b01              CMP      r3,#1
00042c  d101              BNE      |L1.1074|
;;;877    	{
;;;878    		tmp |= UART_FCR_RX_RS;
00042e  f0420202          ORR      r2,r2,#2
                  |L1.1074|
;;;879    	}
;;;880    	if (FIFOCfg->FIFO_DMAMode == ENABLE)
000432  7889              LDRB     r1,[r1,#2]
000434  2901              CMP      r1,#1
000436  d101              BNE      |L1.1084|
;;;881    	{
;;;882    		tmp |= UART_FCR_DMAMODE_SEL;
000438  f0420208          ORR      r2,r2,#8
                  |L1.1084|
;;;883    	}
;;;884    
;;;885    
;;;886    	//write to FIFO control register
;;;887    	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;888    	{
;;;889    		((LPC_UART1_TypeDef *)UARTx)->/*IIFCR.*/FCR = tmp & UART_FCR_BITMASK;
00043c  f00201cf          AND      r1,r2,#0xcf
000440  7201              STRB     r1,[r0,#8]
;;;890    	}
;;;891    	else
;;;892    	{
;;;893    		UARTx->/*IIFCR.*/FCR = tmp & UART_FCR_BITMASK;
;;;894    	}
;;;895    }
000442  e7d3              B        |L1.1004|
;;;896    
                          ENDP

                  UART_FIFOConfigStructInit PROC
;;;908    *******************************************************************************/
;;;909    void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct)
000444  2100              MOVS     r1,#0
;;;910    {
;;;911    	UART_FIFOInitStruct->FIFO_DMAMode = DISABLE;
000446  7081              STRB     r1,[r0,#2]
;;;912    	UART_FIFOInitStruct->FIFO_Level = UART_FIFO_TRGLEV0;
000448  70c1              STRB     r1,[r0,#3]
;;;913    	UART_FIFOInitStruct->FIFO_ResetRxBuf = ENABLE;
00044a  2101              MOVS     r1,#1
00044c  7001              STRB     r1,[r0,#0]
;;;914    	UART_FIFOInitStruct->FIFO_ResetTxBuf = ENABLE;
00044e  7041              STRB     r1,[r0,#1]
;;;915    }
000450  e7cc              B        |L1.1004|
;;;916    
                          ENDP

                  UART_ABCmd PROC
;;;934     **********************************************************************/
;;;935    void UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
000452  b530              PUSH     {r4,r5,lr}
;;;936    				FunctionalState NewState)
;;;937    {
;;;938    	uint32_t tmp;
;;;939    
;;;940    	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;941    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;942    
;;;943    	tmp = 0;
000454  2300              MOVS     r3,#0
;;;944    	if (NewState == ENABLE) {
000456  2a01              CMP      r2,#1
000458  d108              BNE      |L1.1132|
;;;945    		if (ABConfigStruct->ABMode == UART_AUTOBAUD_MODE1){
00045a  780c              LDRB     r4,[r1,#0]
00045c  2c01              CMP      r4,#1
00045e  d100              BNE      |L1.1122|
;;;946    			tmp |= UART_ACR_MODE;
000460  2302              MOVS     r3,#2
                  |L1.1122|
;;;947    		}
;;;948    		if (ABConfigStruct->AutoRestart == ENABLE){
000462  7849              LDRB     r1,[r1,#1]
000464  2901              CMP      r1,#1
000466  d101              BNE      |L1.1132|
;;;949    			tmp |= UART_ACR_AUTO_RESTART;
000468  f0430304          ORR      r3,r3,#4
                  |L1.1132|
;;;950    		}
;;;951    	}
;;;952    
;;;953    	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
00046c  4d66              LDR      r5,|L1.1544|
;;;954    	{
;;;955    		if (NewState == ENABLE)
;;;956    		{
;;;957    			// Clear DLL and DLM value
;;;958    			((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_DLAB_EN;
;;;959    			((LPC_UART1_TypeDef *)UARTx)->DLL = 0;
;;;960    			((LPC_UART1_TypeDef *)UARTx)->DLM = 0;
;;;961    			((LPC_UART1_TypeDef *)UARTx)->LCR &= ~UART_LCR_DLAB_EN;
;;;962    			// FDR value must be reset to default value
;;;963    			((LPC_UART1_TypeDef *)UARTx)->FDR = 0x10;
00046e  2410              MOVS     r4,#0x10
000470  2100              MOVS     r1,#0
000472  42a8              CMP      r0,r5                 ;953
000474  d10f              BNE      |L1.1174|
000476  2a01              CMP      r2,#1                 ;955
000478  d10b              BNE      |L1.1170|
00047a  7b02              LDRB     r2,[r0,#0xc]          ;958
00047c  f0420280          ORR      r2,r2,#0x80           ;958
000480  7302              STRB     r2,[r0,#0xc]          ;958
000482  7001              STRB     r1,[r0,#0]            ;959
000484  7101              STRB     r1,[r0,#4]            ;960
000486  7b01              LDRB     r1,[r0,#0xc]          ;961
000488  f0210180          BIC      r1,r1,#0x80           ;961
00048c  7301              STRB     r1,[r0,#0xc]          ;961
00048e  6284              STR      r4,[r0,#0x28]
;;;964    			((LPC_UART1_TypeDef *)UARTx)->ACR = UART_ACR_START | tmp;
000490  e00f              B        |L1.1202|
                  |L1.1170|
;;;965    		}
;;;966    		else
;;;967    		{
;;;968    			((LPC_UART1_TypeDef *)UARTx)->ACR = 0;
000492  6201              STR      r1,[r0,#0x20]
;;;969    		}
;;;970    	}
;;;971    	else
;;;972    	{
;;;973    		if (NewState == ENABLE)
;;;974    		{
;;;975    			// Clear DLL and DLM value
;;;976    			UARTx->LCR |= UART_LCR_DLAB_EN;
;;;977    			UARTx->DLL = 0;
;;;978    			UARTx->DLM = 0;
;;;979    			UARTx->LCR &= ~UART_LCR_DLAB_EN;
;;;980    			// FDR value must be reset to default value
;;;981    			UARTx->FDR = 0x10;
;;;982    			UARTx->ACR = UART_ACR_START | tmp;
;;;983    		}
;;;984    		else
;;;985    		{
;;;986    			UARTx->ACR = 0;
;;;987    		}
;;;988    	}
;;;989    }
000494  bd30              POP      {r4,r5,pc}
                  |L1.1174|
000496  2a01              CMP      r2,#1                 ;973
000498  d1fb              BNE      |L1.1170|
00049a  7b02              LDRB     r2,[r0,#0xc]          ;976
00049c  f0420280          ORR      r2,r2,#0x80           ;976
0004a0  7302              STRB     r2,[r0,#0xc]          ;976
0004a2  7001              STRB     r1,[r0,#0]            ;977
0004a4  7101              STRB     r1,[r0,#4]            ;978
0004a6  7b01              LDRB     r1,[r0,#0xc]          ;979
0004a8  f0210180          BIC      r1,r1,#0x80           ;979
0004ac  7301              STRB     r1,[r0,#0xc]          ;979
0004ae  f8804028          STRB     r4,[r0,#0x28]         ;981
                  |L1.1202|
0004b2  f0430101          ORR      r1,r3,#1              ;982
0004b6  e7ec              B        |L1.1170|
;;;990    
                          ENDP

                  UART_ABClearIntPending PROC
;;;1002    **********************************************************************/
;;;1003   void UART_ABClearIntPending(LPC_UART_TypeDef *UARTx, UART_ABEO_Type ABIntType)
0004b8  4a53              LDR      r2,|L1.1544|
;;;1004   {
;;;1005   	CHECK_PARAM(PARAM_UARTx(UARTx));
;;;1006   	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
;;;1007   	{
;;;1008   		UARTx->ACR |= ABIntType;
0004ba  6a02              LDR      r2,[r0,#0x20]
0004bc  430a              ORRS     r2,r2,r1
0004be  6202              STR      r2,[r0,#0x20]
;;;1009   	}
;;;1010   	else
;;;1011   		UARTx->ACR |= ABIntType;
;;;1012   }
0004c0  e794              B        |L1.1004|
;;;1013   
                          ENDP

                  UART_IrDAInvtInputCmd PROC
;;;1067    **********************************************************************/
;;;1068   void UART_IrDAInvtInputCmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState)
0004c2  2901              CMP      r1,#1
;;;1069   {
0004c4  d007              BEQ      |L1.1238|
;;;1070   	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
;;;1071   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1072   
;;;1073   	if (NewState == ENABLE)
;;;1074   	{
;;;1075   		UARTx->ICR |= UART_ICR_IRDAINV;
;;;1076   	}
;;;1077   	else if (NewState == DISABLE)
0004c6  2900              CMP      r1,#0
0004c8  d190              BNE      |L1.1004|
;;;1078   	{
;;;1079   		UARTx->ICR &= (~UART_ICR_IRDAINV) & UART_ICR_BITMASK;
0004ca  f8101f24          LDRB     r1,[r0,#0x24]!
0004ce  f001013d          AND      r1,r1,#0x3d
                  |L1.1234|
0004d2  7001              STRB     r1,[r0,#0]            ;1075
;;;1080   	}
;;;1081   }
0004d4  e78a              B        |L1.1004|
                  |L1.1238|
0004d6  f8101f24          LDRB     r1,[r0,#0x24]!        ;1075
0004da  f0410102          ORR      r1,r1,#2              ;1075
0004de  e7f8              B        |L1.1234|
;;;1082   
                          ENDP

                  UART_IrDACmd PROC
;;;1091    **********************************************************************/
;;;1092   void UART_IrDACmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState)
0004e0  2901              CMP      r1,#1
;;;1093   {
;;;1094   	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
;;;1095   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1096   
;;;1097   	if (NewState == ENABLE)
;;;1098   	{
;;;1099   		UARTx->ICR |= UART_ICR_IRDAEN;
;;;1100   	}
;;;1101   	else
;;;1102   	{
;;;1103   		UARTx->ICR &= (~UART_ICR_IRDAEN) & UART_ICR_BITMASK;
0004e2  f8101f24          LDRB     r1,[r0,#0x24]!
0004e6  d003              BEQ      |L1.1264|
0004e8  f001013e          AND      r1,r1,#0x3e
                  |L1.1260|
0004ec  7001              STRB     r1,[r0,#0]            ;1099
;;;1104   	}
;;;1105   }
0004ee  e77d              B        |L1.1004|
                  |L1.1264|
0004f0  f0410101          ORR      r1,r1,#1              ;1099
0004f4  e7fa              B        |L1.1260|
;;;1106   
                          ENDP

                  UART_IrDAPulseDivConfig PROC
;;;1123    **********************************************************************/
;;;1124   void UART_IrDAPulseDivConfig(LPC_UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv)
0004f6  00ca              LSLS     r2,r1,#3
;;;1125   {
;;;1126   	uint32_t tmp, tmp1;
;;;1127   	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
;;;1128   	CHECK_PARAM(PARAM_UART_IrDA_PULSEDIV(PulseDiv));
;;;1129   
;;;1130   	tmp1 = UART_ICR_PULSEDIV(PulseDiv);
;;;1131   	tmp = UARTx->ICR & (~UART_ICR_PULSEDIV(7));
0004f8  f8101f24          LDRB     r1,[r0,#0x24]!
0004fc  f0210138          BIC      r1,r1,#0x38
;;;1132   	tmp |= tmp1 | UART_ICR_FIXPULSE_EN;
000500  4311              ORRS     r1,r1,r2
000502  f001013f          AND      r1,r1,#0x3f
;;;1133   	UARTx->ICR = tmp & UART_ICR_BITMASK;
000506  f0410104          ORR      r1,r1,#4
00050a  7001              STRB     r1,[r0,#0]
;;;1134   }
00050c  e76e              B        |L1.1004|
;;;1135   
                          ENDP

                  UART_FullModemForcePinState PROC
;;;1153    **********************************************************************/
;;;1154   void UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, \
00050e  2300              MOVS     r3,#0
;;;1155   							UART1_SignalState NewState)
;;;1156   {
000510  b111              CBZ      r1,|L1.1304|
;;;1157   	uint8_t tmp = 0;
;;;1158   
;;;1159   	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
;;;1160   	CHECK_PARAM(PARAM_UART1_MODEM_PIN(Pin));
;;;1161   	CHECK_PARAM(PARAM_UART1_SIGNALSTATE(NewState));
;;;1162   
;;;1163   	switch (Pin){
000512  2901              CMP      r1,#1
000514  d103              BNE      |L1.1310|
000516  e001              B        |L1.1308|
                  |L1.1304|
;;;1164   	case UART1_MODEM_PIN_DTR:
;;;1165   		tmp = UART1_MCR_DTR_CTRL;
000518  2301              MOVS     r3,#1
;;;1166   		break;
00051a  e000              B        |L1.1310|
                  |L1.1308|
;;;1167   	case UART1_MODEM_PIN_RTS:
;;;1168   		tmp = UART1_MCR_RTS_CTRL;
00051c  2302              MOVS     r3,#2
                  |L1.1310|
;;;1169   		break;
;;;1170   	default:
;;;1171   		break;
;;;1172   	}
;;;1173   
;;;1174   	if (NewState == ACTIVE){
;;;1175   		UARTx->MCR |= tmp;
;;;1176   	} else {
;;;1177   		UARTx->MCR &= (~tmp) & UART1_MCR_BITMASK;
00051e  7c01              LDRB     r1,[r0,#0x10]
000520  2a01              CMP      r2,#1                 ;1174
000522  d004              BEQ      |L1.1326|
000524  22f3              MOVS     r2,#0xf3
000526  439a              BICS     r2,r2,r3
000528  4011              ANDS     r1,r1,r2
                  |L1.1322|
00052a  7401              STRB     r1,[r0,#0x10]         ;1175
;;;1178   	}
;;;1179   }
00052c  e75e              B        |L1.1004|
                  |L1.1326|
00052e  4319              ORRS     r1,r1,r3              ;1175
000530  e7fb              B        |L1.1322|
;;;1180   
                          ENDP

                  UART_FullModemConfigMode PROC
;;;1193    **********************************************************************/
;;;1194   void UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, \
000532  b121              CBZ      r1,|L1.1342|
;;;1195   							FunctionalState NewState)
;;;1196   {
;;;1197   	uint8_t tmp;
;;;1198   
;;;1199   	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
;;;1200   	CHECK_PARAM(PARAM_UART1_MODEM_MODE(Mode));
;;;1201   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1202   
;;;1203   	switch(Mode){
000534  2901              CMP      r1,#1
000536  d004              BEQ      |L1.1346|
000538  2902              CMP      r1,#2
00053a  d105              BNE      |L1.1352|
00053c  e003              B        |L1.1350|
                  |L1.1342|
;;;1204   	case UART1_MODEM_MODE_LOOPBACK:
;;;1205   		tmp = UART1_MCR_LOOPB_EN;
00053e  2310              MOVS     r3,#0x10
;;;1206   		break;
000540  e002              B        |L1.1352|
                  |L1.1346|
;;;1207   	case UART1_MODEM_MODE_AUTO_RTS:
;;;1208   		tmp = UART1_MCR_AUTO_RTS_EN;
000542  2340              MOVS     r3,#0x40
;;;1209   		break;
000544  e000              B        |L1.1352|
                  |L1.1350|
;;;1210   	case UART1_MODEM_MODE_AUTO_CTS:
;;;1211   		tmp = UART1_MCR_AUTO_CTS_EN;
000546  2380              MOVS     r3,#0x80
                  |L1.1352|
;;;1212   		break;
;;;1213   	default:
;;;1214   		break;
;;;1215   	}
;;;1216   
;;;1217   	if (NewState == ENABLE)
;;;1218   	{
;;;1219   		UARTx->MCR |= tmp;
;;;1220   	}
;;;1221   	else
;;;1222   	{
;;;1223   		UARTx->MCR &= (~tmp) & UART1_MCR_BITMASK;
000548  7c01              LDRB     r1,[r0,#0x10]
00054a  2a01              CMP      r2,#1                 ;1217
00054c  d004              BEQ      |L1.1368|
00054e  22f3              MOVS     r2,#0xf3
000550  439a              BICS     r2,r2,r3
000552  4011              ANDS     r1,r1,r2
                  |L1.1364|
000554  7401              STRB     r1,[r0,#0x10]         ;1219
;;;1224   	}
;;;1225   }
000556  e749              B        |L1.1004|
                  |L1.1368|
000558  4319              ORRS     r1,r1,r3              ;1219
00055a  e7fb              B        |L1.1364|
;;;1226   
                          ENDP

                  UART_FullModemGetStatus PROC
;;;1239    **********************************************************************/
;;;1240   uint8_t UART_FullModemGetStatus(LPC_UART1_TypeDef *UARTx)
00055c  7e00              LDRB     r0,[r0,#0x18]
;;;1241   {
;;;1242   	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
;;;1243   	return ((UARTx->MSR) & UART1_MSR_BITMASK);
;;;1244   }
00055e  e745              B        |L1.1004|
;;;1245   
                          ENDP

                  UART_RS485Config PROC
;;;1257    **********************************************************************/
;;;1258   void UART_RS485Config(LPC_UART1_TypeDef *UARTx, UART1_RS485_CTRLCFG_Type *RS485ConfigStruct)
000560  78cb              LDRB     r3,[r1,#3]
;;;1259   {
;;;1260   	uint32_t tmp;
;;;1261   
;;;1262   	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
;;;1263   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->AutoAddrDetect_State));
;;;1264   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->AutoDirCtrl_State));
;;;1265   	CHECK_PARAM(PARAM_UART1_RS485_CFG_DELAYVALUE(RS485ConfigStruct->DelayValue));
;;;1266   	CHECK_PARAM(PARAM_SETSTATE(RS485ConfigStruct->DirCtrlPol_Level));
;;;1267   	CHECK_PARAM(PARAM_UART_RS485_DIRCTRL_PIN(RS485ConfigStruct->DirCtrlPin));
;;;1268   	CHECK_PARAM(PARAM_UART1_RS485_CFG_MATCHADDRVALUE(RS485ConfigStruct->MatchAddrValue));
;;;1269   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->NormalMultiDropMode_State));
;;;1270   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->Rx_State));
;;;1271   
;;;1272   	tmp = 0;
000562  2200              MOVS     r2,#0
;;;1273   	// If Auto Direction Control is enabled -  This function is used in Master mode
;;;1274   	if (RS485ConfigStruct->AutoDirCtrl_State == ENABLE)
000564  2b01              CMP      r3,#1
000566  d10c              BNE      |L1.1410|
;;;1275   	{
;;;1276   		tmp |= UART1_RS485CTRL_DCTRL_EN;
;;;1277   
;;;1278   		// Set polar
;;;1279   		if (RS485ConfigStruct->DirCtrlPol_Level == SET)
000568  794b              LDRB     r3,[r1,#5]
00056a  2210              MOVS     r2,#0x10              ;1276
00056c  2b01              CMP      r3,#1
00056e  d100              BNE      |L1.1394|
;;;1280   		{
;;;1281   			tmp |= UART1_RS485CTRL_OINV_1;
000570  2230              MOVS     r2,#0x30
                  |L1.1394|
;;;1282   		}
;;;1283   
;;;1284   		// Set pin according to
;;;1285   		if (RS485ConfigStruct->DirCtrlPin == UART1_RS485_DIRCTRL_DTR)
000572  790b              LDRB     r3,[r1,#4]
000574  2b01              CMP      r3,#1
000576  d101              BNE      |L1.1404|
;;;1286   		{
;;;1287   			tmp |= UART1_RS485CTRL_SEL_DTR;
000578  f0420208          ORR      r2,r2,#8
                  |L1.1404|
;;;1288   		}
;;;1289   
;;;1290   		// Fill delay time
;;;1291   		UARTx->RS485DLY = RS485ConfigStruct->DelayValue & UART1_RS485DLY_BITMASK;
00057c  79cb              LDRB     r3,[r1,#7]
00057e  f8803054          STRB     r3,[r0,#0x54]
                  |L1.1410|
;;;1292   	}
;;;1293   
;;;1294   	// MultiDrop mode is enable
;;;1295   	if (RS485ConfigStruct->NormalMultiDropMode_State == ENABLE)
000582  780b              LDRB     r3,[r1,#0]
000584  2b01              CMP      r3,#1
000586  d101              BNE      |L1.1420|
;;;1296   	{
;;;1297   		tmp |= UART1_RS485CTRL_NMM_EN;
000588  f0420201          ORR      r2,r2,#1
                  |L1.1420|
;;;1298   	}
;;;1299   
;;;1300   	// Auto Address Detect function
;;;1301   	if (RS485ConfigStruct->AutoAddrDetect_State == ENABLE)
00058c  788b              LDRB     r3,[r1,#2]
00058e  2b01              CMP      r3,#1
000590  d104              BNE      |L1.1436|
;;;1302   	{
;;;1303   		tmp |= UART1_RS485CTRL_AADEN;
;;;1304   		// Fill Match Address
;;;1305   		UARTx->ADRMATCH = RS485ConfigStruct->MatchAddrValue & UART1_RS485ADRMATCH_BITMASK;
000592  798b              LDRB     r3,[r1,#6]
000594  f0420204          ORR      r2,r2,#4              ;1303
000598  f8803050          STRB     r3,[r0,#0x50]
                  |L1.1436|
;;;1306   	}
;;;1307   
;;;1308   
;;;1309   	// Receiver is disable
;;;1310   	if (RS485ConfigStruct->Rx_State == DISABLE)
00059c  7849              LDRB     r1,[r1,#1]
00059e  b909              CBNZ     r1,|L1.1444|
;;;1311   	{
;;;1312   		tmp |= UART1_RS485CTRL_RX_DIS;
0005a0  f0420202          ORR      r2,r2,#2
                  |L1.1444|
;;;1313   	}
;;;1314   
;;;1315   	// write back to RS485 control register
;;;1316   	UARTx->RS485CTRL = tmp & UART1_RS485CTRL_BITMASK;
0005a4  f880204c          STRB     r2,[r0,#0x4c]
;;;1317   
;;;1318   	// Enable Parity function and leave parity in stick '0' parity as default
;;;1319   	UARTx->LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
0005a8  7b01              LDRB     r1,[r0,#0xc]
0005aa  f0410138          ORR      r1,r1,#0x38
0005ae  7301              STRB     r1,[r0,#0xc]
;;;1320   }
0005b0  e71c              B        |L1.1004|
;;;1321   
                          ENDP

                  UART_RS485ReceiverCmd PROC
;;;1329    **********************************************************************/
;;;1330   void UART_RS485ReceiverCmd(LPC_UART1_TypeDef *UARTx, FunctionalState NewState)
0005b2  2901              CMP      r1,#1
;;;1331   {
;;;1332   	if (NewState == ENABLE){
;;;1333   		UARTx->RS485CTRL &= ~UART1_RS485CTRL_RX_DIS;
;;;1334   	} else {
;;;1335   		UARTx->RS485CTRL |= UART1_RS485CTRL_RX_DIS;
0005b4  f8101f4c          LDRB     r1,[r0,#0x4c]!
0005b8  d003              BEQ      |L1.1474|
0005ba  f0410102          ORR      r1,r1,#2
                  |L1.1470|
0005be  7001              STRB     r1,[r0,#0]            ;1333
;;;1336   	}
;;;1337   }
0005c0  e714              B        |L1.1004|
                  |L1.1474|
0005c2  f0210102          BIC      r1,r1,#2              ;1333
0005c6  e7fa              B        |L1.1470|
;;;1338   
                          ENDP

                  UART_RS485Send PROC
;;;1346    **********************************************************************/
;;;1347   uint32_t UART_RS485Send(LPC_UART1_TypeDef *UARTx, uint8_t *pDatFrm, \
0005c8  b530              PUSH     {r4,r5,lr}
;;;1348   					uint32_t size, uint8_t ParityStick)
;;;1349   {
0005ca  4604              MOV      r4,r0
0005cc  b163              CBZ      r3,|L1.1512|
;;;1350   	uint8_t tmp, save;
;;;1351   	uint32_t cnt;
;;;1352   
;;;1353   	if (ParityStick){
;;;1354   		save = tmp = UARTx->LCR & UART_LCR_BITMASK;
0005ce  7b25              LDRB     r5,[r4,#0xc]
;;;1355   		tmp &= ~(UART_LCR_PARITY_EVEN);
0005d0  f0250010          BIC      r0,r5,#0x10
;;;1356   		UARTx->LCR = tmp;
0005d4  7320              STRB     r0,[r4,#0xc]
;;;1357   		cnt = UART_Send((LPC_UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
0005d6  2301              MOVS     r3,#1
0005d8  4620              MOV      r0,r4
0005da  f7fffffe          BL       UART_Send
                  |L1.1502|
;;;1358   		while (!(UARTx->LSR & UART_LSR_TEMT));
0005de  7d21              LDRB     r1,[r4,#0x14]
0005e0  0649              LSLS     r1,r1,#25
0005e2  d5fc              BPL      |L1.1502|
;;;1359   		UARTx->LCR = save;
0005e4  7325              STRB     r5,[r4,#0xc]
;;;1360   	} else {
;;;1361   		cnt = UART_Send((LPC_UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
;;;1362   		while (!(UARTx->LSR & UART_LSR_TEMT));
;;;1363   	}
;;;1364   	return cnt;
;;;1365   }
0005e6  bd30              POP      {r4,r5,pc}
                  |L1.1512|
0005e8  2301              MOVS     r3,#1                 ;1361
0005ea  f7fffffe          BL       UART_Send
                  |L1.1518|
0005ee  7d21              LDRB     r1,[r4,#0x14]         ;1362
0005f0  0649              LSLS     r1,r1,#25             ;1362
0005f2  d5fc              BPL      |L1.1518|
0005f4  bd30              POP      {r4,r5,pc}
;;;1366   
                          ENDP

                  UART_RS485SendSlvAddr PROC
;;;1372    **********************************************************************/
;;;1373   void UART_RS485SendSlvAddr(LPC_UART1_TypeDef *UARTx, uint8_t SlvAddr)
0005f6  b503              PUSH     {r0,r1,lr}
;;;1374   {
;;;1375   	UART_RS485Send(UARTx, &SlvAddr, 1, 1);
0005f8  2301              MOVS     r3,#1
0005fa  461a              MOV      r2,r3
0005fc  a901              ADD      r1,sp,#4
0005fe  f7fffffe          BL       UART_RS485Send
;;;1376   }
000602  bd0c              POP      {r2,r3,pc}
;;;1377   
                          ENDP

                  UART_RS485SendData PROC
;;;1384    **********************************************************************/
;;;1385   uint32_t UART_RS485SendData(LPC_UART1_TypeDef *UARTx, uint8_t *pData, uint32_t size)
000604  2300              MOVS     r3,#0
;;;1386   {
;;;1387   	return (UART_RS485Send(UARTx, pData, size, 0));
000606  e7fe              B        UART_RS485Send
;;;1388   }
;;;1389   
                          ENDP

                  |L1.1544|
                          DCD      0x40010000

;*** Start embedded assembler ***

#line 1 "Drivers\\source\\lpc17xx_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc17xx_uart_c_e5efacd7____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_lpc17xx_uart_c_e5efacd7____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc17xx_uart_c_e5efacd7____REVSH|
#line 462
|__asm___14_lpc17xx_uart_c_e5efacd7____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc17xx_uart_c_e5efacd7____RRX|
#line 649
|__asm___14_lpc17xx_uart_c_e5efacd7____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
