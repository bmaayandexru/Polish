; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\flash\uart.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\uart.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\Main -I.\Drivers -I.\Drivers\include -I.\UCNC -ID:\Projects\Frezer\Frezer.keil\01020124\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\LPC1700_DFP\2.3.0\Device\Include -D__UVISION_VERSION=517 -D_RTE_ -DLPC175x_6x --omf_browse=.\flash\uart.crf UCNC\UART.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART0_IntTransmit PROC
;;;176    
;;;177    void UART0_IntTransmit(void){
000000  b570              PUSH     {r4-r6,lr}
;;;178        // Disable THRE interrupt
;;;179    
;;;180    		//UART_IntConfig((LPC_UART_TypeDef *)LPC_UART0, UART_INTCFG_THRE, DISABLE);
;;;181    		LPC_UART0->IER &= (~UART_IER_THREINT_EN) & UART_IER_BITMASK;
000002  4cfe              LDR      r4,|L1.1020|
000004  6860              LDR      r0,[r4,#4]
000006  f2403605          MOV      r6,#0x305
00000a  4030              ANDS     r0,r0,r6
00000c  6060              STR      r0,[r4,#4]
                  |L1.14|
;;;182    
;;;183    	/* Wait for FIFO buffer empty, transfer UART_TX_FIFO_SIZE bytes
;;;184    	 * of data or break whenever ring buffers are empty */
;;;185    	/* Wait until THR empty */
;;;186    	// Ждем освобождения регистра THR
;;;187    	
;;;188    //  while (UART_CheckBusy((LPC_UART_TypeDef *)LPC_UART0) == SET);
;;;189    		while(!(LPC_UART0->LSR & UART_LSR_TEMT));
00000e  7d20              LDRB     r0,[r4,#0x14]
000010  0640              LSLS     r0,r0,#25
000012  d5fc              BPL      |L1.14|
;;;190    	
;;;191    	// проверяем наличие данных в выходном буфере
;;;192    		if (!__BUF_IS_EMPTY(rb0.tx_head,rb0.tx_tail))
000014  4dfa              LDR      r5,|L1.1024|
000016  6828              LDR      r0,[r5,#0]  ; rb0
000018  6869              LDR      r1,[r5,#4]  ; rb0
00001a  f3c00008          UBFX     r0,r0,#0,#9
00001e  f3c10108          UBFX     r1,r1,#0,#9
000022  4288              CMP      r0,r1
000024  d010              BEQ      |L1.72|
;;;193        {
;;;194            /* Move a piece of data into the transmit FIFO */
;;;195    //    	if (UART_Send((LPC_UART_TypeDef *)LPC_UART0, (uint8_t *)&rb0.tx[rb0.tx_tail], 1, NONE_BLOCKING)){
;;;196        	if (UART0_Send(rb0.tx[rb0.tx_tail])){
000026  6869              LDR      r1,[r5,#4]  ; rb0
000028  f1050010          ADD      r0,r5,#0x10
00002c  5c08              LDRB     r0,[r1,r0]
00002e  f7fffffe          BL       UART0_Send
000032  b148              CBZ      r0,|L1.72|
;;;197    	        /* Update transmit ring FIFO tail pointer */
;;;198    	        __BUF_INCR(rb0.tx_tail);
000034  6868              LDR      r0,[r5,#4]  ; rb0
000036  1c40              ADDS     r0,r0,#1
000038  f3c00008          UBFX     r0,r0,#0,#9
00003c  6068              STR      r0,[r5,#4]  ; rb0
;;;199    					rb0.txfree++;
00003e  f8b50412          LDRH     r0,[r5,#0x412]  ; rb0
000042  1c40              ADDS     r0,r0,#1
000044  f8a50412          STRH     r0,[r5,#0x412]
                  |L1.72|
;;;200    			} 
;;;201        }
;;;202    
;;;203        /* If there is no more data to send, disable the transmit
;;;204           interrupt - else enable it or keep it enabled */
;;;205    		if (__BUF_IS_EMPTY(rb0.tx_head, rb0.tx_tail)) {
000048  6828              LDR      r0,[r5,#0]  ; rb0
00004a  f3c00108          UBFX     r1,r0,#0,#9
00004e  6868              LDR      r0,[r5,#4]  ; rb0
000050  f3c00208          UBFX     r2,r0,#0,#9
;;;206        	//UART_IntConfig((LPC_UART_TypeDef *)LPC_UART0, UART_INTCFG_THRE, DISABLE);
;;;207    			// UART_IntConfig DISABLE через регистры
;;;208    			LPC_UART0->IER &= (~UART_IER_THREINT_EN) & UART_IER_BITMASK;
;;;209        	// Reset Tx Interrupt state
;;;210        	TxIntStat0 = RESET;
000054  48eb              LDR      r0,|L1.1028|
000056  4291              CMP      r1,r2                 ;205
000058  d105              BNE      |L1.102|
00005a  6861              LDR      r1,[r4,#4]            ;208
00005c  4031              ANDS     r1,r1,r6              ;208
00005e  6061              STR      r1,[r4,#4]            ;208
000060  2100              MOVS     r1,#0
000062  7001              STRB     r1,[r0,#0]
;;;211        }
;;;212        else{
;;;213          // Set Tx Interrupt state
;;;214    			TxIntStat0 = SET;
;;;215    			//UART_IntConfig((LPC_UART_TypeDef *)LPC_UART0, UART_INTCFG_THRE, ENABLE);
;;;216    			LPC_UART0->IER |= UART_IER_THREINT_EN;
;;;217        }
;;;218    		
;;;219    }
000064  bd70              POP      {r4-r6,pc}
                  |L1.102|
000066  2101              MOVS     r1,#1                 ;214
000068  7001              STRB     r1,[r0,#0]            ;214
00006a  6860              LDR      r0,[r4,#4]            ;216
00006c  f0400002          ORR      r0,r0,#2              ;216
000070  6060              STR      r0,[r4,#4]            ;216
000072  bd70              POP      {r4-r6,pc}
;;;220    
                          ENDP

                  UART0_IntReceive PROC
;;;271    
;;;272    void UART0_IntReceive(void){
000074  b5f8              PUSH     {r3-r7,lr}
;;;273    	uint8_t tmpc;
;;;274    	uint32_t rLen;
;;;275    
;;;276    	while(1){
;;;277    		// Call UART read function in UART driver
;;;278    		rLen = UART_Receive((LPC_UART_TypeDef *)LPC_UART0, &tmpc, 1, NONE_BLOCKING);
;;;279    		//				^ можно ускорить. надо
;;;280    		// If data received
;;;281    		if (rLen){
;;;282    			// проверка на свободное место в буфере
;;;283    			// если места нет символ теряется
;;;284    			if (!__BUF_IS_FULL(rb0.rx_head,rb0.rx_tail)){
000076  4ce2              LDR      r4,|L1.1024|
000078  4ee0              LDR      r6,|L1.1020|
;;;285    				rb0.rx[rb0.rx_head] = tmpc;
00007a  f5047504          ADD      r5,r4,#0x210
                  |L1.126|
00007e  2300              MOVS     r3,#0                 ;278
000080  2201              MOVS     r2,#1                 ;278
000082  4669              MOV      r1,sp                 ;278
000084  4630              MOV      r0,r6                 ;278
000086  f7fffffe          BL       UART_Receive
00008a  2800              CMP      r0,#0                 ;281
00008c  d017              BEQ      |L1.190|
00008e  68e0              LDR      r0,[r4,#0xc]          ;284  ; rb0
000090  f3c00108          UBFX     r1,r0,#0,#9           ;284
000094  68a0              LDR      r0,[r4,#8]            ;284  ; rb0
000096  1c40              ADDS     r0,r0,#1              ;284
000098  f3c00008          UBFX     r0,r0,#0,#9           ;284
00009c  4281              CMP      r1,r0                 ;284
00009e  d0ee              BEQ      |L1.126|
0000a0  f89d0000          LDRB     r0,[sp,#0]
0000a4  68a1              LDR      r1,[r4,#8]  ; rb0
0000a6  5548              STRB     r0,[r1,r5]
;;;286    				__BUF_INCR(rb0.rx_head);
0000a8  68a0              LDR      r0,[r4,#8]  ; rb0
0000aa  1c40              ADDS     r0,r0,#1
0000ac  f3c00008          UBFX     r0,r0,#0,#9
0000b0  60a0              STR      r0,[r4,#8]  ; rb0
;;;287    				rb0.rxdata++;
0000b2  f8940414          LDRB     r0,[r4,#0x414]  ; rb0
0000b6  1c40              ADDS     r0,r0,#1
0000b8  f8840414          STRB     r0,[r4,#0x414]
0000bc  e7df              B        |L1.126|
                  |L1.190|
;;;288    			}
;;;289    		}
;;;290    		// no more data
;;;291    		else {
;;;292    			break;
;;;293    		}
;;;294    	}
;;;295    }
0000be  bdf8              POP      {r3-r7,pc}
;;;296    
                          ENDP

                  UART0_IntErr PROC
;;;154    
;;;155    void UART0_IntErr(u8 bLSErrType){
0000c0  4770              BX       lr
;;;156    /*
;;;157    	uint8_t test;
;;;158    	// Loop forever
;;;159    	while (1){
;;;160    		// For testing purpose
;;;161    		test = bLSErrType;
;;;162    	}
;;;163    */
;;;164    }
;;;165    
                          ENDP

                  UART0_IRQHandler PROC
;;;76     
;;;77     void UART0_IRQHandler(void)
0000c2  b510              PUSH     {r4,lr}
;;;78     {
;;;79     	uint32_t intsrc, tmp, tmp1;
;;;80     //	static uint32_t f=0;
;;;81     	/* Determine the interrupt source */
;;;82     	intsrc = UART_GetIntId(LPC_UART0); // чтение регистра IRR соответсвующего UARTa
0000c4  4ccd              LDR      r4,|L1.1020|
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       UART_GetIntId
;;;83     	tmp = intsrc & UART_IIR_INTID_MASK/*0000 1110*/;// маскирование 1,2 и 3 битов
0000cc  f000000e          AND      r0,r0,#0xe
;;;84     	
;;;85     	// Receive Line Status
;;;86     	if (tmp == UART_IIR_INTID_RLS/*0000 0110*/){
0000d0  2806              CMP      r0,#6
0000d2  d008              BEQ      |L1.230|
;;;87     		// Check line status
;;;88     		tmp1 = UART_GetLineStatus(LPC_UART0); // чтение регистра LSR
;;;89     		// Mask out the Receive Ready and Transmit Holding empty status
;;;90     		tmp1 &= (UART_LSR_OE | UART_LSR_PE | UART_LSR_FE \
;;;91     				| UART_LSR_BI | UART_LSR_RXFE);
;;;92     		// If any error exist
;;;93     		if (tmp1) {
;;;94     				UART0_IntErr(tmp1);
;;;95     		}
;;;96     	}
;;;97     	
;;;98     	// Receive Data Available or Character time-out
;;;99     	// проверка значения регистра IRR на присутствие символа
;;;100    	// или Character time-out 
;;;101    	if ((tmp == UART_IIR_INTID_RDA) || (tmp == UART_IIR_INTID_CTI)){
0000d4  2804              CMP      r0,#4
0000d6  d00a              BEQ      |L1.238|
0000d8  280c              CMP      r0,#0xc
0000da  d008              BEQ      |L1.238|
;;;102    		  
;;;103    			UART0_IntReceive();
;;;104    		
;;;105    	}
;;;106    	// Transmit Holding Empty
;;;107    	if (tmp == UART_IIR_INTID_THRE){
0000dc  2802              CMP      r0,#2
0000de  d105              BNE      |L1.236|
;;;108    		  
;;;109    			UART0_IntTransmit();
0000e0  e8bd4010          POP      {r4,lr}
0000e4  e7fe              B        UART0_IntTransmit
                  |L1.230|
0000e6  4620              MOV      r0,r4                 ;88
0000e8  f7fffffe          BL       UART_GetLineStatus
                  |L1.236|
;;;110    	}
;;;111    	
;;;112    	// исследование прерывания TIMER0_IRQn
;;;113    	// U0T0p = 1 если T0 в режиме ожидания
;;;114    //	if (!U0T0p) U0T0p = NVIC_GetPendingIRQ (TIMER0_IRQn);
;;;115    	
;;;116    }
0000ec  bd10              POP      {r4,pc}
                  |L1.238|
0000ee  e8bd4010          POP      {r4,lr}               ;103
0000f2  e7fe              B        UART0_IntReceive
;;;117    
                          ENDP

                  StartDelay PROC
;;;680    
;;;681    void StartDelay(void){
0000f4  48c3              LDR      r0,|L1.1028|
;;;682    //		StartTI(tiTx485Delay,2); // было когда MR0 = TC + interval
;;;683    	// очень странно но так работает лучше !!!
;;;684    	// StartTI(tiTx485Delay,0); // работает !!!
;;;685    	// хотя должно бы так
;;;686    	StartTI(tiTx485Delay,tiMksToTick(Delay));
0000f6  6840              LDR      r0,[r0,#4]  ; Delay
0000f8  2132              MOVS     r1,#0x32
0000fa  fbb0f0f1          UDIV     r0,r0,r1
0000fe  49c2              LDR      r1,|L1.1032|
000100  1c40              ADDS     r0,r0,#1
000102  6008              STR      r0,[r1,#0]  ; ti
;;;687    }
000104  4770              BX       lr
;;;688    
                          ENDP

                  UART1_IntTransmit PROC
;;;221    
;;;222    void UART1_IntTransmit(void){
000106  b570              PUSH     {r4-r6,lr}
;;;223    		// Disable THRE interrupt
;;;224    		//UART_IntConfig((LPC_UART_TypeDef *)LPC_UART1, UART_INTCFG_THRE, DISABLE);
;;;225    		// замена UART_IntConfig через регистры
;;;226    		((LPC_UART1_TypeDef *)LPC_UART1)->/*DLIER.*/IER &= (~UART_IER_THREINT_EN) & UART1_IER_BITMASK;
000108  4dc0              LDR      r5,|L1.1036|
00010a  6868              LDR      r0,[r5,#4]
00010c  f240368d          MOV      r6,#0x38d
000110  4030              ANDS     r0,r0,r6
000112  6068              STR      r0,[r5,#4]
                  |L1.276|
;;;227    		/* Wait for FIFO buffer empty, transfer UART_TX_FIFO_SIZE bytes
;;;228    		* of data or break whenever ring buffers are empty */
;;;229    		/* Wait until THR empty */
;;;230    		// Ждем освобождения регистра THR
;;;231    		//while (UART_CheckBusy((LPC_UART_TypeDef *)LPC_UART1) == SET);
;;;232    		// 				^ можно через регистры. надо
;;;233    		// UART_CheckBusy через порт
;;;234    		while(!(((LPC_UART_TypeDef *)LPC_UART1)->LSR & UART_LSR_TEMT));
000114  7d28              LDRB     r0,[r5,#0x14]
000116  0640              LSLS     r0,r0,#25
000118  d5fc              BPL      |L1.276|
;;;235    		// если полудуплекс занимаем линию
;;;236    //		if (rb1.dup == HALF_DUPLEX) BusyUartLine();
;;;237    		if (rb1.dup == HALF_DUPLEX) DefBusyUartLine; // т к define
00011a  4cbd              LDR      r4,|L1.1040|
00011c  f8940410          LDRB     r0,[r4,#0x410]  ; rb1
000120  2801              CMP      r0,#1
000122  d102              BNE      |L1.298|
000124  49bb              LDR      r1,|L1.1044|
000126  200c              MOVS     r0,#0xc
000128  6588              STR      r0,[r1,#0x58]
                  |L1.298|
;;;238    		
;;;239    		// проверяем наличие данных в выходном буфере
;;;240    		if (!__BUF_IS_EMPTY(rb1.tx_head,rb1.tx_tail))
00012a  6820              LDR      r0,[r4,#0]  ; rb1
00012c  6861              LDR      r1,[r4,#4]  ; rb1
00012e  f3c00008          UBFX     r0,r0,#0,#9
000132  f3c10108          UBFX     r1,r1,#0,#9
000136  4288              CMP      r0,r1
000138  d010              BEQ      |L1.348|
;;;241        {
;;;242            /* Move a piece of data into the transmit FIFO */
;;;243    //    	if (UART_Send((LPC_UART_TypeDef *)LPC_UART1, (uint8_t *)&rb1.tx[rb1.tx_tail], 1, NONE_BLOCKING)){
;;;244        	if (UART1_Send(rb1.tx[rb1.tx_tail])){
00013a  6861              LDR      r1,[r4,#4]  ; rb1
00013c  48b4              LDR      r0,|L1.1040|
00013e  3010              ADDS     r0,r0,#0x10
000140  5c08              LDRB     r0,[r1,r0]
000142  f7fffffe          BL       UART1_Send
000146  b148              CBZ      r0,|L1.348|
;;;245    	        /* Update transmit ring FIFO tail pointer */
;;;246    	      __BUF_INCR(rb1.tx_tail);
000148  6860              LDR      r0,[r4,#4]  ; rb1
00014a  1c40              ADDS     r0,r0,#1
00014c  f3c00008          UBFX     r0,r0,#0,#9
000150  6060              STR      r0,[r4,#4]  ; rb1
;;;247    				rb1.txfree++;
000152  f8b40412          LDRH     r0,[r4,#0x412]  ; rb1
000156  1c40              ADDS     r0,r0,#1
000158  f8a40412          STRH     r0,[r4,#0x412]
                  |L1.348|
;;;248        	} 
;;;249        }
;;;250        /* If there is no more data to send, disable the transmit
;;;251           interrupt - else enable it or keep it enabled */
;;;252    		if (__BUF_IS_EMPTY(rb1.tx_head, rb1.tx_tail)) {
00015c  6820              LDR      r0,[r4,#0]  ; rb1
00015e  f3c00108          UBFX     r1,r0,#0,#9
000162  6860              LDR      r0,[r4,#4]  ; rb1
000164  f3c00208          UBFX     r2,r0,#0,#9
;;;253        	//UART_IntConfig((LPC_UART_TypeDef *)LPC_UART1, UART_INTCFG_THRE, DISABLE);
;;;254        	//	^ можно через регистры. надо
;;;255    			// UART_IntConfig DISABLE через регистры
;;;256    			((LPC_UART1_TypeDef *)LPC_UART1)->IER &= (~UART_IER_THREINT_EN) & UART1_IER_BITMASK;
;;;257    			// Reset Tx Interrupt state
;;;258        	TxIntStat1 = RESET;
000168  48a6              LDR      r0,|L1.1028|
00016a  4291              CMP      r1,r2                 ;252
00016c  d10b              BNE      |L1.390|
00016e  6869              LDR      r1,[r5,#4]            ;256
000170  4031              ANDS     r1,r1,r6              ;256
000172  6069              STR      r1,[r5,#4]            ;256
000174  2100              MOVS     r1,#0
000176  7041              STRB     r1,[r0,#1]
;;;259    			if (rb1.dup == HALF_DUPLEX) StartDelay();
000178  f8940410          LDRB     r0,[r4,#0x410]  ; rb1
00017c  2801              CMP      r0,#1
00017e  d108              BNE      |L1.402|
000180  e8bd4070          POP      {r4-r6,lr}
000184  e7fe              B        StartDelay
                  |L1.390|
;;;260        }
;;;261        else{
;;;262          // Set Tx Interrupt state
;;;263    			TxIntStat1 = SET;
000186  2101              MOVS     r1,#1
000188  7041              STRB     r1,[r0,#1]
;;;264        	//UART_IntConfig((LPC_UART_TypeDef *)LPC_UART1, UART_INTCFG_THRE, ENABLE);
;;;265    			//	^ можно через регистры. надо
;;;266    			// UART_IntConfig ENABLE через регистры
;;;267    			((LPC_UART1_TypeDef *)LPC_UART1)->IER |= UART_IER_THREINT_EN;
00018a  6868              LDR      r0,[r5,#4]
00018c  f0400002          ORR      r0,r0,#2
000190  6068              STR      r0,[r5,#4]
                  |L1.402|
;;;268        }
;;;269    }
000192  bd70              POP      {r4-r6,pc}
;;;270    
                          ENDP

                  UART1_IntReceive PROC
;;;296    
;;;297    void UART1_IntReceive(void){
000194  b5f8              PUSH     {r3-r7,lr}
;;;298    	uint8_t tmpc;
;;;299    	uint32_t rLen;
;;;300    
;;;301    	while(1){
;;;302    		// Call UART read function in UART driver
;;;303    		rLen = UART_Receive((LPC_UART_TypeDef *)LPC_UART1, &tmpc, 1, NONE_BLOCKING);
;;;304    		//			^ можно ускорить. надо
;;;305    		// If data received
;;;306    		if (rLen){
;;;307    			/* Check if buffer is more space
;;;308    			 * If no more space, remaining character will be trimmed out
;;;309    			 */
;;;310    			// проверка на свободное место в буфере
;;;311    			// если места нет символ теряется
;;;312    			if (!__BUF_IS_FULL(rb1.rx_head,rb1.rx_tail)){
000196  4c9e              LDR      r4,|L1.1040|
000198  4e9c              LDR      r6,|L1.1036|
;;;313    				rb1.rx[rb1.rx_head] = tmpc;
00019a  f5047504          ADD      r5,r4,#0x210
                  |L1.414|
00019e  2300              MOVS     r3,#0                 ;303
0001a0  2201              MOVS     r2,#1                 ;303
0001a2  4669              MOV      r1,sp                 ;303
0001a4  4630              MOV      r0,r6                 ;303
0001a6  f7fffffe          BL       UART_Receive
0001aa  2800              CMP      r0,#0                 ;306
0001ac  d017              BEQ      |L1.478|
0001ae  68e0              LDR      r0,[r4,#0xc]          ;312  ; rb1
0001b0  f3c00108          UBFX     r1,r0,#0,#9           ;312
0001b4  68a0              LDR      r0,[r4,#8]            ;312  ; rb1
0001b6  1c40              ADDS     r0,r0,#1              ;312
0001b8  f3c00008          UBFX     r0,r0,#0,#9           ;312
0001bc  4281              CMP      r1,r0                 ;312
0001be  d0ee              BEQ      |L1.414|
0001c0  f89d0000          LDRB     r0,[sp,#0]
0001c4  68a1              LDR      r1,[r4,#8]  ; rb1
0001c6  5548              STRB     r0,[r1,r5]
;;;314    				__BUF_INCR(rb1.rx_head);
0001c8  68a0              LDR      r0,[r4,#8]  ; rb1
0001ca  1c40              ADDS     r0,r0,#1
0001cc  f3c00008          UBFX     r0,r0,#0,#9
0001d0  60a0              STR      r0,[r4,#8]  ; rb1
;;;315    				rb1.rxdata++;
0001d2  f8940414          LDRB     r0,[r4,#0x414]  ; rb1
0001d6  1c40              ADDS     r0,r0,#1
0001d8  f8840414          STRB     r0,[r4,#0x414]
0001dc  e7df              B        |L1.414|
                  |L1.478|
;;;316    			}
;;;317    		}
;;;318    		// no more data
;;;319    		else {
;;;320    			break;
;;;321    		}
;;;322    	}
;;;323    }
0001de  bdf8              POP      {r3-r7,pc}
;;;324    
                          ENDP

                  UART1_IntErr PROC
;;;165    
;;;166    void UART1_IntErr(u8 bLSErrType){
0001e0  4770              BX       lr
;;;167    /*
;;;168    	uint8_t test;
;;;169    	// Loop forever
;;;170    	while (1){
;;;171    		// For testing purpose
;;;172    		test = bLSErrType;
;;;173    	}
;;;174    */
;;;175    }
;;;176    
                          ENDP

                  UART1_IRQHandler PROC
;;;118    
;;;119    void UART1_IRQHandler(void)
0001e2  b510              PUSH     {r4,lr}
;;;120    {
;;;121    	uint32_t intsrc, tmp, tmp1;
;;;122    	/* Determine the interrupt source */	
;;;123    
;;;124    	intsrc = UART_GetIntId((LPC_UART_TypeDef *)LPC_UART1); // чтение регистра IRR соответсвующего UARTa
0001e4  4c89              LDR      r4,|L1.1036|
0001e6  4620              MOV      r0,r4
0001e8  f7fffffe          BL       UART_GetIntId
;;;125    	tmp = intsrc & UART_IIR_INTID_MASK/*0000 1110*/;// маскирование 1,2 и 3 битов
0001ec  f000000e          AND      r0,r0,#0xe
;;;126    	// Receive Line Status
;;;127    	if (tmp == UART_IIR_INTID_RLS/*0000 0110*/){
0001f0  2806              CMP      r0,#6
0001f2  d008              BEQ      |L1.518|
;;;128    		// Check line status
;;;129    		tmp1 = UART_GetLineStatus((LPC_UART_TypeDef *)LPC_UART1); // чтение регистра LSR !!!!Здесь была ошибка
;;;130    		// Mask out the Receive Ready and Transmit Holding empty status
;;;131    		tmp1 &= (UART_LSR_OE | UART_LSR_PE | UART_LSR_FE \
;;;132    				| UART_LSR_BI | UART_LSR_RXFE);
;;;133    		// If any error exist
;;;134    		if (tmp1) {
;;;135    				UART1_IntErr(tmp1);
;;;136    		}
;;;137    	}
;;;138    	// Receive Data Available or Character time-out
;;;139    	// проверка значения регистра IRR на присутствие символа
;;;140    	// или Character time-out 
;;;141    	if ((tmp == UART_IIR_INTID_RDA) || (tmp == UART_IIR_INTID_CTI)){
0001f4  2804              CMP      r0,#4
0001f6  d00a              BEQ      |L1.526|
0001f8  280c              CMP      r0,#0xc
0001fa  d008              BEQ      |L1.526|
;;;142    			//Msg("r");
;;;143    			UART1_IntReceive();
;;;144    	}
;;;145    	// Transmit Holding Empty
;;;146    	if (tmp == UART_IIR_INTID_THRE){
0001fc  2802              CMP      r0,#2
0001fe  d105              BNE      |L1.524|
;;;147    			UART1_IntTransmit();
000200  e8bd4010          POP      {r4,lr}
000204  e7fe              B        UART1_IntTransmit
                  |L1.518|
000206  4620              MOV      r0,r4                 ;129
000208  f7fffffe          BL       UART_GetLineStatus
                  |L1.524|
;;;148    	}
;;;149    	
;;;150    // исследование прерывания TIMER0_IRQn
;;;151    //	U1T0p = 1 если T0 в режиме ожидания
;;;152    //	if (!U1T0p) U1T0p = NVIC_GetPendingIRQ (TIMER0_IRQn);
;;;153    }
00020c  bd10              POP      {r4,pc}
                  |L1.526|
00020e  e8bd4010          POP      {r4,lr}               ;143
000212  e7fe              B        UART1_IntReceive
;;;154    
                          ENDP

                  InitFullDupControlSignal PROC
;;;707    
;;;708    void InitFullDupControlSignal(void){
000214  487f              LDR      r0,|L1.1044|
;;;709    	// инициализация выходных сигналов для полного дуплекса
;;;710    	// Только для UART1 !!!!!!!!!!!! 
;;;711    	// DE(2.2) = 1; RE(2.3)=0
;;;712    	DE_PORT->FIODIR |= DE_PIN_MASK; // DE(2.2) - выходной пин 
000216  6c01              LDR      r1,[r0,#0x40]
000218  f0410104          ORR      r1,r1,#4
00021c  6401              STR      r1,[r0,#0x40]
;;;713    	RE_PORT->FIODIR |= RE_PIN_MASK; // RE(2.2) - выходной пин 
00021e  6c01              LDR      r1,[r0,#0x40]
000220  f0410108          ORR      r1,r1,#8
000224  6401              STR      r1,[r0,#0x40]
;;;714    	// разрешаем и прием и передачу
;;;715    	DE_PORT->FIOPIN |=  DE_PIN_MASK; // DE(2.2) = 1 
000226  6d41              LDR      r1,[r0,#0x54]
000228  f0410104          ORR      r1,r1,#4
00022c  6541              STR      r1,[r0,#0x54]
;;;716    	RE_PORT->FIOPIN &= ~RE_PIN_MASK; // RE(2.3) = 0 
00022e  6d41              LDR      r1,[r0,#0x54]
000230  f0210108          BIC      r1,r1,#8
000234  6541              STR      r1,[r0,#0x54]
;;;717    }
000236  4770              BX       lr
;;;718    
                          ENDP

                  InitHalfDupWaitInterval PROC
;;;674    
;;;675    void InitHalfDupWaitInterval(u32 baud_rate){
000238  4977              LDR      r1,|L1.1048|
;;;676    //							байт	бит на байт 	мкс в секунде скорость
;;;677    	Delay = (u32)(1			*10						*1000000 		/ baud_rate);
00023a  fbb1f0f0          UDIV     r0,r1,r0
00023e  4971              LDR      r1,|L1.1028|
000240  6048              STR      r0,[r1,#4]  ; Delay
;;;678    	// задержка в мкс
;;;679    }
000242  4770              BX       lr
;;;680    
                          ENDP

                  InitHalfDupControlSignal PROC
;;;696    
;;;697    void InitHalfDupControlSignal(void){
000244  4873              LDR      r0,|L1.1044|
;;;698    	// инициализация выходных сигналов для полудуплекса
;;;699    	// Только для UART1 !!!!!!!!!!!! 
;;;700    	// DE(2.2) = 1; RE(2.3)=0
;;;701    	DE_PORT->FIODIR |= DE_PIN_MASK; // DE(2.2) - выходной пин 
000246  6c01              LDR      r1,[r0,#0x40]
000248  f0410104          ORR      r1,r1,#4
00024c  6401              STR      r1,[r0,#0x40]
;;;702    	RE_PORT->FIODIR |= RE_PIN_MASK; // RE(2.3) - выходной пин 
00024e  6c01              LDR      r1,[r0,#0x40]
000250  f0410108          ORR      r1,r1,#8
000254  6401              STR      r1,[r0,#0x40]
;;;703    	// настройка на прием по умолчанию (освобождение линии)
;;;704    //	FreeUartLine();
;;;705    	DefFreeUartLine; // без () т к define
000256  210c              MOVS     r1,#0xc
000258  65c1              STR      r1,[r0,#0x5c]
;;;706    }
00025a  4770              BX       lr
;;;707    
                          ENDP

                  UARTx_Init PROC
;;;324    
;;;325    BOOL UARTx_Init(u8 num, 
00025c  e92d4ff0          PUSH     {r4-r11,lr}
;;;326    				UART_DUPLEX_Type dup,	
;;;327    				u32 baud_rate,
;;;328    				UART_PARITY_Type par,
;;;329    				UART_DATABIT_Type dbits,
;;;330    				UART_STOPBIT_Type stopbits)
;;;331    {
000260  0007              MOVS     r7,r0
;;;332    	// UART Configuration structure variable
;;;333    	UART_CFG_Type UARTConfigStruct;
;;;334    
;;;335    	// UART FIFO configuration Struct variable
;;;336    	UART_FIFO_CFG_Type UARTFIFOConfigStruct;
;;;337    
;;;338    	// Pin configuration for UART
;;;339    	PINSEL_CFG_Type PinCfg;
;;;340    
;;;341    	// RS485 configuration
;;;342    //	UART1_RS485_CTRLCFG_Type rs485cfg;
;;;343    ///*	
;;;344    	LPC_UART_TypeDef *UARTPort;
;;;345    	UART_RING_BUFFER_T * rb;
;;;346    
;;;347    	switch (num) {
;;;348    		case 0:
;;;349    			PinCfg.Funcnum = 1;
;;;350    			PinCfg.OpenDrain = 0;
;;;351    			PinCfg.Pinmode = 0;
;;;352    			PinCfg.Pinnum = 2;
;;;353    			PinCfg.Portnum = 0;
;;;354    			PINSEL_ConfigPin(&PinCfg);
;;;355    			PinCfg.Pinnum = 3;
;;;356    			PINSEL_ConfigPin(&PinCfg);
;;;357    			UARTPort = LPC_UART0;
;;;358    			rb = &rb0;
;;;359    			break;
;;;360    		case 1:
;;;361    			// RS 232
;;;362    			PinCfg.Funcnum = 2;
;;;363    			PinCfg.OpenDrain = 0;
;;;364    			PinCfg.Pinmode = 0;
;;;365    			PinCfg.Portnum = 2;
;;;366    			PinCfg.Pinnum = 0;
;;;367    			PINSEL_ConfigPin(&PinCfg);
;;;368    			PinCfg.Pinnum = 1;
;;;369    			PINSEL_ConfigPin(&PinCfg);
;;;370    			UARTPort = (LPC_UART_TypeDef*)LPC_UART1;
000262  f8df81a8          LDR      r8,|L1.1036|
000266  b085              SUB      sp,sp,#0x14           ;331
000268  469a              MOV      r10,r3                ;331
00026a  4691              MOV      r9,r2                 ;331
00026c  468b              MOV      r11,r1                ;331
00026e  f04f0501          MOV      r5,#1                 ;331
000272  f04f0002          MOV      r0,#2                 ;352
000276  f04f0400          MOV      r4,#0
00027a  d005              BEQ      |L1.648|
00027c  2f01              CMP      r7,#1                 ;347
00027e  d019              BEQ      |L1.692|
;;;371    			rb = &rb1;
;;;372    			break;
;;;373    		default: return FALSE;
000280  2000              MOVS     r0,#0
                  |L1.642|
;;;374    	}// switch (num)
;;;375    
;;;376    
;;;377    	UARTConfigStruct.Baud_rate = baud_rate;
;;;378    	UARTConfigStruct.Databits = dbits;
;;;379    	UARTConfigStruct.Parity = par;
;;;380    	UARTConfigStruct.Stopbits = stopbits;
;;;381    
;;;382    	// Initialize UART0 peripheral with given to corresponding parameter
;;;383    	UART_Init(UARTPort, &UARTConfigStruct);
;;;384    
;;;385    
;;;386    //	 Initialize FIFOConfigStruct to default state:
;;;387    //	 * 				- FIFO_DMAMode = DISABLE
;;;388    //	 * 				- FIFO_Level = UART_FIFO_TRGLEV0
;;;389    //	 * 				- FIFO_ResetRxBuf = ENABLE
;;;390    //	 * 				- FIFO_ResetTxBuf = ENABLE
;;;391    //	 * 				- FIFO_State = ENABLE
;;;392    	
;;;393    	UART_FIFOConfigStructInit(&UARTFIFOConfigStruct);
;;;394    	// Initialize FIFO for UART0 peripheral
;;;395    	UART_FIFOConfig(UARTPort, &UARTFIFOConfigStruct);
;;;396      
;;;397    	// Enable UART Transmit
;;;398    	UART_TxCmd(UARTPort, ENABLE);
;;;399    
;;;400        // Enable UART Rx interrupt 
;;;401    	UART_IntConfig(UARTPort, UART_INTCFG_RBR, ENABLE);
;;;402    	// Enable UART line status interrupt 
;;;403    	UART_IntConfig(UARTPort, UART_INTCFG_RLS, ENABLE);
;;;404    
;;;405    
;;;406    //	 * Do not enable transmit interrupt here, since it is handled by
;;;407    //	 * UART_Send() function, just to reset Tx Interrupt state for the
;;;408    //	 * first time
;;;409    	switch (num) {
;;;410    		case 0: TxIntStat0 = RESET; break;
;;;411    		case 1: TxIntStat1 = RESET; break;
;;;412    	}
;;;413    
;;;414    	// Reset ring buf head and tail idx
;;;415    	__BUF_RESET((*rb).rx_head);
;;;416    	__BUF_RESET((*rb).rx_tail);
;;;417    	__BUF_RESET((*rb).tx_head);
;;;418    	__BUF_RESET((*rb).tx_tail);
;;;419    	(*rb).txfree = UART_RING_BUFSIZE; 	// буфер пустой
;;;420    	(*rb).rxdata = 0;					// буфер пустой 
;;;421    	(*rb).dup = dup;					// установка дуплекса
;;;422    
;;;423    	if (UARTPort == (LPC_UART_TypeDef*)LPC_UART1) {
;;;424    		if ((*rb).dup) {
;;;425    			 InitHalfDupControlSignal();
;;;426    			 InitHalfDupWaitInterval(baud_rate);
;;;427    		} else InitFullDupControlSignal();
;;;428    	} 
;;;429    
;;;430    	switch (num) {
;;;431    		case 0: 
;;;432    		  NVIC_EnableIRQ(UART0_IRQn);
;;;433    			NVIC_SetPriority(UART0_IRQn, 3);
;;;434    		break;
;;;435    		case 1: 
;;;436    			NVIC_EnableIRQ(UART1_IRQn);
;;;437    			NVIC_SetPriority(UART1_IRQn, 2);
;;;438    		break;
;;;439    	}
;;;440    
;;;441    	return TRUE;
;;;442    //*/
;;;443    }
000282  b005              ADD      sp,sp,#0x14
000284  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.648|
000288  f88d5002          STRB     r5,[sp,#2]            ;349
00028c  f88d4003          STRB     r4,[sp,#3]            ;351
000290  f88d0001          STRB     r0,[sp,#1]            ;352
000294  f88d4004          STRB     r4,[sp,#4]            ;350
000298  f88d4000          STRB     r4,[sp,#0]            ;353
00029c  4668              MOV      r0,sp                 ;354
00029e  f7fffffe          BL       PINSEL_ConfigPin
0002a2  2003              MOVS     r0,#3                 ;355
0002a4  f88d0001          STRB     r0,[sp,#1]            ;355
0002a8  4668              MOV      r0,sp                 ;356
0002aa  f7fffffe          BL       PINSEL_ConfigPin
0002ae  4e53              LDR      r6,|L1.1020|
0002b0  4d53              LDR      r5,|L1.1024|
0002b2  e013              B        |L1.732|
                  |L1.692|
0002b4  f88d0002          STRB     r0,[sp,#2]            ;362
0002b8  f88d4003          STRB     r4,[sp,#3]            ;364
0002bc  f88d0000          STRB     r0,[sp,#0]            ;365
0002c0  f88d4004          STRB     r4,[sp,#4]            ;363
0002c4  f88d4001          STRB     r4,[sp,#1]            ;366
0002c8  4668              MOV      r0,sp                 ;367
0002ca  f7fffffe          BL       PINSEL_ConfigPin
0002ce  f88d5001          STRB     r5,[sp,#1]            ;368
0002d2  4668              MOV      r0,sp                 ;369
0002d4  f7fffffe          BL       PINSEL_ConfigPin
0002d8  4d4d              LDR      r5,|L1.1040|
0002da  4646              MOV      r6,r8                 ;370
                  |L1.732|
0002dc  980e              LDR      r0,[sp,#0x38]         ;378
0002de  f88d000d          STRB     r0,[sp,#0xd]          ;378
0002e2  f88da00c          STRB     r10,[sp,#0xc]         ;379
0002e6  980f              LDR      r0,[sp,#0x3c]         ;380
0002e8  f88d000e          STRB     r0,[sp,#0xe]          ;380
0002ec  f8cd9008          STR      r9,[sp,#8]            ;378
0002f0  a902              ADD      r1,sp,#8              ;383
0002f2  4630              MOV      r0,r6                 ;383
0002f4  f7fffffe          BL       UART_Init
0002f8  a804              ADD      r0,sp,#0x10           ;393
0002fa  f7fffffe          BL       UART_FIFOConfigStructInit
0002fe  a904              ADD      r1,sp,#0x10           ;395
000300  4630              MOV      r0,r6                 ;395
000302  f7fffffe          BL       UART_FIFOConfig
000306  2101              MOVS     r1,#1                 ;398
000308  4630              MOV      r0,r6                 ;398
00030a  f7fffffe          BL       UART_TxCmd
00030e  2201              MOVS     r2,#1                 ;401
000310  2100              MOVS     r1,#0                 ;401
000312  4630              MOV      r0,r6                 ;401
000314  f7fffffe          BL       UART_IntConfig
000318  2201              MOVS     r2,#1                 ;403
00031a  2102              MOVS     r1,#2                 ;403
00031c  4630              MOV      r0,r6                 ;403
00031e  f7fffffe          BL       UART_IntConfig
000322  4838              LDR      r0,|L1.1028|
000324  b117              CBZ      r7,|L1.812|
000326  2f01              CMP      r7,#1                 ;409
000328  d103              BNE      |L1.818|
00032a  e001              B        |L1.816|
                  |L1.812|
00032c  7004              STRB     r4,[r0,#0]            ;410
00032e  e000              B        |L1.818|
                  |L1.816|
000330  7044              STRB     r4,[r0,#1]            ;411
                  |L1.818|
000332  60ac              STR      r4,[r5,#8]            ;415
000334  60ec              STR      r4,[r5,#0xc]          ;416
000336  602c              STR      r4,[r5,#0]            ;417
000338  606c              STR      r4,[r5,#4]            ;418
00033a  f44f7000          MOV      r0,#0x200             ;419
00033e  f8a50412          STRH     r0,[r5,#0x412]        ;419
000342  f8854414          STRB     r4,[r5,#0x414]        ;420
000346  f885b410          STRB     r11,[r5,#0x410]       ;421
00034a  4546              CMP      r6,r8                 ;423
00034c  d10a              BNE      |L1.868|
00034e  f8950410          LDRB     r0,[r5,#0x410]        ;424
000352  b128              CBZ      r0,|L1.864|
000354  f7fffffe          BL       InitHalfDupControlSignal
000358  4648              MOV      r0,r9                 ;426
00035a  f7fffffe          BL       InitHalfDupWaitInterval
00035e  e001              B        |L1.868|
                  |L1.864|
000360  f7fffffe          BL       InitFullDupControlSignal
                  |L1.868|
000364  b117              CBZ      r7,|L1.876|
000366  2f01              CMP      r7,#1                 ;430
000368  d10d              BNE      |L1.902|
00036a  e005              B        |L1.888|
                  |L1.876|
00036c  2005              MOVS     r0,#5                 ;432
00036e  f7fffffe          BL       __NVIC_EnableIRQ
000372  2103              MOVS     r1,#3                 ;433
000374  2005              MOVS     r0,#5                 ;433
000376  e004              B        |L1.898|
                  |L1.888|
000378  2006              MOVS     r0,#6                 ;436
00037a  f7fffffe          BL       __NVIC_EnableIRQ
00037e  2102              MOVS     r1,#2                 ;437
000380  2006              MOVS     r0,#6                 ;437
                  |L1.898|
000382  f7fffffe          BL       __NVIC_SetPriority
                  |L1.902|
000386  2001              MOVS     r0,#1                 ;441
000388  e77b              B        |L1.642|
;;;444    
                          ENDP

                  UARTx_PlaceForSend PROC
;;;445    
;;;446    u16 UARTx_PlaceForSend(u8 num)
00038a  b108              CBZ      r0,|L1.912|
;;;447    // возвращает количество свободных байт для передачи
;;;448    {
;;;449    	if (num/*==1*/) return rb1.txfree;
00038c  4820              LDR      r0,|L1.1040|
00038e  e000              B        |L1.914|
                  |L1.912|
;;;450    	else return rb0.txfree;
000390  481b              LDR      r0,|L1.1024|
                  |L1.914|
000392  f8b00412          LDRH     r0,[r0,#0x412]  ; rb0
;;;451    }
000396  4770              BX       lr
;;;452    
                          ENDP

                  UARTx_SendBuffer PROC
;;;453    u16 UARTx_SendBuffer(u8 num,u8 * buffer,u16 buflen)
000398  e92d47f0          PUSH     {r4-r10,lr}
;;;454    // передает buffer размером count
;;;455    // возвращает количество фактически переданных байт
;;;456    {
00039c  4616              MOV      r6,r2
00039e  f1b00900          SUBS     r9,r0,#0
;;;457        u8 *data = (u8 *) buffer;
0003a2  460d              MOV      r5,r1
;;;458        u32 bytes = 0;
0003a4  f04f0700          MOV      r7,#0
0003a8  d005              BEQ      |L1.950|
;;;459    	LPC_UART_TypeDef *UARTPort;
;;;460    	volatile UART_RING_BUFFER_T * rb;
;;;461    	switch (num) {
0003aa  f1b90f01          CMP      r9,#1
0003ae  d006              BEQ      |L1.958|
;;;462    		case 0:
;;;463    			UARTPort = LPC_UART0;
;;;464    			rb = &rb0;
;;;465    			break;
;;;466    		case 1:
;;;467    			UARTPort = (LPC_UART_TypeDef*)LPC_UART1;
;;;468    			rb = &rb1;
;;;469    			break;
;;;470    		default: return 0;// ошибка 
0003b0  2000              MOVS     r0,#0
                  |L1.946|
;;;471    	}
;;;472      UART_IntConfig(UARTPort, UART_INTCFG_THRE, DISABLE);
;;;473    	while ((buflen > 0) && (!__BUF_IS_FULL((*rb).tx_head, (*rb).tx_tail)))
;;;474    	{
;;;475    		(*rb).tx[(*rb).tx_head] = *data;
;;;476    		data++;
;;;477    		__BUF_INCR((*rb).tx_head);
;;;478    		bytes++;
;;;479    		buflen--;
;;;480    		(*rb).txfree--;
;;;481    	}
;;;482    // отладка переполнения
;;;483    //	if (buflen > 0) SetPin(OUT13);
;;;484    	switch (num) {	 
;;;485    		case 0:
;;;486    			if (TxIntStat0 == RESET)  
;;;487    				UART0_IntTransmit();
;;;488    			else
;;;489    				UART_IntConfig(UARTPort, UART_INTCFG_THRE, ENABLE);
;;;490    			break;
;;;491    		case 1:
;;;492    			if (TxIntStat1 == RESET)  
;;;493    				UART1_IntTransmit();
;;;494    			else
;;;495    				UART_IntConfig(UARTPort, UART_INTCFG_THRE, ENABLE);
;;;496    			break;
;;;497    		default: break; // ошибка
;;;498    	}
;;;499        return bytes;
;;;500    }
0003b2  e8bd87f0          POP      {r4-r10,pc}
                  |L1.950|
0003b6  4811              LDR      r0,|L1.1020|
0003b8  4c11              LDR      r4,|L1.1024|
0003ba  4680              MOV      r8,r0                 ;463
0003bc  e002              B        |L1.964|
                  |L1.958|
0003be  4813              LDR      r0,|L1.1036|
0003c0  4c13              LDR      r4,|L1.1040|
0003c2  4680              MOV      r8,r0                 ;467
                  |L1.964|
0003c4  2200              MOVS     r2,#0                 ;472
0003c6  2101              MOVS     r1,#1                 ;472
0003c8  f7fffffe          BL       UART_IntConfig
0003cc  f1040010          ADD      r0,r4,#0x10           ;475
0003d0  e011              B        |L1.1014|
0003d2  bf00              NOP                            ;475
                  |L1.980|
0003d4  f8151b01          LDRB     r1,[r5],#1            ;475
0003d8  6822              LDR      r2,[r4,#0]            ;475
0003da  5411              STRB     r1,[r2,r0]            ;475
0003dc  6821              LDR      r1,[r4,#0]            ;477
0003de  1c49              ADDS     r1,r1,#1              ;477
0003e0  f3c10108          UBFX     r1,r1,#0,#9           ;477
0003e4  6021              STR      r1,[r4,#0]            ;477
0003e6  1e76              SUBS     r6,r6,#1              ;477
0003e8  f8b41412          LDRH     r1,[r4,#0x412]        ;480
0003ec  b2b6              UXTH     r6,r6                 ;479
0003ee  1e49              SUBS     r1,r1,#1              ;480
0003f0  f8a41412          STRH     r1,[r4,#0x412]        ;480
0003f4  1c7f              ADDS     r7,r7,#1              ;480
                  |L1.1014|
0003f6  b1ce              CBZ      r6,|L1.1068|
0003f8  6861              LDR      r1,[r4,#4]            ;473
0003fa  e00f              B        |L1.1052|
                  |L1.1020|
                          DCD      0x4000c000
                  |L1.1024|
                          DCD      ||.bss||
                  |L1.1028|
                          DCD      ||.data||
                  |L1.1032|
                          DCD      ||ti||
                  |L1.1036|
                          DCD      0x40010000
                  |L1.1040|
                          DCD      ||.bss||+0x418
                  |L1.1044|
                          DCD      0x2009c000
                  |L1.1048|
                          DCD      0x00989680
                  |L1.1052|
00041c  f3c10208          UBFX     r2,r1,#0,#9           ;473
000420  6821              LDR      r1,[r4,#0]            ;473
000422  1c49              ADDS     r1,r1,#1              ;473
000424  f3c10108          UBFX     r1,r1,#0,#9           ;473
000428  428a              CMP      r2,r1                 ;473
00042a  d1d3              BNE      |L1.980|
                  |L1.1068|
00042c  48a0              LDR      r0,|L1.1712|
00042e  ea5f0109          MOVS     r1,r9                 ;484
000432  d003              BEQ      |L1.1084|
000434  f1b90f01          CMP      r9,#1                 ;484
000438  d10c              BNE      |L1.1108|
00043a  e004              B        |L1.1094|
                  |L1.1084|
00043c  7800              LDRB     r0,[r0,#0]            ;486  ; TxIntStat0
00043e  b920              CBNZ     r0,|L1.1098|
000440  f7fffffe          BL       UART0_IntTransmit
000444  e006              B        |L1.1108|
                  |L1.1094|
000446  7840              LDRB     r0,[r0,#1]            ;492  ; TxIntStat1
000448  b130              CBZ      r0,|L1.1112|
                  |L1.1098|
00044a  2201              MOVS     r2,#1                 ;495
00044c  4611              MOV      r1,r2                 ;495
00044e  4640              MOV      r0,r8                 ;495
000450  f7fffffe          BL       UART_IntConfig
                  |L1.1108|
000454  b2b8              UXTH     r0,r7                 ;499
000456  e7ac              B        |L1.946|
                  |L1.1112|
000458  f7fffffe          BL       UART1_IntTransmit
00045c  e7fa              B        |L1.1108|
;;;501    
                          ENDP

                  UART0_SendBuffer PROC
;;;502    u16 UART0_SendBuffer(u8 * buffer,u16 buflen)
00045e  e92d41f0          PUSH     {r4-r8,lr}
;;;503    // передает buffer размером count
;;;504    // возвращает количество фактически переданных байт
;;;505    {
;;;506    		u32 bytes = 0;
;;;507    		
;;;508    //		UART_IntConfig(LPC_UART0, UART_INTCFG_THRE, DISABLE);
;;;509    		LPC_UART0->IER &= (~UART_IER_THREINT_EN) & UART_IER_BITMASK;
000462  4d94              LDR      r5,|L1.1716|
000464  2400              MOVS     r4,#0                 ;506
000466  686a              LDR      r2,[r5,#4]
000468  f2403305          MOV      r3,#0x305
00046c  401a              ANDS     r2,r2,r3
00046e  606a              STR      r2,[r5,#4]
;;;510    		while ((buflen > 0) && (!__BUF_IS_FULL(rb0.tx_head, rb0.tx_tail)))
;;;511    		{
;;;512    			rb0.tx[rb0.tx_head] = *buffer;
000470  4a91              LDR      r2,|L1.1720|
000472  f1020310          ADD      r3,r2,#0x10
000476  e010              B        |L1.1178|
                  |L1.1144|
000478  f8106b01          LDRB     r6,[r0],#1
00047c  6817              LDR      r7,[r2,#0]  ; rb0
00047e  54fe              STRB     r6,[r7,r3]
;;;513    			buffer++;
;;;514    			__BUF_INCR(rb0.tx_head);
000480  6816              LDR      r6,[r2,#0]  ; rb0
000482  1c76              ADDS     r6,r6,#1
000484  f3c60608          UBFX     r6,r6,#0,#9
000488  6016              STR      r6,[r2,#0]  ; rb0
00048a  1e49              SUBS     r1,r1,#1
;;;515    			bytes++;
;;;516    			buflen--;
;;;517    			rb0.txfree--;
00048c  f8b26412          LDRH     r6,[r2,#0x412]  ; rb0
000490  b289              UXTH     r1,r1                 ;516
000492  1e76              SUBS     r6,r6,#1
000494  f8a26412          STRH     r6,[r2,#0x412]
000498  1c64              ADDS     r4,r4,#1
                  |L1.1178|
00049a  b141              CBZ      r1,|L1.1198|
00049c  6856              LDR      r6,[r2,#4]            ;510  ; rb0
00049e  f3c60708          UBFX     r7,r6,#0,#9           ;510
0004a2  6816              LDR      r6,[r2,#0]            ;510  ; rb0
0004a4  1c76              ADDS     r6,r6,#1              ;510
0004a6  f3c60608          UBFX     r6,r6,#0,#9           ;510
0004aa  42b7              CMP      r7,r6                 ;510
0004ac  d1e4              BNE      |L1.1144|
                  |L1.1198|
;;;518    		}
;;;519    
;;;520    		if (TxIntStat0 == RESET) 
0004ae  4880              LDR      r0,|L1.1712|
0004b0  7800              LDRB     r0,[r0,#0]  ; TxIntStat0
0004b2  b130              CBZ      r0,|L1.1218|
;;;521    			UART0_IntTransmit();
;;;522    		else
;;;523    //			UART_IntConfig(LPC_UART0, UART_INTCFG_THRE, ENABLE);
;;;524    			LPC_UART0->IER |= UART_IER_THREINT_EN;
0004b4  6868              LDR      r0,[r5,#4]
0004b6  f0400002          ORR      r0,r0,#2
0004ba  6068              STR      r0,[r5,#4]
                  |L1.1212|
;;;525    
;;;526        return bytes;
0004bc  b2a0              UXTH     r0,r4
                  |L1.1214|
;;;527    }
0004be  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1218|
0004c2  f7fffffe          BL       UART0_IntTransmit
0004c6  e7f9              B        |L1.1212|
;;;528    
                          ENDP

                  UART1_SendBuffer PROC
;;;529    u16 UART1_SendBuffer(u8 * buffer,u16 buflen)
0004c8  e92d41f0          PUSH     {r4-r8,lr}
;;;530    // передает buffer размером count
;;;531    // возвращает количество фактически переданных байт
;;;532    {
;;;533    		u32 bytes = 0;
;;;534    		
;;;535    //		UART_IntConfig(LPC_UART0, UART_INTCFG_THRE, DISABLE);
;;;536    		LPC_UART1->IER &= (~UART_IER_THREINT_EN) & UART_IER_BITMASK;
0004cc  4d7b              LDR      r5,|L1.1724|
0004ce  2400              MOVS     r4,#0                 ;533
0004d0  686a              LDR      r2,[r5,#4]
0004d2  f2403305          MOV      r3,#0x305
0004d6  401a              ANDS     r2,r2,r3
0004d8  606a              STR      r2,[r5,#4]
;;;537    		while ((buflen > 0) && (!__BUF_IS_FULL(rb1.tx_head, rb1.tx_tail)))
;;;538    		{
;;;539    			rb1.tx[rb1.tx_head] = *buffer;
0004da  4a79              LDR      r2,|L1.1728|
0004dc  f1020310          ADD      r3,r2,#0x10
0004e0  e011              B        |L1.1286|
0004e2  bf00              NOP      
                  |L1.1252|
0004e4  f8106b01          LDRB     r6,[r0],#1
0004e8  6817              LDR      r7,[r2,#0]  ; rb1
0004ea  54fe              STRB     r6,[r7,r3]
;;;540    			buffer++;
;;;541    			__BUF_INCR(rb1.tx_head);
0004ec  6816              LDR      r6,[r2,#0]  ; rb1
0004ee  1c76              ADDS     r6,r6,#1
0004f0  f3c60608          UBFX     r6,r6,#0,#9
0004f4  6016              STR      r6,[r2,#0]  ; rb1
0004f6  1e49              SUBS     r1,r1,#1
;;;542    			bytes++;
;;;543    			buflen--;
;;;544    			rb1.txfree--;
0004f8  f8b26412          LDRH     r6,[r2,#0x412]  ; rb1
0004fc  b289              UXTH     r1,r1                 ;543
0004fe  1e76              SUBS     r6,r6,#1
000500  f8a26412          STRH     r6,[r2,#0x412]
000504  1c64              ADDS     r4,r4,#1
                  |L1.1286|
000506  b141              CBZ      r1,|L1.1306|
000508  6856              LDR      r6,[r2,#4]            ;537  ; rb1
00050a  f3c60708          UBFX     r7,r6,#0,#9           ;537
00050e  6816              LDR      r6,[r2,#0]            ;537  ; rb1
000510  1c76              ADDS     r6,r6,#1              ;537
000512  f3c60608          UBFX     r6,r6,#0,#9           ;537
000516  42b7              CMP      r7,r6                 ;537
000518  d1e4              BNE      |L1.1252|
                  |L1.1306|
;;;545    		}
;;;546    
;;;547    		if (TxIntStat1 == RESET) 
00051a  4865              LDR      r0,|L1.1712|
00051c  7840              LDRB     r0,[r0,#1]  ; TxIntStat1
00051e  b128              CBZ      r0,|L1.1324|
;;;548    			UART1_IntTransmit();
;;;549    		else
;;;550    //			UART_IntConfig(LPC_UART0, UART_INTCFG_THRE, ENABLE);
;;;551    			LPC_UART1->IER |= UART_IER_THREINT_EN;
000520  6868              LDR      r0,[r5,#4]
000522  f0400002          ORR      r0,r0,#2
000526  6068              STR      r0,[r5,#4]
                  |L1.1320|
;;;552    
;;;553        return bytes;
000528  b2a0              UXTH     r0,r4
;;;554    }
00052a  e7c8              B        |L1.1214|
                  |L1.1324|
00052c  f7fffffe          BL       UART1_IntTransmit
000530  e7fa              B        |L1.1320|
;;;555    
                          ENDP

                  UARTx_ReadyRecvData PROC
;;;556    
;;;557    u16 UARTx_ReadyRecvData(u8 num)
000532  b108              CBZ      r0,|L1.1336|
;;;558    // возвращает количество байт готовых к приему
;;;559    {
;;;560    	if (num/*==1*/) return rb1.rxdata;
000534  4862              LDR      r0,|L1.1728|
000536  e000              B        |L1.1338|
                  |L1.1336|
;;;561    	else return rb0.rxdata;
000538  485f              LDR      r0,|L1.1720|
                  |L1.1338|
00053a  f8900414          LDRB     r0,[r0,#0x414]  ; rb0
;;;562    }
00053e  4770              BX       lr
;;;563    
                          ENDP

                  UARTx_RecvBuffer PROC
;;;564    u16 UARTx_RecvBuffer(u8 num,u8 * buffer,u16 buflen)
000540  e92d41f0          PUSH     {r4-r8,lr}
;;;565    // принимает count байт в buffer
;;;566    // возвращает количество фактически принятых байт
;;;567    {
000544  4616              MOV      r6,r2
;;;568        u8 *data = (u8 *) buffer;
000546  460d              MOV      r5,r1
;;;569        u32 bytes = 0;
000548  2700              MOVS     r7,#0
00054a  b118              CBZ      r0,|L1.1364|
;;;570    	LPC_UART_TypeDef *UARTPort;
;;;571    	UART_RING_BUFFER_T * rb;
;;;572    
;;;573    	switch (num) {
00054c  2801              CMP      r0,#1
00054e  d005              BEQ      |L1.1372|
;;;574    		case 0:
;;;575    			UARTPort = LPC_UART0;
;;;576    			rb = &rb0;
;;;577    			break;
;;;578    		case 1:
;;;579    			UARTPort = (LPC_UART_TypeDef*)LPC_UART1;
;;;580    			rb = &rb1;
;;;581    			break;
;;;582    		default: return 0;// ошибка 
000550  2000              MOVS     r0,#0
;;;583    	}
;;;584    
;;;585    	UART_IntConfig(UARTPort, UART_INTCFG_RBR, DISABLE);
;;;586    	while ((buflen > 0) && (!(__BUF_IS_EMPTY((*rb).rx_head, (*rb).rx_tail))))
;;;587    	{
;;;588    		*data = (*rb).rx[(*rb).rx_tail];
;;;589    		data++;
;;;590    		__BUF_INCR((*rb).rx_tail);
;;;591    		bytes++;
;;;592    		buflen--;
;;;593    		(*rb).rxdata--;
;;;594    	}
;;;595    
;;;596    	UART_IntConfig(UARTPort, UART_INTCFG_RBR, ENABLE);
;;;597        return bytes;
;;;598    }
000552  e7b4              B        |L1.1214|
                  |L1.1364|
000554  4857              LDR      r0,|L1.1716|
000556  4c58              LDR      r4,|L1.1720|
000558  4680              MOV      r8,r0                 ;575
00055a  e002              B        |L1.1378|
                  |L1.1372|
00055c  4857              LDR      r0,|L1.1724|
00055e  4c58              LDR      r4,|L1.1728|
000560  4680              MOV      r8,r0                 ;579
                  |L1.1378|
000562  2200              MOVS     r2,#0                 ;585
000564  4611              MOV      r1,r2                 ;585
000566  f7fffffe          BL       UART_IntConfig
00056a  f5047004          ADD      r0,r4,#0x210          ;588
00056e  e010              B        |L1.1426|
                  |L1.1392|
000570  68e1              LDR      r1,[r4,#0xc]          ;588
000572  5c09              LDRB     r1,[r1,r0]            ;588
000574  f8051b01          STRB     r1,[r5],#1            ;588
000578  68e1              LDR      r1,[r4,#0xc]          ;590
00057a  1c49              ADDS     r1,r1,#1              ;590
00057c  f3c10108          UBFX     r1,r1,#0,#9           ;590
000580  60e1              STR      r1,[r4,#0xc]          ;590
000582  1e76              SUBS     r6,r6,#1              ;590
000584  f8941414          LDRB     r1,[r4,#0x414]        ;593
000588  b2b6              UXTH     r6,r6                 ;592
00058a  1e49              SUBS     r1,r1,#1              ;593
00058c  f8841414          STRB     r1,[r4,#0x414]        ;593
000590  1c7f              ADDS     r7,r7,#1              ;593
                  |L1.1426|
000592  b13e              CBZ      r6,|L1.1444|
000594  68a1              LDR      r1,[r4,#8]            ;586
000596  68e2              LDR      r2,[r4,#0xc]          ;586
000598  f3c10108          UBFX     r1,r1,#0,#9           ;586
00059c  f3c20208          UBFX     r2,r2,#0,#9           ;586
0005a0  4291              CMP      r1,r2                 ;586
0005a2  d1e5              BNE      |L1.1392|
                  |L1.1444|
0005a4  2201              MOVS     r2,#1                 ;596
0005a6  2100              MOVS     r1,#0                 ;596
0005a8  4640              MOV      r0,r8                 ;596
0005aa  f7fffffe          BL       UART_IntConfig
0005ae  b2b8              UXTH     r0,r7                 ;597
0005b0  e785              B        |L1.1214|
;;;599    
                          ENDP

                  UART0_RecvBuffer PROC
;;;600    u16 UART0_RecvBuffer(u8 * buffer,u16 buflen)
0005b2  b5f0              PUSH     {r4-r7,lr}
;;;601    // принимает count байт в buffer
;;;602    // возвращает количество фактически принятых байт
;;;603    {
;;;604    		u32 bytes = 0;
;;;605    
;;;606    		//UART_IntConfig(LPC_UART0, UART_INTCFG_RBR, DISABLE);
;;;607    		LPC_UART0->IER &= (~UART_IER_RBRINT_EN) & UART_IER_BITMASK;
0005b4  4c3f              LDR      r4,|L1.1716|
0005b6  2500              MOVS     r5,#0                 ;604
0005b8  6862              LDR      r2,[r4,#4]
0005ba  f2403306          MOV      r3,#0x306
0005be  401a              ANDS     r2,r2,r3
0005c0  6062              STR      r2,[r4,#4]
;;;608    		while ((buflen > 0) && (!(__BUF_IS_EMPTY(rb0.rx_head, rb0.rx_tail))))
;;;609    		{
;;;610    			*buffer = rb0.rx[rb0.rx_tail];
0005c2  4a3d              LDR      r2,|L1.1720|
0005c4  f5027304          ADD      r3,r2,#0x210
0005c8  e010              B        |L1.1516|
                  |L1.1482|
0005ca  68d6              LDR      r6,[r2,#0xc]  ; rb0
0005cc  5cf6              LDRB     r6,[r6,r3]
0005ce  f8006b01          STRB     r6,[r0],#1
;;;611    			buffer++;
;;;612    			__BUF_INCR(rb0.rx_tail);
0005d2  68d6              LDR      r6,[r2,#0xc]  ; rb0
0005d4  1c76              ADDS     r6,r6,#1
0005d6  f3c60608          UBFX     r6,r6,#0,#9
0005da  60d6              STR      r6,[r2,#0xc]  ; rb0
0005dc  1e49              SUBS     r1,r1,#1
;;;613    			bytes++;
;;;614    			buflen--;
;;;615    			rb0.rxdata--;
0005de  f8926414          LDRB     r6,[r2,#0x414]  ; rb0
0005e2  b289              UXTH     r1,r1                 ;614
0005e4  1e76              SUBS     r6,r6,#1
0005e6  f8826414          STRB     r6,[r2,#0x414]
0005ea  1c6d              ADDS     r5,r5,#1
                  |L1.1516|
0005ec  b139              CBZ      r1,|L1.1534|
0005ee  6896              LDR      r6,[r2,#8]            ;608  ; rb0
0005f0  68d7              LDR      r7,[r2,#0xc]          ;608  ; rb0
0005f2  f3c60608          UBFX     r6,r6,#0,#9           ;608
0005f6  f3c70708          UBFX     r7,r7,#0,#9           ;608
0005fa  42be              CMP      r6,r7                 ;608
0005fc  d1e5              BNE      |L1.1482|
                  |L1.1534|
;;;616    		}
;;;617    		//UART_IntConfig(LPC_UART0, UART_INTCFG_RBR, ENABLE);
;;;618    		LPC_UART0->IER |= UART_IER_RBRINT_EN;
0005fe  6860              LDR      r0,[r4,#4]
000600  f0400001          ORR      r0,r0,#1
000604  6060              STR      r0,[r4,#4]
;;;619    		return bytes;
000606  b2a8              UXTH     r0,r5
;;;620    }
000608  bdf0              POP      {r4-r7,pc}
;;;621    
                          ENDP

                  UART1_RecvBuffer PROC
;;;622    u16 UART1_RecvBuffer(u8 * buffer,u16 buflen)
00060a  b5f0              PUSH     {r4-r7,lr}
;;;623    // принимает count байт в buffer
;;;624    // возвращает количество фактически принятых байт
;;;625    {
;;;626    		u32 bytes = 0;
;;;627    		//UART_IntConfig(LPC_UART1, UART_INTCFG_RBR, DISABLE);
;;;628    		LPC_UART1->IER &= (~UART_IER_RBRINT_EN) & UART_IER_BITMASK;
00060c  4c2b              LDR      r4,|L1.1724|
00060e  2500              MOVS     r5,#0                 ;626
000610  6862              LDR      r2,[r4,#4]
000612  f2403306          MOV      r3,#0x306
000616  401a              ANDS     r2,r2,r3
000618  6062              STR      r2,[r4,#4]
;;;629    		while ((buflen > 0) && (!(__BUF_IS_EMPTY(rb1.rx_head, rb1.rx_tail))))
;;;630    		{
;;;631    			*buffer = rb1.rx[rb1.rx_tail];
00061a  4a29              LDR      r2,|L1.1728|
00061c  f5027304          ADD      r3,r2,#0x210
000620  e010              B        |L1.1604|
                  |L1.1570|
000622  68d6              LDR      r6,[r2,#0xc]  ; rb1
000624  5cf6              LDRB     r6,[r6,r3]
000626  f8006b01          STRB     r6,[r0],#1
;;;632    			buffer++;
;;;633    			__BUF_INCR(rb1.rx_tail);
00062a  68d6              LDR      r6,[r2,#0xc]  ; rb1
00062c  1c76              ADDS     r6,r6,#1
00062e  f3c60608          UBFX     r6,r6,#0,#9
000632  60d6              STR      r6,[r2,#0xc]  ; rb1
000634  1e49              SUBS     r1,r1,#1
;;;634    			bytes++;
;;;635    			buflen--;
;;;636    			rb1.rxdata--;
000636  f8926414          LDRB     r6,[r2,#0x414]  ; rb1
00063a  b289              UXTH     r1,r1                 ;635
00063c  1e76              SUBS     r6,r6,#1
00063e  f8826414          STRB     r6,[r2,#0x414]
000642  1c6d              ADDS     r5,r5,#1
                  |L1.1604|
000644  b139              CBZ      r1,|L1.1622|
000646  6896              LDR      r6,[r2,#8]            ;629  ; rb1
000648  68d7              LDR      r7,[r2,#0xc]          ;629  ; rb1
00064a  f3c60608          UBFX     r6,r6,#0,#9           ;629
00064e  f3c70708          UBFX     r7,r7,#0,#9           ;629
000652  42be              CMP      r6,r7                 ;629
000654  d1e5              BNE      |L1.1570|
                  |L1.1622|
;;;637    		}
;;;638    		//UART_IntConfig(LPC_UART1, UART_INTCFG_RBR, ENABLE);
;;;639    		LPC_UART1->IER |= UART_IER_RBRINT_EN;
000656  6860              LDR      r0,[r4,#4]
000658  f0400001          ORR      r0,r0,#1
00065c  6060              STR      r0,[r4,#4]
;;;640    		return bytes;
00065e  b2a8              UXTH     r0,r5
;;;641    }
000660  bdf0              POP      {r4-r7,pc}
;;;642    
                          ENDP

                  WaitAndFreeUartLine PROC
;;;688    
;;;689    void WaitAndFreeUartLine(void) {
000662  4818              LDR      r0,|L1.1732|
;;;690    	if EndTI(tiTx485Delay) {
000664  6801              LDR      r1,[r0,#0]  ; ti
000666  2901              CMP      r1,#1
000668  d104              BNE      |L1.1652|
;;;691    //		FreeUartLine();
;;;692    		DefFreeUartLine; // т к define
00066a  4a17              LDR      r2,|L1.1736|
00066c  210c              MOVS     r1,#0xc
00066e  65d1              STR      r1,[r2,#0x5c]
;;;693    		StopTI(tiTx485Delay);
000670  2101              MOVS     r1,#1
000672  6001              STR      r1,[r0,#0]  ; ti
                  |L1.1652|
;;;694    	}
;;;695    }
000674  4770              BX       lr
;;;696    
                          ENDP

                  __NVIC_EnableIRQ PROC
;;;1495    */
;;;1496   __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000676  2800              CMP      r0,#0
;;;1497   {
000678  db09              BLT      |L1.1678|
;;;1498     if ((int32_t)(IRQn) >= 0)
;;;1499     {
;;;1500       NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
00067a  f000021f          AND      r2,r0,#0x1f
00067e  2101              MOVS     r1,#1
000680  4091              LSLS     r1,r1,r2
000682  0940              LSRS     r0,r0,#5
000684  0080              LSLS     r0,r0,#2
000686  f10020e0          ADD      r0,r0,#0xe000e000
00068a  f8c01100          STR      r1,[r0,#0x100]
                  |L1.1678|
;;;1501     }
;;;1502   }
00068e  4770              BX       lr
;;;1503   
                          ENDP

                  __NVIC_SetPriority PROC
;;;1623    */
;;;1624   __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000690  06c9              LSLS     r1,r1,#27
;;;1625   {
;;;1626     if ((int32_t)(IRQn) >= 0)
;;;1627     {
;;;1628       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000692  0e09              LSRS     r1,r1,#24
000694  2800              CMP      r0,#0                 ;1626
000696  db04              BLT      |L1.1698|
000698  f10020e0          ADD      r0,r0,#0xe000e000     ;1625
00069c  f8801400          STRB     r1,[r0,#0x400]
;;;1629     }
;;;1630     else
;;;1631     {
;;;1632       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1633     }
;;;1634   }
0006a0  4770              BX       lr
                  |L1.1698|
0006a2  f000000f          AND      r0,r0,#0xf            ;1632
0006a6  f10020e0          ADD      r0,r0,#0xe000e000     ;1632
0006aa  f8801d14          STRB     r1,[r0,#0xd14]        ;1632
0006ae  4770              BX       lr
;;;1635   
                          ENDP

                  |L1.1712|
                          DCD      ||.data||
                  |L1.1716|
                          DCD      0x4000c000
                  |L1.1720|
                          DCD      ||.bss||
                  |L1.1724|
                          DCD      0x40010000
                  |L1.1728|
                          DCD      ||.bss||+0x418
                  |L1.1732|
                          DCD      ||ti||
                  |L1.1736|
                          DCD      0x2009c000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||rb0||
                          %        1048
                  ||rb1||
                          %        1048

                          AREA ||.data||, DATA, ALIGN=2

                  TxIntStat0
000000  00                DCB      0x00
                  TxIntStat1
000001  000000            DCB      0x00,0x00,0x00
                  Delay
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "UCNC\\UART.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_UART_c_bb43f66e____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_UART_c_bb43f66e____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_UART_c_bb43f66e____REVSH|
#line 462
|__asm___6_UART_c_bb43f66e____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_UART_c_bb43f66e____RRX|
#line 649
|__asm___6_UART_c_bb43f66e____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
